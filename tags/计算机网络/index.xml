<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>计算机网络 on Sirius&#39; Blog</title>
    <link>https://sirius1y.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
    <description>Recent content in 计算机网络 on Sirius&#39; Blog</description>
    <image>
      <title>Sirius&#39; Blog</title>
      <url>https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.127.0</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 May 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://sirius1y.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机基础知识</title>
      <link>https://sirius1y.top/posts/notes/jobhunter/cs-basic-notes/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://sirius1y.top/posts/notes/jobhunter/cs-basic-notes/</guid>
      <description>计算机网络 TCP TCP为什么要进行三次握手？ 三次握手是建立网络连接的过程，确保双方能够正确地进行数据传输。
第一次握手SYN：客户端向服务端发送SYN请求同步信号，并初始化客户端序列号；
第二次握手SYN+ACK：服务端收到了客户端发送的SYN信号后回复ACK确认收到，同时也发送SYN，指定自己的初始序列号；
第三次握手ACK：客户端收到服务端的ACK+SYN后，回复一个ACK，表示已经收到服务端的ACK+SYN。这个包的序列会加一，表示客户端已经准备好和服务端进行数据传输了。
为什么是三次握手？不是两次或者四次 原因1：阻止重复的历史连接初始化
如果是两次握手的话，因网络堵塞的问题，客户端发送了两次SYN给服务端，服务端收到了第一个SYN的时候，就回复SYN+ACK给客户端，并进入了ESTABLISHED状态。而客户端这边收到了服务端旧的ACK+SYN，会认为这是历史连接从而发送RST报文，使服务端断开连接。
原因2：同步双方的序列号
TCP协议的双方都必须要维护一个序列号。两次握手只能保证一方的序列号被接收。
原因3：避免资源浪费
如果是两次握手，那么服务端在收到SYN后回复ACK的时候就要主动建立连接，要是网络堵塞，对面发了好多个SYN来，那完蛋了，建立了好多个TCP连接，造成了资源浪费。
TCP的四次挥手 四次挥手是指在TCP断开连接的过程中发生的，一般是由客户端发起，服务端完成最后的断开。
因为TCP是全双工通信，所以需要两边都要通知对方停止数据传输，故需要四次挥手保证断开连接。
具体流程：（刚开始双方都处于ESTABLISHED状态）
1.客户端向服务端发起FIN报文，表示客户端不再发送数据；（客户端进入FIN_WAIT_1中状态）
2.服务端收到FIN报文后，回复一个ACK表示收到；（服务端进入CLOSED_WAIT状态，客户端收到ACK后进入FIN_WAIT_2状态）
3.服务端向客户端发起FIIN报文，表示服务端也不再发送数据；（服务端进入LAST_ACK状态）
4.客户端收到服务端的FIN报文后，也回复一个ACK。（客户端进入TIME_WAIT状态）
发送端在最后会进入到TIME_WAIT的状态，
为什么有TIME_WAIT状态？ 原因1：保证历史连接中的数据不会干扰下一次连接。
原因2：保证被动关闭连接。如果服务端没有TIME_WAIT状态直接close的话，要是服务端没有收到客户端最后一次发送的ACK会重发FIN，如果服务器已经处于CLOSE状态，就会返回RST报文，RST报文会被服务端认定为错误。
为什么TIME_WAIT的时间是2MSL？ MSL是报文的最大生存时间，超过这个时间的报文都会被丢弃。两个MSL时间可以保证客户端发送的ACK报文可以到达服务端+服务端要是在第一个MSL中没有收到ACK可以重发一次FIN到客户端，并保证能够到达客户端。
HTTP GET方法和POST方法有什么区别？ 用途：GET方法一般用于请求服务器上的数据；POST方法用于向服务器提交数据。
请求参数：GET方法的请求参数一般放在URL中，POST的请求参数一般放在请求体中。
幂等：多次执行相同的操作，结果都相同。
幂等行：GET方法是安全幂等的，POST不是幂等的。
缓存机制：GET请求会被浏览器主动cache，如果下一次传输的数据相同，就会返回浏览器中的内容；而POST不会。
GET的请求参数会被保存在浏览器的历史记录中，而POST中的参数不会保留
时间消耗：GET产生一个TCP数据包，浏览器会把header和data一起发送出去，服务器相应200；
POST产生两个TCP数据包，浏览器先发送hader，服务器相应100（继续发送），浏览器再发送data，服务器相应200
什么情况下会使用POST读取数据？ 当查询的数据量很多，GET方式的URL太长太大，GET方式大概是4KB，POST上限是8MB 当对数据的安全性有更高要求的时候，可以在POST的请求体中对数据进行加密 HTTP版本对比 HTTP/0.9 只支持GET方法 HTTP/1.0 支持多种请求方式 引入了请求头和响应头 引入状态码 不支持长连接
HTTP/1.1 支持长连接 管道网络传输（可以同时发送A、B请求，不必等待A响应） 但是管道网络传输存在队头阻塞的问题
头部冗余
没有请求优先级
请求只能通过客户端推送，服务器不能主动推送
HTTP/2 使用HPACK进行头部压缩 把数据部分压缩成头信息帧和数据帧 并发传输：引入了stream的概念，多个Stream复用一条TCP连接，通过streamID识别，不同stream的帧可以乱序发送 支持服务器推送 HTTPS 和HTTP对比 优点
安全性更高
缺点
HTTPS涉及到了加解密的过程，所以对服务器的负荷会高一些；
握手阶段的延迟比较高，因为还有SSL/TLS握手;
加密过程 HTTPS采用了对称加密+非对称加密的混合加密模式</description>
    </item>
    <item>
      <title>学长的计算机网络笔记</title>
      <link>https://sirius1y.top/posts/notes/network/note-network/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://sirius1y.top/posts/notes/network/note-network/</guid>
      <description>概述 互联网：专有名词
互连网：通用网络
互联网的组成 边缘部分 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。
端系统之间的两种通信方式 客户-服务器方式（C/S）
客户是服务的请求方，服务器是服务的提供方
客户软件的特点 被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址 不需要特殊的硬件和很复杂的操作系统 服务器软件的特点 一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址 一般需要强大的硬件和高级的操作系统支持 对等方式（P2P）
不区分客户和服务器。
核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）
在网络核心部分起特殊作用的是路由器 (router)。 at Shanghai University
路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。
分组交换是网络核心部分最重要的功能
电路交换 $$N$$ 部电话机两两直接相连，需 $$N(N – 1)/2$$ 对电线。这种直接连接方法所需要的电线对的数量与电话机数量的平方（ $$N^2$$ ）成正比。
当电话机的数量增多时，就要使用交换机来完成全网的分组任务，这就是电路交换
特点 电路交换必定是面向连接的 电路交换分为三个阶段： 建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用； 通话：主叫和被叫双方一直占用通信资源； 释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源） 总结 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%
分组交换 分组交换采用存储转发技术
步骤 在发送端，先把较长的报文划分成较短的、固定长度的数据段 每一个数据段前面添加上首部构成分组 (packet) 分组交换网以“分组”（也称为“包”，首部也可称为“包头”）作为数据传输单元，依次把各分组发送到接收端（假定接收端在左边） 接收端收到分组后剥去首部还原成报文 最后，在接收端把收到的数据恢复成为原来的报文。 首部的重要性 每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。 分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。 每个分组在互联网中独立地选择传输路径。（通过路由器） 用这样的存储转发方式，最后分组就能到达最终目的地。 路由器的作用 在路由器中的输入和输出端口之间没有直接连线。 路由器处理分组的过程是： 把收到的分组先放入缓存（暂时存储）； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去。 优点 高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用 灵活：为每一个分组独立地选择最合适的转发路由 迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。 可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性 缺点 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销 总结 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</description>
    </item>
  </channel>
</rss>
