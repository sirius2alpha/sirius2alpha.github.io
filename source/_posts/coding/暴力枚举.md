---
title: 暴力枚举和高精度 刷题记录
catalog: true
date: 2023-06-29
subtitle: 暴力枚举+高精度模拟，洛谷题解
lang: cn
header-img: /img/header_img/passage_bg1.jpg
tags:
- coding 
- 暴力枚举
- 高精度
- 模拟

---
## 暴力枚举

### 矩形中的正方形和长方形数目	

**洛谷P2241**

矩形：只用确定左上和右下两个点就可以确定一个矩形

正方形：固定住一个点作为正方形的左上角，就可以很轻易地数出这个点所包含的正方形数目



故，设矩形长为m，宽为n，矩形的个数：ΣiΣj(m-i)(n-j)，正方形的个数：ΣiΣj min(m-i,n-j)

注意数据的大小，可能需要开long long的数据类型。

```C++
#include <iostream>
using namespace std;
int main()
{
    int n, m;
    long long count_square = 0;
    long long count_rectangle = 0;
    long long count_marix = 0;
    cin >> n >> m;
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++){
            count_marix += (m - i) * (n - j);
            count_square += ((m - i) > (n - j) ? (n - j) : (m - i));
        }
    count_rectangle = count_marix - count_square;
    cout<<count_square<<" "<<count_rectangle;
    return 0;
}
```

### 涂国旗

**洛谷P3392**

思路：

暴力 首先预处理，算出每一行如果分别换成R/W/B需要的成本

然后两层for循环n^2的枚举前两种颜色的行数，第三种颜色就是剩下的，然后统计比较。注意每行不能小于1。

```C++
#include <iostream>
using namespace std;
int main()
{
    int n, m;
    cin >> m >> n;
    // 开一个m行n列的二维数组
    char arr[m][n];
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            cin >> arr[i][j];
    int count = 1000000;

    // 预处理，存储每行白色、蓝色、红色的个数
    int time[m][3] = {0};
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (arr[i][j] == 'W')
                time[i][0]++;
            else if (arr[i][j] == 'B')
                time[i][1]++;
            else
                time[i][2]++;

    // 暴力枚举
    // i表示白色的行号，j表示蓝色的行号，k表示红色的行号
    for (int i = 0; i < m - 2; i++)
        for (int j = i + 1; j < m - 1; j++)
        {
            int temp = 0;
            int k = m - j;
            // 计算需要涂色的次数
            for (int a = 0; a <= i; a++)
                temp += (time[a][1] + time[a][2]);
            for (int a = i + 1; a <= j; a++)
                temp += (time[a][0] + time[a][2]);
            for (int a = j + 1; a <= m-1; a++)
                temp += (time[a][0] + time[a][1]);

            if (temp <= count)
                count = temp;
        }

    cout << count;
    return 0;
}
```



### 全排列

**题目**：按照字典序输出自然数 1 到 n 所有不重复的排列，即 n 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。



这道题目采用了**深搜**完成。

**需要两个数组**

一个数组path[n]：用来存放走过的路径。当path数组走满了就进行输出。

一个数组visited[n]：用来标记哪些顶点是已经被访问过的。

**程序的思路**

依次从不同的入口进行DFS；

访问完一个顶点之后将他的visited数组进行标记，并将该顶点加入到path路径中。

**需要注意的地方**

1	DFS在每一层上都需要相对独立的visited数组和path数组，这样才能保证后续访问过了点不会影响到之后进行的同层次的点进行访问的过程，所以我在形参中采用了const来保证path和visited数组不会被改变，每次在调用函数的过程中重新定义这两个数组并进行复制赋值。

2	设置位宽是iomanip库中的setw( )函数进行设置。

```C++
// p1706
#include <iostream>
#include <iomanip>
using namespace std;

void dfs(const int path_[], const int visited_[], int n, int i, const int num)
{
    int path[num];
    int visited[num];

    for (int j = 0; j < num; j++)
    {
        path[j] = path_[j];
        visited[j] = visited_[j];
    }

    // n表示当前节点序号，i用于控制path数组的下标
    if (visited[n] == 1)
        return;

    // 访问未曾访问过的节点，将他标记为已访问，记录路径
    visited[n] = 1;
    path[i] = n + 1;
    i++;

    if (i == num)
    {
        for (int j = 0; j < num; j++)
            cout << setw(5) << path[j];
        cout << endl;
    }
    else
    {
        // 继续访问visited[n]中下一个没有访问过的节点
        for (int j = 0; j < num; j++)
            dfs(path, visited, j, i, num);
    }
}
int main()
{
    int num;
    cin >> num;

    int path[num];
    int visited[num];

    for (int i = 0; i < num; i++)
    {
        // 从每个节点开始遍历，先对path和visited数组进行初始化
        for (int i = 0; i < num; i++)
        {
            path[i] = -1;
            visited[i] = 0;
        }
        dfs(path, visited, i, 0, num);
    }
    return 0;
}
```



### 妖梦拼木棒

**洛谷P3799**

数据量很大，大概有5000行左右，第一次做的时候三层for循环，时间复杂度O(n3)太高，全部超时。

后来修改了一下，先对数据进行预处理，求出每个长度的个数并存下来，就不用每次去寻找两个一样长的木棒了。

求组合数的方法：

```CPP
// 求组合数
int C(int n, int m)
{
    int ans = 1;
    for (int i = 1; i <= m; i++)
        ans = ans * (n - i + 1) / i;
    return ans;
}
```

```cpp
#include <iostream>
using namespace std;

const int modnum = 1e9 + 7;

// 求组合数
int C(int n, int m)
{
    int ans = 1;
    for (int i = 1; i <= m; i++)
        ans = ans * (n - i + 1) / i;
    return ans;
}

int main()
{
    int n;
    cin >> n;
    int arr[n];
    int acount[n];

    for (int i = 0; i < n; i++)
    {
        cin >> arr[i];
        acount[i] = 0;
    }

    // 记录长度为arr[i]的木棒的数量
    for (int i = 0; i < n; i++)
        acount[arr[i]]++;

    // 暴力枚举

    long long count = 0;

    for (int i = 0; i < n; i++)
    {
        // i表示最长的木棒的长度
        if (acount[i] >= 2)
        {
            int times = C(acount[i], 2) % modnum;
            // 从比他们小的范围中寻找两个数，让他们之后等于arr[i]
            // j表示两根短木棒之一的长度
            for (int j = 0; j <= i / 2; j++)

                if (j == i - j && acount[j] >= 2)
                    count += (times * C(acount[j], 2) % modnum);

                else if (j != i - j && acount[j] >= 1 && acount[i - j] >= 1)
                    count += (times * C(acount[j], 1) % modnum * C(acount[i - j], 1) % modnum);
        }
    }

    count %= modnum;
    cout << count;
    return 0;
}
```





## 高精度模拟

### 爬楼梯

**洛谷P1255**

高精度加法+递推

爬楼梯的过程就是一个递推的过程，第三个阶梯的方案数，等于前面两个阶梯各自的方案数之和。

高精度加法还是通过一个数组进行实现，设一个flag进位标志，每次都把进位标志加上，加完之后把flag归0，在进行判断是否大于等于10（flag置1）。



注意：输入为0和1的输出结果比较特殊，可以先判断、二维数组的初始化。

```C++
// P1255
#include <iostream>
using namespace std;
int arr[5010][5010];

int main()
{
    int n;
    cin >> n;
    if (n == 0)
    {
        cout << 0;
        return 0;
    }
    if (n == 1)
    {
        cout << 1;
        return 0;
    }
    for (int i = 0; i < 5010; i++)
    {
        for (int j = 0; j < 5010; j++)
        {
            arr[i][j] = 0;
        }
    }

    arr[0][0] = 0;
    arr[1][0] = 1;
    arr[2][0] = 2;

    for (int i = 3; i <= n; i++)
    {
        // 斐波拉其数列，高精度加法
        int j = 0;
        int flag = 0;
        for (int j = 0; j < 5010; j++)
        {
            arr[i][j] = arr[i - 1][j] + arr[i - 2][j] + flag;
            flag = 0;
            if (arr[i][j] >= 10)
            {
                arr[i][j] -= 10;
                flag = 1;
            }
        }
    }

    // 逆序输出
    int i = 5010;
    while (arr[n][i] == 0)
        i--;
    for (; i >= 0; i--)
        cout << arr[n][i];

    return 0;
}
```

