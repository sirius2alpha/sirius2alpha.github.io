<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go学习笔记 | Sirius' Blog</title>
<meta name=keywords content="go,学习笔记"><meta name=description content='配置 Go 工作区 继续之前，请务必仔细阅读此部分。
Go 在组织项目文件方面与其他编程语言不同。 首先，Go 是在工作区的概念下工作的。 工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。
若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。
Go 工作区文件夹 每个 Go 工作区都包含三个基本文件夹：
bin：包含应用程序中的可执行文件。 src：包括位于工作站中的所有应用程序源代码。 pkg：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。 例如，工作站文件夹结构树可能与下面的示例类似：
bin/ hello coolapp pkg/ github.com/gorilla/ mux.a src/ github.com/golang/example/ .git/ hello/ hello.go
Go实战经验 在命令行中输入&rsquo;code . &lsquo;会唤起VS code编辑当前目录
源码规范 可执行文件都要包含在package main中 import的包必须都要使用，否则报错不进行编译；vs code中保存文件就会自动调整文件格式，并且删除未使用的import 整个package main中只能有一个func main() 变量的声明和初始化 Go是强类型语言，声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。
变量声明的方式有很多，格式和其他语言不太一样
最普通的方式：var 变量名称 变量类型 Go也可以像Python那样自动推断变量的类型，有些时候可以不用加类型名称 最常用的方式（只适用于在函数内，声明并初始化一个新的变量）：使用冒号等号 age := 32 注意，在函数体外还是只能用var的方式声明和初始化变量 // 变量声明 // 变量声明了必须要使用，否则编译不通过 var first string var second, third string var age int = 1 var ( fisrtly int = 1 secondly string = 2 thirdly = "123" ) var firstName, secondName, agenumber = "123", "456", 32 // 最常见的声明方式 冒号等于号 := 用于声明并初始化变量，不能用于常量的声明 firstName_, secondName_, age_ := "123", "456", 32 // 常量声明f const HTTPstatusOK = 200 const ( StatusOK = 0 StatusConnectionReset = 1 StatusOtherError = 2 ) 数据类型 基本类型：数字、字符串、布尔值 聚合类型：数组、结构体 引用类型：指针、切片、映射、函数、通道 接口类型：接口 基本类型 在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。'><meta name=author content="sirius1y"><link rel=canonical href=//localhost:1313/posts/notes/languages/go-notes/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=//localhost:1313/images/icon.png><link rel=icon type=image/png sizes=16x16 href=//localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=//localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=//localhost:1313/apple-touch-icon.png><link rel=mask-icon href=//localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=//localhost:1313/posts/notes/languages/go-notes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go学习笔记"><meta property="og:description" content='配置 Go 工作区 继续之前，请务必仔细阅读此部分。
Go 在组织项目文件方面与其他编程语言不同。 首先，Go 是在工作区的概念下工作的。 工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。
若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。
Go 工作区文件夹 每个 Go 工作区都包含三个基本文件夹：
bin：包含应用程序中的可执行文件。 src：包括位于工作站中的所有应用程序源代码。 pkg：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。 例如，工作站文件夹结构树可能与下面的示例类似：
bin/ hello coolapp pkg/ github.com/gorilla/ mux.a src/ github.com/golang/example/ .git/ hello/ hello.go
Go实战经验 在命令行中输入&rsquo;code . &lsquo;会唤起VS code编辑当前目录
源码规范 可执行文件都要包含在package main中 import的包必须都要使用，否则报错不进行编译；vs code中保存文件就会自动调整文件格式，并且删除未使用的import 整个package main中只能有一个func main() 变量的声明和初始化 Go是强类型语言，声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。
变量声明的方式有很多，格式和其他语言不太一样
最普通的方式：var 变量名称 变量类型 Go也可以像Python那样自动推断变量的类型，有些时候可以不用加类型名称 最常用的方式（只适用于在函数内，声明并初始化一个新的变量）：使用冒号等号 age := 32 注意，在函数体外还是只能用var的方式声明和初始化变量 // 变量声明 // 变量声明了必须要使用，否则编译不通过 var first string var second, third string var age int = 1 var ( fisrtly int = 1 secondly string = 2 thirdly = "123" ) var firstName, secondName, agenumber = "123", "456", 32 // 最常见的声明方式 冒号等于号 := 用于声明并初始化变量，不能用于常量的声明 firstName_, secondName_, age_ := "123", "456", 32 // 常量声明f const HTTPstatusOK = 200 const ( StatusOK = 0 StatusConnectionReset = 1 StatusOtherError = 2 ) 数据类型 基本类型：数字、字符串、布尔值 聚合类型：数组、结构体 引用类型：指针、切片、映射、函数、通道 接口类型：接口 基本类型 在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。'><meta property="og:type" content="article"><meta property="og:url" content="//localhost:1313/posts/notes/languages/go-notes/"><meta property="og:image" content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-20T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Go学习笔记"><meta name=twitter:description content='配置 Go 工作区 继续之前，请务必仔细阅读此部分。
Go 在组织项目文件方面与其他编程语言不同。 首先，Go 是在工作区的概念下工作的。 工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。
若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。
Go 工作区文件夹 每个 Go 工作区都包含三个基本文件夹：
bin：包含应用程序中的可执行文件。 src：包括位于工作站中的所有应用程序源代码。 pkg：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。 例如，工作站文件夹结构树可能与下面的示例类似：
bin/ hello coolapp pkg/ github.com/gorilla/ mux.a src/ github.com/golang/example/ .git/ hello/ hello.go
Go实战经验 在命令行中输入&rsquo;code . &lsquo;会唤起VS code编辑当前目录
源码规范 可执行文件都要包含在package main中 import的包必须都要使用，否则报错不进行编译；vs code中保存文件就会自动调整文件格式，并且删除未使用的import 整个package main中只能有一个func main() 变量的声明和初始化 Go是强类型语言，声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。
变量声明的方式有很多，格式和其他语言不太一样
最普通的方式：var 变量名称 变量类型 Go也可以像Python那样自动推断变量的类型，有些时候可以不用加类型名称 最常用的方式（只适用于在函数内，声明并初始化一个新的变量）：使用冒号等号 age := 32 注意，在函数体外还是只能用var的方式声明和初始化变量 // 变量声明 // 变量声明了必须要使用，否则编译不通过 var first string var second, third string var age int = 1 var ( fisrtly int = 1 secondly string = 2 thirdly = "123" ) var firstName, secondName, agenumber = "123", "456", 32 // 最常见的声明方式 冒号等于号 := 用于声明并初始化变量，不能用于常量的声明 firstName_, secondName_, age_ := "123", "456", 32 // 常量声明f const HTTPstatusOK = 200 const ( StatusOK = 0 StatusConnectionReset = 1 StatusOtherError = 2 ) 数据类型 基本类型：数字、字符串、布尔值 聚合类型：数组、结构体 引用类型：指针、切片、映射、函数、通道 接口类型：接口 基本类型 在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"//localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Go学习笔记","item":"//localhost:1313/posts/notes/languages/go-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go学习笔记","name":"Go学习笔记","description":"配置 Go 工作区 继续之前，请务必仔细阅读此部分。\nGo 在组织项目文件方面与其他编程语言不同。 首先，Go 是在工作区的概念下工作的。 工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。\n若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。\nGo 工作区文件夹 每个 Go 工作区都包含三个基本文件夹：\nbin：包含应用程序中的可执行文件。 src：包括位于工作站中的所有应用程序源代码。 pkg：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。 例如，工作站文件夹结构树可能与下面的示例类似：\nbin/ hello coolapp pkg/ github.com/gorilla/ mux.a src/ github.com/golang/example/ .git/ hello/ hello.go\nGo实战经验 在命令行中输入\u0026rsquo;code . \u0026lsquo;会唤起VS code编辑当前目录\n源码规范 可执行文件都要包含在package main中 import的包必须都要使用，否则报错不进行编译；vs code中保存文件就会自动调整文件格式，并且删除未使用的import 整个package main中只能有一个func main() 变量的声明和初始化 Go是强类型语言，声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。\n变量声明的方式有很多，格式和其他语言不太一样\n最普通的方式：var 变量名称 变量类型 Go也可以像Python那样自动推断变量的类型，有些时候可以不用加类型名称 最常用的方式（只适用于在函数内，声明并初始化一个新的变量）：使用冒号等号 age := 32 注意，在函数体外还是只能用var的方式声明和初始化变量 // 变量声明 // 变量声明了必须要使用，否则编译不通过 var first string var second, third string var age int = 1 var ( fisrtly int = 1 secondly string = 2 thirdly = \u0026#34;123\u0026#34; ) var firstName, secondName, agenumber = \u0026#34;123\u0026#34;, \u0026#34;456\u0026#34;, 32 // 最常见的声明方式 冒号等于号 := 用于声明并初始化变量，不能用于常量的声明 firstName_, secondName_, age_ := \u0026#34;123\u0026#34;, \u0026#34;456\u0026#34;, 32 // 常量声明f const HTTPstatusOK = 200 const ( StatusOK = 0 StatusConnectionReset = 1 StatusOtherError = 2 ) 数据类型 基本类型：数字、字符串、布尔值 聚合类型：数组、结构体 引用类型：指针、切片、映射、函数、通道 接口类型：接口 基本类型 在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。","keywords":["go","学习笔记"],"articleBody":"配置 Go 工作区 继续之前，请务必仔细阅读此部分。\nGo 在组织项目文件方面与其他编程语言不同。 首先，Go 是在工作区的概念下工作的。 工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。\n若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。\nGo 工作区文件夹 每个 Go 工作区都包含三个基本文件夹：\nbin：包含应用程序中的可执行文件。 src：包括位于工作站中的所有应用程序源代码。 pkg：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。 例如，工作站文件夹结构树可能与下面的示例类似：\nbin/ hello coolapp pkg/ github.com/gorilla/ mux.a src/ github.com/golang/example/ .git/ hello/ hello.go\nGo实战经验 在命令行中输入’code . ‘会唤起VS code编辑当前目录\n源码规范 可执行文件都要包含在package main中 import的包必须都要使用，否则报错不进行编译；vs code中保存文件就会自动调整文件格式，并且删除未使用的import 整个package main中只能有一个func main() 变量的声明和初始化 Go是强类型语言，声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。\n变量声明的方式有很多，格式和其他语言不太一样\n最普通的方式：var 变量名称 变量类型 Go也可以像Python那样自动推断变量的类型，有些时候可以不用加类型名称 最常用的方式（只适用于在函数内，声明并初始化一个新的变量）：使用冒号等号 age := 32 注意，在函数体外还是只能用var的方式声明和初始化变量 // 变量声明 // 变量声明了必须要使用，否则编译不通过 var first string var second, third string var age int = 1 var ( fisrtly int = 1 secondly string = 2 thirdly = \"123\" ) var firstName, secondName, agenumber = \"123\", \"456\", 32 // 最常见的声明方式 冒号等于号 := 用于声明并初始化变量，不能用于常量的声明 firstName_, secondName_, age_ := \"123\", \"456\", 32 // 常量声明f const HTTPstatusOK = 200 const ( StatusOK = 0 StatusConnectionReset = 1 StatusOtherError = 2 ) 数据类型 基本类型：数字、字符串、布尔值 聚合类型：数组、结构体 引用类型：指针、切片、映射、函数、通道 接口类型：接口 基本类型 在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。\nint 类型的 0（及其所有子类型，如 int64） float32 和 float64 类型的 +0.000000e+000 bool 类型的 false string 类型的空值 整数 int类型有int8, int16, int32, int64, uint8等，不同类型的数字之间进行运算需要进行显式转换\nuint，无符号整数一般只用于位运算符和特定的算术运算符，如实现位集，解析二进制格式文件，或散列和加密。\nrune 只是 int32 数据类型的别名，常常指代一个Unicode码点（code point）；\nbyte类型是uint8类型的同义词，强调一个值是原始数据，而非量值。\n算术运算符 取模运算符%，仅能用于整数，取模余数的正负号总是和被除数一致。 除法运算/，其行为取决于操作数是否都为整型，整数相除，商会舍弃小数部分。 全部的基本类型的值（布尔值、数值、字符串）都可以进行比较。\n位运算符 运算符^作为二元运算符时，表示异或（XOR）；作为一元运算符时，表示按位取反。 运算符\u0026^表示按位清除： 如表达式z=x\u0026^y，可以理解为y先取反，再与x做AND。 格式化输出 o := 0666 fmt.Printf(\"%d %[1]o %#[1]x %#[1]X\",o) 谓词%d、%o、 %x和%X，指定进位制基数和输出格式； %后面的副词[1]高速Printf重复使用第一个操作数； 副词#高速Printf输出相应的前缀0、0x或0X。 用%c输出文字符号（rune literal），如果希望有单引号输出，用%q 浮点数 Go具有两种大小的浮点数：float32和 float64。\n在十进制下，float32的有效位数大约是6位，float64有效位数大约是15位，绝大多数情况下，应该优先选择float64。\n复数 Go具备两种大小的复数complex64和complaex128，两者分别由float32和float64构成。\n内置的complex函数根据给定的实部和虚部创建复数complex(1,2)\n内置的real和imag函数分别提取复数的实部和虚部，real(x*y)，imag(x*y)\n可以使用==和!=判断复数是否等值，若两个复数的实部和虚部都相等，则他们相等。\nmath/cmplx包提供了复数运算所需的库函数，如复数的平方根函数和幂函数。\n布尔值 在 Go 中，不能将布尔类型隐式转换为 0 或 1，反之也不行。\n字符串 字符串是不可变的字节序列。\n字符串操作的4个重要标准包\nstrings strings包提供了很多用于搜索、替换、比较、修整、切分和连接字符串的函数。\nbytes 主要用于操作字节slice（[]byte类型，其某些属性和字符串相同）\nstrconv 主要用于转换布尔值、整数、浮点数为 与之对应的 字符串形式；\n或者把 字符串 转换为 布尔值、整数、浮点数；\n另外还有为字符串添加、去除引号的函数。\nunicode 主要用于判别文字符号值特性的函数，如IsDigit、IsLetter、IsUpper和IsLower。\n字符串与数字的相互转换 int64(integer32)这样转换\n使用包strconv，实现字符串和数字之间的转换\nfunc Atoi(s string) (int, error)\nAtoi is equivalent to ParseInt(s, 10, 0), converted to type int.\nfunc Itoa(i int) string\nItoa is equivalent to FormatInt(int64(i), 10).\n整数转换成字符串\nfmt.Sprintf(\"%d\",x) strconv.Itoa(x) 解释表示整数的字符串\nx, err := strconv.Atoi(\"123\") y, err := strconv.ParseInt(\"123\",10,64) 常量 常量是一种表达式，可以保证在编译阶段就可以计算出其表达式的值。\n常量声明可以同时指定类型和值，如果没有显示指定类型，则类型根据右边的表达式推断。\n常量生成器iota 在常量声明中，iota从0开始取值，逐项加一。\ntype Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 上面声明中，Sunday的值为0，Monday为1…\n无类型常量 许多常量并不从属于某一具体类型，这些值比基本类型的数字精度更高，且算术精度高于原生的及其精度，可以认为他们的精度至少达到了256位。\n借助推迟确定丛书类型，无类型常量不仅能够能暂时维持更高的精度，与类型已确定的常量相比，他们还能写进更多表达式而无需转换类型。\n例如无类型的浮点型常量math.Pi可用于任何需要浮点值或者复数的地方：\nvar x float32 = math.Pi var y float64 = math.Pi var z complex128 = math.Pi 复合数据类型 数组和结构体都是聚合类型，他们的长度都是固定的。\nslice和map都是动态数据结构，他们的长度在元素添加到结构中时可以动态增长。\n数组 如果一个数组的元素类型是可比较的，那么这个数组是可比较的，可以用==比较两个数组。\nGo把数组和其他的类型都看成值传递，而在其他的语言中，数组是隐式地使用引用传递。\n当然，也可以传递一个数组的指针给函数。\nslice slice表示一个拥有想同类型元素的可变长度的序列。slice通常写成[ ]T，其中元素的类型都是T。\n数组和slice紧密关联，slice是一种轻量级的数据结构，可以用来访问数组的部分或者全部元素，而这个数组被称为slice的底层数组。\n属性 slice有三个属性：指针、长度、容量。\n指针指向数组的第一个可以从slice中访问的元素。\n长度是指slice中的元素个数，他不能超过slice的容量。\n容量的大小通常是从slice的其实元素到底层数组的最后一个元素的个数。\nGo的内置函数len和cap可以返回slice的容量和长度。\nslice比较 和数组不同，slice无法作比较，不能用==来测试两个slice是否拥有相同的元素。\n标准库中提供了高度优化的函数butes.Equal来比较两个字节slice([ ]byte)，但对于其他类型的slice我们必须自己写函数来比较。\nslice的零值是nil，检查一个slice是否是空，正确的做法是len(s)==0，而不是s == nil，因为在s != nil的情况下，slice也有可能是空。\nmake 内置函数make可以创建一个具有指定元素类型、长度和容量的slice。\nmake([]T,len) make([]T,len,cap)\t// 和make([]cap)[:len]功能相同 第一行代码其实make创建了一个无名数组并返回了他的一个slice，这个数组只能通过slice进行访问，其中的cap可以省略，不过slice的长度和容量相等。\n第二行代码，slice值引用了数组的前len个元素，未来的slice元素留出空间。\nappend函数 内置函数append将元素追加到slice的后面。\nmap 结构体 函数 Go 中的所有可执行程序都具有此函数，因为它是程序的起点。 程序中只能有一个 main() 函数。 如果创建的是 Go 包，则无需编写 main() 函数。\n命令行参数 os.Args[0]是命令本身的名字，从1开始读取命令行参数 strconv.Atoi()函数的使用，它的返回值是两个，_在Go中表示不会用到的变量 package main import ( \"fmt\" \"os\" \"strconv\" ) func main() { // 这里的os.Args[0]是命令本身的名字，所以我们从os.Args[1]开始处理 sum := sum(os.Args[1], os.Args[2]) fmt.Println(\"Sum:\", sum) } func sum(a string, b string) int { // Atoi返回的是两个值，一个是转换后的值，一个是错误信息 numa, _ := strconv.Atoi(a) numb, _ := strconv.Atoi(b) return numa + numb } 函数返回值的强制转换 func sum(number1 string, number2 string) (result int) { int1, _ := strconv.Atoi(number1) int2, _ := strconv.Atoi(number2) result = int1 + int2 return } 返回多个值 在第一行就相当于sum和mul已经完成了声明，所以在后面不能用冒号等号运算符。\nfunc caculate(num1 string, num2 string) (sum int, mul int) { numa, _ := strconv.Atoi(num1) numb, _ := strconv.Atoi(num2) sum = numa + numb mul = numa * numb return } 指针传值 在实参上用 \u0026变量 的方式传递地址，形参用 *类型 的方式接收地址，在函数内部用 *变量 的方式读取地址中的值并进行修改。\npackage main import ( \"fmt\" \"strconv\" ) func main() { name := \"Otis\" fmt.Println(\"Hello\", name) changeName(\u0026name, \"Maeve\") fmt.Println(\"Hello\", name) } func changeName(name *string, newName string) { *name = newName return } 包 当使用 main 包时，程序将生成独立的可执行文件。 但当程序非是 main 包的一部分时，Go 不会生成二进制文件。 它生成包存档文件（具有 .a 扩展名的文件）。\n创建包 不同于其他编程语言，Go 不会提供 public 或 private 关键字，以指示是否可以从包的内外部调用变量或函数。 但 Go 须遵循以下两个简单规则：\n如需将某些内容设为专用内容，请以小写字母开始。 如需将某些内容设为公共内容，请以大写字母开始。 package calculator var logMessage = \"[LOG]\" // Version of the calculator var Version = \"1.0\" func internalSum(number int) int { return number - 1 } // Sum two integer numbers func Sum(number1, number2 int) int { return number1 + number2 } 让我们看一下该代码中的一些事项：\n只能从包内调用 logMessage 变量。 可以从任何位置访问 Version 变量。 建议你添加注释来描述此变量的用途。 （此描述适用于包的任何用户。） 只能从包内调用 internalSum 函数。 可以从任何位置访问 Sum 函数。 建议你添加注释来描述此函数的用途。 若要确认一切正常，可在 calculator 目录中运行 go build 命令。 如果执行此操作，请注意系统不会生成可执行的二进制文件。\n创建模块 在编写完成包之后，在终端中执行命令go mod init 模块名字，就会将当前的go文件打包成一个模块，想要调用这个模块中的包的内容，就要先import模块中的包名。\n控制流 if/else表达式语句 go的if条件没有小括号，但是执行体部分有大括号，又不像Python，又不像C++的。\nelse子句可选，go不支持三元运算符\n像这样：\nif i \u003e 0 { return true } // if, else if, else的使用方法 var a int = 10 if a \u003c 20 { fmt.Println(\"a is less than 20\") } else if a \u003c 30 { fmt.Println(\"a is less than 30\") } else { fmt.Println(\"a is greater than 30\") } // 这里的b是局部变量，只在if语句块中有效，和if条件用的分号隔开 if b := 20; b \u003c 30 { fmt.Println(\"b is less than 30\") } 在 Go 中，在 if 块内声明变量是惯用的方式。 这是一种使用在 Go 中常见的约定进行高效编程的方式。\nSwitch语句 switch语句的基本格式：\nswitch i{ case 0: fmt.Println(\"Zero\") case 1,3,5,7:\t// case 中可以包含多个值，可以避免代码重复的问题 fmt.Println(\"One\") default: fmt.Println(\"NO MATCH\") } for语句 // for循环的大括号是必须的 for i := 0; i \u003c 10; i++ { fmt.Println(\"for loop\") } // go没有while循环，可以用for代替 for a \u003c 20 { fmt.Println(\"while loop\") a++ } // 无限循环 var num int64 for { fmt.Println(\"infinite loop\") num = time.Now().Unix() if num%5 == 1 { fmt.Println(\"break\") break } } fmt.Println(num) 性能优化 slice 预分配内存 尽可能在使用make()创建切片的时候提供容量信息。\n// good data := make([]int, 0, size) // bad data := make([]int, 0) 这和slice的底层实现有关，提前预分配内存可以避免向slice中append的过程中不断扩容，而降低效率。\n大内存释放 在已有切片的基础上创建切片，会对原先的切片造成引用，从而不会垃圾回收浪费内存。\n可以使用copy替代re-slice。\n// bad func GetLastBySlice(origin []int) []int{ return origin[len(origin)-2:] } // good func GetLstByCopy (origin []int) []int{ result := make([]int,2) copy(result, origin[len(origin)-2:]) return result } string 字符串拼接处理 可以有三种方式处理拼接字符串，直接使用+进行拼接操作，使用StrBuilder()方法，使用ByteBuffer()方法。\nfunc Plus(n int, str string) string { s := \"\" for i:=0; i\u003cn; i++{ s += str } return s } // 性能最好 func StrBuilder(n int, str string) string{ var builder string.Builder for i:=0; i\u003cn; i++{ builder.WriteString(str) } return builder.String() } // 性能和StrBuilder差不多，稍差 func ByteBuffer(n int, str string) string{ buf := new(bytes.Buffer) for i:=0; i\u003cn; i++{ buf.WriteString(str) } return buf.String() } 字符串string在go中是不可变类型，每次使用+进行拼接都要重新开辟空间，并重新分配内存，这就导致了他的效率很低。\nStrBuilder和ByteBuffer底层都是使用[]byte数组，有内存扩容策略，不用每次都重新分配内存。\nStrBuilder在转化为字符串的时候直接将底层的[]byte转换成伟字符串进行返回；\n而ByteBuffer在转换为字符串的时候重新申请了一块空间，导致他比StrBuilder慢一点。\n性能进一步提升\n在StrBuilder和ByteBuffer方法中，提前使用builder.Grow(n*len(str))或buf.Grow(n*len(str))方法进行内存预分配。\nfunc StrBuilder(n int, str string) string{ var builder string.Builder // new builder.Grow(n*len(str)) for i:=0; i\u003cn; i++{ builder.WriteString(str) } return builder.String() } struct 空结构体 空结构体不占用任何的内存空间。\n可在各种场景当做占位符使用：\n节省内存 对于实现set，可以考虑用map进行代替；\n对于这个场景，只需要用到map的键，而不需要使用值\nfunc EmptyStructMap(n int){ m := make(map[int]struct{}) for i:=0; i\u003cn; i++{ m[i] = struct{}{} } } 多线程操作 atimic包 VS 加锁 使用atomic包\n锁的实现是通过操作系统来实现，属于系统调用 atomic操作通过硬件实现，效率比锁高 sync.Mutex应该用于保护一段逻辑，不仅仅用于保护一个变量 对于非数值操作，可以使用atomic.Value，能承载一个interface{} ","wordCount":"904","inLanguage":"en","image":"//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-06-20T00:00:00Z","dateModified":"2023-06-20T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"//localhost:1313/posts/notes/languages/go-notes/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"//localhost:1313/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=//localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=//localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=//localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=//localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=//localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=//localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=//localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=//localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go学习笔记</h1><div class=post-meta><span title='2023-06-20 00:00:00 +0000 UTC'>June 20, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;904 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#%e9%85%8d%e7%bd%ae-go-%e5%b7%a5%e4%bd%9c%e5%8c%ba aria-label="配置 Go 工作区">配置 Go 工作区</a></li><li><a href=#go-%e5%b7%a5%e4%bd%9c%e5%8c%ba%e6%96%87%e4%bb%b6%e5%a4%b9 aria-label="Go 工作区文件夹">Go 工作区文件夹</a></li><li><a href=#go%e5%ae%9e%e6%88%98%e7%bb%8f%e9%aa%8c aria-label=Go实战经验>Go实战经验</a><ul><li><a href=#%e6%ba%90%e7%a0%81%e8%a7%84%e8%8c%83 aria-label=源码规范>源码规范</a></li><li><a href=#%e5%8f%98%e9%87%8f%e7%9a%84%e5%a3%b0%e6%98%8e%e5%92%8c%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=变量的声明和初始化>变量的声明和初始化</a></li></ul></li></ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=数据类型>数据类型</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b aria-label=基本类型>基本类型</a><ul><li><a href=#%e6%95%b4%e6%95%b0 aria-label=整数>整数</a><ul><li><a href=#%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=算术运算符>算术运算符</a></li><li><a href=#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=位运算符>位运算符</a></li><li><a href=#%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba aria-label=格式化输出>格式化输出</a></li></ul></li><li><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label=浮点数>浮点数</a></li><li><a href=#%e5%a4%8d%e6%95%b0 aria-label=复数>复数</a></li><li><a href=#%e5%b8%83%e5%b0%94%e5%80%bc aria-label=布尔值>布尔值</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a><ul><li><a href=#strings aria-label=strings>strings</a></li><li><a href=#bytes aria-label=bytes>bytes</a></li><li><a href=#strconv aria-label=strconv>strconv</a></li><li><a href=#unicode aria-label=unicode>unicode</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%8e%e6%95%b0%e5%ad%97%e7%9a%84%e7%9b%b8%e4%ba%92%e8%bd%ac%e6%8d%a2 aria-label=字符串与数字的相互转换>字符串与数字的相互转换</a></li></ul></li><li><a href=#%e5%b8%b8%e9%87%8f aria-label=常量>常量</a><ul><li><a href=#%e5%b8%b8%e9%87%8f%e7%94%9f%e6%88%90%e5%99%a8iota aria-label=常量生成器iota>常量生成器iota</a></li><li><a href=#%e6%97%a0%e7%b1%bb%e5%9e%8b%e5%b8%b8%e9%87%8f aria-label=无类型常量>无类型常量</a></li></ul></li></ul></li><li><a href=#%e5%a4%8d%e5%90%88%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=复合数据类型>复合数据类型</a><ul><li><a href=#%e6%95%b0%e7%bb%84 aria-label=数组>数组</a></li><li><a href=#slice aria-label=slice>slice</a><ul><li><a href=#%e5%b1%9e%e6%80%a7 aria-label=属性>属性</a></li><li><a href=#slice%e6%af%94%e8%be%83 aria-label=slice比较>slice比较</a></li><li><a href=#make aria-label=make>make</a></li><li><a href=#append%e5%87%bd%e6%95%b0 aria-label=append函数>append函数</a></li></ul></li><li><a href=#map aria-label=map>map</a><ul><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93 aria-label=结构体>结构体</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul><ul><ul><li><a href=#%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0 aria-label=命令行参数>命令行参数</a></li><li><a href=#%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc%e7%9a%84%e5%bc%ba%e5%88%b6%e8%bd%ac%e6%8d%a2 aria-label=函数返回值的强制转换>函数返回值的强制转换</a></li><li><a href=#%e8%bf%94%e5%9b%9e%e5%a4%9a%e4%b8%aa%e5%80%bc aria-label=返回多个值>返回多个值</a></li><li><a href=#%e6%8c%87%e9%92%88%e4%bc%a0%e5%80%bc aria-label=指针传值>指针传值</a></li></ul><li><a href=#%e5%8c%85 aria-label=包>包</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e5%8c%85 aria-label=创建包>创建包</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e6%a8%a1%e5%9d%97 aria-label=创建模块>创建模块</a></li></ul></li><li><a href=#%e6%8e%a7%e5%88%b6%e6%b5%81 aria-label=控制流>控制流</a><ul><li><a href=#ifelse%e8%a1%a8%e8%be%be%e5%bc%8f%e8%af%ad%e5%8f%a5 aria-label=if/else表达式语句>if/else表达式语句</a></li><li><a href=#switch%e8%af%ad%e5%8f%a5 aria-label=Switch语句>Switch语句</a></li><li><a href=#for%e8%af%ad%e5%8f%a5 aria-label=for语句>for语句</a></li></ul></li></ul></ul></li><li><a href=#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96 aria-label=性能优化>性能优化</a><ul><li><a href=#slice-1 aria-label=slice>slice</a><ul><li><a href=#%e9%a2%84%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98 aria-label=预分配内存>预分配内存</a></li><li><a href=#%e5%a4%a7%e5%86%85%e5%ad%98%e9%87%8a%e6%94%be aria-label=大内存释放>大内存释放</a></li></ul></li><li><a href=#string aria-label=string>string</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%8b%bc%e6%8e%a5%e5%a4%84%e7%90%86 aria-label=字符串拼接处理>字符串拼接处理</a></li></ul></li><li><a href=#struct aria-label=struct>struct</a><ul><li><a href=#%e7%a9%ba%e7%bb%93%e6%9e%84%e4%bd%93 aria-label=空结构体>空结构体</a></li></ul></li><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%93%8d%e4%bd%9c aria-label=多线程操作>多线程操作</a><ul><li><a href=#atimic%e5%8c%85-vs-%e5%8a%a0%e9%94%81 aria-label="atimic包 VS 加锁">atimic包 VS 加锁</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=配置-go-工作区>配置 Go 工作区<a hidden class=anchor aria-hidden=true href=#配置-go-工作区>#</a></h2><p>继续之前，请务必仔细阅读此部分。</p><p>Go 在组织项目文件方面与其他编程语言不同。 首先，<strong>Go 是在工作区的概念下工作</strong>的。 <strong>工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。</strong> 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。</p><p>若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。</p><h2 id=go-工作区文件夹>Go 工作区文件夹<a hidden class=anchor aria-hidden=true href=#go-工作区文件夹>#</a></h2><p>每个 Go 工作区都包含三个基本文件夹：</p><ul><li><em>bin</em>：包含应用程序中的可执行文件。</li><li><em>src</em>：包括位于工作站中的所有应用程序源代码。</li><li><em>pkg</em>：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。</li></ul><p>例如，工作站文件夹结构树可能与下面的示例类似：</p><blockquote><p>bin/
hello
coolapp
pkg/
github.com/gorilla/
mux.a
src/
github.com/golang/example/
.git/
hello/
hello.go</p></blockquote><h2 id=go实战经验>Go实战经验<a hidden class=anchor aria-hidden=true href=#go实战经验>#</a></h2><p>在命令行中输入&rsquo;code . &lsquo;会唤起VS code编辑当前目录</p><h3 id=源码规范>源码规范<a hidden class=anchor aria-hidden=true href=#源码规范>#</a></h3><ul><li>可执行文件都要包含在package main中</li><li>import的包必须都要使用，否则报错不进行编译；vs code中保存文件就会自动调整文件格式，并且删除未使用的import</li><li>整个package main中只能有一个func main()</li></ul><h3 id=变量的声明和初始化>变量的声明和初始化<a hidden class=anchor aria-hidden=true href=#变量的声明和初始化>#</a></h3><p>Go是<strong>强类型语言</strong>，声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。</p><p>变量声明的方式有很多，格式和其他语言不太一样</p><ul><li>最普通的方式：var 变量名称 变量类型</li><li>Go也可以像Python那样自动推断变量的类型，有些时候可以不用加类型名称</li><li>最常用的方式（只适用于在函数内，声明并初始化一个新的变量）：使用冒号等号 age := 32</li><li>注意，在函数体外还是只能用var的方式声明和初始化变量</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 变量声明
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 变量声明了必须要使用，否则编译不通过
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>first</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>second</span><span class=p>,</span> <span class=nx>third</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>age</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>fisrtly</span>  <span class=kt>int</span>    <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>secondly</span> <span class=kt>string</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>		<span class=nx>thirdly</span>         <span class=p>=</span> <span class=s>&#34;123&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>firstName</span><span class=p>,</span> <span class=nx>secondName</span><span class=p>,</span> <span class=nx>agenumber</span> <span class=p>=</span> <span class=s>&#34;123&#34;</span><span class=p>,</span> <span class=s>&#34;456&#34;</span><span class=p>,</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 最常见的声明方式 冒号等于号 := 用于声明并初始化变量，不能用于常量的声明
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>firstName_</span><span class=p>,</span> <span class=nx>secondName_</span><span class=p>,</span> <span class=nx>age_</span> <span class=o>:=</span> <span class=s>&#34;123&#34;</span><span class=p>,</span> <span class=s>&#34;456&#34;</span><span class=p>,</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 常量声明f
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>const</span> <span class=nx>HTTPstatusOK</span> <span class=p>=</span> <span class=mi>200</span>
</span></span><span class=line><span class=cl>	<span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>StatusOK</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=nx>StatusConnectionReset</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>StatusOtherError</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span> 
</span></span></code></pre></div><h1 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h1><ul><li>基本类型：数字、字符串、布尔值</li><li>聚合类型：数组、结构体</li><li>引用类型：指针、切片、映射、函数、通道</li><li>接口类型：接口</li></ul><h2 id=基本类型>基本类型<a hidden class=anchor aria-hidden=true href=#基本类型>#</a></h2><p>在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。</p><ul><li>int 类型的 0（及其所有子类型，如 int64）</li><li>float32 和 float64 类型的 +0.000000e+000</li><li>bool 类型的 false</li><li>string 类型的空值</li></ul><h3 id=整数>整数<a hidden class=anchor aria-hidden=true href=#整数>#</a></h3><p>int类型有int8, int16, int32, int64, uint8等，不同类型的数字之间进行运算需要进行显式转换</p><p>uint，无符号整数一般只用于位运算符和特定的算术运算符，如实现位集，解析二进制格式文件，或散列和加密。</p><p>rune 只是 int32 数据类型的别名，常常指代一个Unicode码点（code point）；</p><p>byte类型是uint8类型的同义词，强调一个值是原始数据，而非量值。</p><h4 id=算术运算符>算术运算符<a hidden class=anchor aria-hidden=true href=#算术运算符>#</a></h4><ul><li>取模运算符%，仅能用于整数，取模余数的正负号总是和被除数一致。</li><li>除法运算/，其行为取决于操作数是否都为整型，整数相除，商会舍弃小数部分。</li></ul><p>全部的<strong>基本类型</strong>的值（布尔值、数值、字符串）都可以进行比较。</p><h4 id=位运算符>位运算符<a hidden class=anchor aria-hidden=true href=#位运算符>#</a></h4><ul><li>运算符^作为二元运算符时，表示异或（XOR）；作为一元运算符时，表示按位取反。</li><li>运算符&^表示按位清除：
如表达式z=x&^y，可以理解为y先取反，再与x做AND。</li></ul><h4 id=格式化输出>格式化输出<a hidden class=anchor aria-hidden=true href=#格式化输出>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>o</span> <span class=o>:=</span> <span class=mo>0666</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d %[1]o %#[1]x %#[1]X&#34;</span><span class=p>,</span><span class=nx>o</span><span class=p>)</span>
</span></span></code></pre></div><ul><li>谓词%d、%o、 %x和%X，指定进位制基数和输出格式；</li><li>%后面的副词[1]高速Printf重复使用第一个操作数；</li><li>副词#高速Printf输出相应的前缀0、0x或0X。</li><li>用%c输出文字符号（rune literal），如果希望有单引号输出，用%q</li></ul><h3 id=浮点数>浮点数<a hidden class=anchor aria-hidden=true href=#浮点数>#</a></h3><p>Go具有两种大小的浮点数：float32和 float64。</p><p>在十进制下，float32的有效位数大约是6位，float64有效位数大约是15位，绝大多数情况下，应该<strong>优先选择float64</strong>。</p><h3 id=复数>复数<a hidden class=anchor aria-hidden=true href=#复数>#</a></h3><p>Go具备两种大小的复数complex64和complaex128，两者分别由float32和float64构成。</p><p>内置的complex函数根据给定的实部和虚部创建复数<code>complex(1,2)</code></p><p>内置的real和imag函数分别提取复数的实部和虚部，<code>real(x*y)</code>，<code>imag(x*y)</code></p><p>可以使用==和!=判断复数是否等值，若两个复数的实部和虚部都相等，则他们相等。</p><p>math/cmplx包提供了复数运算所需的库函数，如复数的平方根函数和幂函数。</p><h3 id=布尔值>布尔值<a hidden class=anchor aria-hidden=true href=#布尔值>#</a></h3><p>在 Go 中，不能将布尔类型隐式转换为 0 或 1，反之也不行。</p><h3 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h3><p>字符串是不可变的字节序列。</p><p><strong>字符串操作的4个重要标准包</strong></p><h4 id=strings>strings<a hidden class=anchor aria-hidden=true href=#strings>#</a></h4><p>strings包提供了很多用于搜索、替换、比较、修整、切分和连接字符串的函数。</p><h4 id=bytes>bytes<a hidden class=anchor aria-hidden=true href=#bytes>#</a></h4><p>主要用于操作字节slice（[]byte类型，其某些属性和字符串相同）</p><h4 id=strconv>strconv<a hidden class=anchor aria-hidden=true href=#strconv>#</a></h4><p>主要用于转换布尔值、整数、浮点数为 与之对应的 字符串形式；</p><p>或者把 字符串 转换为 布尔值、整数、浮点数；</p><p>另外还有为字符串添加、去除引号的函数。</p><h4 id=unicode>unicode<a hidden class=anchor aria-hidden=true href=#unicode>#</a></h4><p>主要用于判别文字符号值特性的函数，如IsDigit、IsLetter、IsUpper和IsLower。</p><h4 id=字符串与数字的相互转换>字符串与数字的相互转换<a hidden class=anchor aria-hidden=true href=#字符串与数字的相互转换>#</a></h4><ul><li><p>int64(integer32)这样转换</p></li><li><p>使用包strconv，实现字符串和数字之间的转换</p><ul><li><p>func Atoi(s string) (int, error)</p><p>Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.</p></li><li><p>func Itoa(i int) string</p><p>Itoa is equivalent to FormatInt(int64(i), 10).</p></li></ul></li></ul><p><strong>整数转换成字符串</strong></p><ul><li><code>fmt.Sprintf("%d",x)</code></li><li><code>strconv.Itoa(x)</code></li></ul><p><strong>解释表示整数的字符串</strong></p><ul><li><code>x, err := strconv.Atoi("123")</code></li><li><code>y, err := strconv.ParseInt("123",10,64)</code></li></ul><h3 id=常量>常量<a hidden class=anchor aria-hidden=true href=#常量>#</a></h3><p>常量是一种表达式，可以保证在编译阶段就可以计算出其表达式的值。</p><p>常量声明可以同时指定类型和值，如果没有显示指定类型，则类型根据右边的表达式推断。</p><h4 id=常量生成器iota>常量生成器iota<a hidden class=anchor aria-hidden=true href=#常量生成器iota>#</a></h4><p>在常量声明中，iota从0开始取值，逐项加一。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Weekday</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>Sunday</span> <span class=nx>Weekday</span> <span class=p>=</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>	<span class=nx>Monday</span>
</span></span><span class=line><span class=cl>	<span class=nx>Tuesday</span>
</span></span><span class=line><span class=cl>	<span class=nx>Wednesday</span>
</span></span><span class=line><span class=cl>	<span class=nx>Thursday</span>
</span></span><span class=line><span class=cl>	<span class=nx>Friday</span>
</span></span><span class=line><span class=cl>	<span class=nx>Saturday</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>上面声明中，Sunday的值为0，Monday为1&mldr;</p><h4 id=无类型常量>无类型常量<a hidden class=anchor aria-hidden=true href=#无类型常量>#</a></h4><p>许多常量并不从属于某一具体类型，这些值比基本类型的数字精度更高，且算术精度高于原生的及其精度，可以认为他们的精度至少达到了256位。</p><p>借助推迟确定丛书类型，无类型常量不仅能够能暂时维持更高的精度，与类型已确定的常量相比，他们还能写进更多表达式而无需转换类型。</p><p>例如无类型的浮点型常量math.Pi可用于任何需要浮点值或者复数的地方：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>x</span> <span class=kt>float32</span> <span class=p>=</span> <span class=nx>math</span><span class=p>.</span><span class=nx>Pi</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>y</span> <span class=kt>float64</span> <span class=p>=</span> <span class=nx>math</span><span class=p>.</span><span class=nx>Pi</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>z</span> <span class=kt>complex128</span> <span class=p>=</span> <span class=nx>math</span><span class=p>.</span><span class=nx>Pi</span>
</span></span></code></pre></div><h2 id=复合数据类型>复合数据类型<a hidden class=anchor aria-hidden=true href=#复合数据类型>#</a></h2><p>数组和结构体都是聚合类型，他们的长度都是固定的。</p><p>slice和map都是动态数据结构，他们的长度在元素添加到结构中时可以动态增长。</p><h3 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h3><p>如果一个数组的元素类型是可比较的，那么这个数组是可比较的，可以用==比较两个数组。</p><p>Go把数组和其他的类型都看成值传递，而在其他的语言中，数组是隐式地使用引用传递。</p><p>当然，也可以传递一个数组的指针给函数。</p><h3 id=slice>slice<a hidden class=anchor aria-hidden=true href=#slice>#</a></h3><p>slice表示一个拥有想同类型元素的可变长度的序列。slice通常写成[ ]T，其中元素的类型都是T。</p><p>数组和slice紧密关联，slice是一种轻量级的数据结构，可以用来访问数组的部分或者全部元素，而这个数组被称为slice的底层数组。</p><h4 id=属性>属性<a hidden class=anchor aria-hidden=true href=#属性>#</a></h4><p>slice有三个属性：指针、长度、容量。</p><ul><li><p>指针指向数组的第一个可以从slice中访问的元素。</p></li><li><p>长度是指slice中的元素个数，他不能超过slice的容量。</p></li><li><p>容量的大小通常是从slice的其实元素到底层数组的最后一个元素的个数。</p></li></ul><p>Go的内置函数len和cap可以返回slice的容量和长度。</p><h4 id=slice比较>slice比较<a hidden class=anchor aria-hidden=true href=#slice比较>#</a></h4><p>和数组不同，slice无法作比较，不能用==来测试两个slice是否拥有相同的元素。</p><p>标准库中提供了高度优化的函数butes.Equal来比较两个字节slice([ ]byte)，但对于其他类型的slice我们必须自己写函数来比较。</p><p>slice的零值是nil，检查一个slice是否是空，正确的做法是len(s)==0，而不是s == nil，因为在s != nil的情况下，slice也有可能是空。</p><h4 id=make>make<a hidden class=anchor aria-hidden=true href=#make>#</a></h4><p>内置函数make可以创建一个具有指定元素类型、长度和容量的slice。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nb>make</span><span class=p>([]</span><span class=nx>T</span><span class=p>,</span><span class=nx>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>make</span><span class=p>([]</span><span class=nx>T</span><span class=p>,</span><span class=nx>len</span><span class=p>,</span><span class=nx>cap</span><span class=p>)</span>		<span class=c1>// 和make([]cap)[:len]功能相同
</span></span></span></code></pre></div><p>第一行代码其实make创建了一个无名数组并返回了他的一个slice，这个数组只能通过slice进行访问，其中的cap可以省略，不过slice的长度和容量相等。</p><p>第二行代码，slice值引用了数组的前len个元素，未来的slice元素留出空间。</p><h4 id=append函数>append函数<a hidden class=anchor aria-hidden=true href=#append函数>#</a></h4><p>内置函数append将元素追加到slice的后面。</p><h3 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3><h4 id=结构体>结构体<a hidden class=anchor aria-hidden=true href=#结构体>#</a></h4><h1 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h1><p>Go 中的所有可执行程序都具有此函数，因为它是程序的起点。 程序中只能有一个 main() 函数。 如果创建的是 Go 包，则无需编写 main() 函数。</p><h4 id=命令行参数>命令行参数<a hidden class=anchor aria-hidden=true href=#命令行参数>#</a></h4><ul><li>os.Args[0]是命令本身的名字，从1开始读取命令行参数</li><li>strconv.Atoi()函数的使用，它的返回值是两个，_在Go中表示不会用到的变量</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;strconv&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 这里的os.Args[0]是命令本身的名字，所以我们从os.Args[1]开始处理
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sum</span> <span class=o>:=</span> <span class=nf>sum</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Sum:&#34;</span><span class=p>,</span> <span class=nx>sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sum</span><span class=p>(</span><span class=nx>a</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Atoi返回的是两个值，一个是转换后的值，一个是错误信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>numa</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>numb</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>numa</span> <span class=o>+</span> <span class=nx>numb</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=函数返回值的强制转换>函数返回值的强制转换<a hidden class=anchor aria-hidden=true href=#函数返回值的强制转换>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sum</span><span class=p>(</span><span class=nx>number1</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>number2</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>result</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>int1</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>number1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>int2</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>number2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=p>=</span> <span class=nx>int1</span> <span class=o>+</span> <span class=nx>int2</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=返回多个值>返回多个值<a hidden class=anchor aria-hidden=true href=#返回多个值>#</a></h4><p>在第一行就相当于sum和mul已经完成了声明，所以在后面不能用冒号等号运算符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>caculate</span><span class=p>(</span><span class=nx>num1</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>num2</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>sum</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>mul</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>numa</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>num1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>numb</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>num2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sum</span> <span class=p>=</span> <span class=nx>numa</span> <span class=o>+</span> <span class=nx>numb</span>
</span></span><span class=line><span class=cl>	<span class=nx>mul</span> <span class=p>=</span> <span class=nx>numa</span> <span class=o>*</span> <span class=nx>numb</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=指针传值>指针传值<a hidden class=anchor aria-hidden=true href=#指针传值>#</a></h4><p>在实参上用 &变量 的方式传递地址，形参用 *类型 的方式接收地址，在函数内部用 *变量 的方式读取地址中的值并进行修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;strconv&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>name</span> <span class=o>:=</span> <span class=s>&#34;Otis&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>changeName</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>name</span><span class=p>,</span> <span class=s>&#34;Maeve&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>changeName</span><span class=p>(</span><span class=nx>name</span> <span class=o>*</span><span class=kt>string</span><span class=p>,</span> <span class=nx>newName</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>name</span> <span class=p>=</span> <span class=nx>newName</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=包>包<a hidden class=anchor aria-hidden=true href=#包>#</a></h3><p>当使用 main 包时，程序将生成独立的可执行文件。 但当程序非是 main 包的一部分时，Go 不会生成二进制文件。 它生成包存档文件（具有 .a 扩展名的文件）。</p><h4 id=创建包>创建包<a hidden class=anchor aria-hidden=true href=#创建包>#</a></h4><p>不同于其他编程语言，Go 不会提供 public 或 private 关键字，以指示是否可以从包的内外部调用变量或函数。 但 Go 须遵循以下两个简单规则：</p><ul><li>如需将某些内容设为专用内容，请以小写字母开始。</li><li>如需将某些内容设为公共内容，请以大写字母开始。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>calculator</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>logMessage</span> <span class=p>=</span> <span class=s>&#34;[LOG]&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Version of the calculator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>Version</span> <span class=p>=</span> <span class=s>&#34;1.0&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>internalSum</span><span class=p>(</span><span class=nx>number</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>number</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Sum two integer numbers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Sum</span><span class=p>(</span><span class=nx>number1</span><span class=p>,</span> <span class=nx>number2</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>number1</span> <span class=o>+</span> <span class=nx>number2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>让我们看一下该代码中的一些事项：</p><ul><li>只能从包内调用 <code>logMessage</code> 变量。</li><li>可以从任何位置访问 <code>Version</code> 变量。 建议你添加注释来描述此变量的用途。 （此描述适用于包的任何用户。）</li><li>只能从包内调用 <code>internalSum</code> 函数。</li><li>可以从任何位置访问 <code>Sum</code> 函数。 建议你添加注释来描述此函数的用途。</li></ul><p>若要确认一切正常，可在 <code>calculator</code> 目录中运行 <code>go build</code> 命令。 如果执行此操作，请注意系统不会生成可执行的二进制文件。</p><h4 id=创建模块>创建模块<a hidden class=anchor aria-hidden=true href=#创建模块>#</a></h4><p>在编写完成包之后，在终端中执行命令<code>go mod init 模块名字</code>，就会将当前的go文件打包成一个模块，想要调用这个模块中的包的内容，就要先import模块中的包名。</p><h3 id=控制流>控制流<a hidden class=anchor aria-hidden=true href=#控制流>#</a></h3><h4 id=ifelse表达式语句>if/else表达式语句<a hidden class=anchor aria-hidden=true href=#ifelse表达式语句>#</a></h4><p>go的if条件没有小括号，但是执行体部分有大括号，又不像Python，又不像C++的。</p><p>else子句可选，go不支持三元运算符</p><p>像这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// if, else if, else的使用方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>a</span> <span class=p>&lt;</span> <span class=mi>20</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a is less than 20&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>a</span> <span class=p>&lt;</span> <span class=mi>30</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a is less than 30&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a is greater than 30&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这里的b是局部变量，只在if语句块中有效，和if条件用的分号隔开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>b</span> <span class=o>:=</span> <span class=mi>20</span><span class=p>;</span> <span class=nx>b</span> <span class=p>&lt;</span> <span class=mi>30</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b is less than 30&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 Go 中，在 if 块内声明变量是惯用的方式。 这是一种使用在 Go 中常见的约定进行高效编程的方式。</p><h4 id=switch语句>Switch语句<a hidden class=anchor aria-hidden=true href=#switch语句>#</a></h4><p>switch语句的基本格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>switch</span> <span class=nx>i</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Zero&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>7</span><span class=p>:</span>	<span class=c1>// case 中可以包含多个值，可以避免代码重复的问题
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;One&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;NO MATCH&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=for语句>for语句<a hidden class=anchor aria-hidden=true href=#for语句>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// for循环的大括号是必须的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;for loop&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// go没有while循环，可以用for代替
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>a</span> <span class=p>&lt;</span> <span class=mi>20</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;while loop&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 无限循环
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>num</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;infinite loop&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>num</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Unix</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>num</span><span class=o>%</span><span class=mi>5</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;break&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
</span></span></code></pre></div><h1 id=性能优化>性能优化<a hidden class=anchor aria-hidden=true href=#性能优化>#</a></h1><h2 id=slice-1>slice<a hidden class=anchor aria-hidden=true href=#slice-1>#</a></h2><h3 id=预分配内存>预分配内存<a hidden class=anchor aria-hidden=true href=#预分配内存>#</a></h3><p>尽可能在使用make()创建切片的时候提供容量信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>data</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>data</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><p>这和slice的底层实现有关，提前预分配内存可以避免向slice中append的过程中不断扩容，而降低效率。</p><h3 id=大内存释放>大内存释放<a hidden class=anchor aria-hidden=true href=#大内存释放>#</a></h3><p>在已有切片的基础上创建切片，会对原先的切片造成引用，从而不会垃圾回收浪费内存。</p><p>可以使用copy替代re-slice。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>GetLastBySlice</span><span class=p>(</span><span class=nx>origin</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>origin</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>origin</span><span class=p>)</span><span class=o>-</span><span class=mi>2</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>GetLstByCopy</span> <span class=p>(</span><span class=nx>origin</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nb>copy</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>origin</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>origin</span><span class=p>)</span><span class=o>-</span><span class=mi>2</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=string>string<a hidden class=anchor aria-hidden=true href=#string>#</a></h2><h3 id=字符串拼接处理>字符串拼接处理<a hidden class=anchor aria-hidden=true href=#字符串拼接处理>#</a></h3><p>可以有三种方式处理拼接字符串，直接使用+进行拼接操作，使用StrBuilder()方法，使用ByteBuffer()方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Plus</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>str</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>s</span> <span class=o>+=</span> <span class=nx>str</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 性能最好
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>StrBuilder</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>str</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>builder</span> <span class=kt>string</span><span class=p>.</span><span class=nx>Builder</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>builder</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nx>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>builder</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 性能和StrBuilder差不多，稍差
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>ByteBuffer</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>str</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>buf</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nx>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>buf</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>字符串string在go中是不可变类型，每次使用+进行拼接都要重新开辟空间，并重新分配内存，这就导致了他的效率很低。</p><p>StrBuilder和ByteBuffer底层都是使用[]byte数组，有内存扩容策略，不用每次都重新分配内存。</p><p>StrBuilder在转化为字符串的时候直接将底层的[]byte转换成伟字符串进行返回；</p><p>而ByteBuffer在转换为字符串的时候重新申请了一块空间，导致他比StrBuilder慢一点。</p><p><strong>性能进一步提升</strong></p><p>在StrBuilder和ByteBuffer方法中，提前使用builder.Grow(n*len(str))或buf.Grow(n*len(str))方法进行内存预分配。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>StrBuilder</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>str</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>builder</span> <span class=kt>string</span><span class=p>.</span><span class=nx>Builder</span>
</span></span><span class=line><span class=cl>    <span class=c1>// new
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>builder</span><span class=p>.</span><span class=nf>Grow</span><span class=p>(</span><span class=nx>n</span><span class=o>*</span><span class=nb>len</span><span class=p>(</span><span class=nx>str</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>builder</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nx>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>builder</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=struct>struct<a hidden class=anchor aria-hidden=true href=#struct>#</a></h2><h3 id=空结构体>空结构体<a hidden class=anchor aria-hidden=true href=#空结构体>#</a></h3><p>空结构体不占用任何的内存空间。</p><p>可在各种场景当做占位符使用：</p><ul><li>节省内存</li></ul><p>对于实现set，可以考虑用map进行代替；</p><p>对于这个场景，只需要用到map的键，而不需要使用值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>EmptyStructMap</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>m</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=多线程操作>多线程操作<a hidden class=anchor aria-hidden=true href=#多线程操作>#</a></h2><h3 id=atimic包-vs-加锁>atimic包 VS 加锁<a hidden class=anchor aria-hidden=true href=#atimic包-vs-加锁>#</a></h3><p>使用atomic包</p><ul><li>锁的实现是通过操作系统来实现，属于系统调用</li><li>atomic操作通过硬件实现，效率比锁高</li><li>sync.Mutex应该用于保护一段逻辑，不仅仅用于保护一个变量</li><li>对于非数值操作，可以使用atomic.Value，能承载一个interface{}</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=//localhost:1313/tags/go/>Go</a></li><li><a href=//localhost:1313/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a></li></ul><nav class=paginav><a class=prev href=//localhost:1313/posts/notes/languages/go-stdlib-notes/><span class=title>« Prev</span><br><span>Go log库，encoding/json</span>
</a><a class=next href=//localhost:1313/posts/notes/security/csrf-attack/><span class=title>Next »</span><br><span>CSRF攻击</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2024 <a href=//localhost:1313/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>