<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git正确使用姿势 | Sirius' Blog</title>
<meta name=keywords content="git"><meta name=description content="记录使用git的常用命令，以及对git的工作模式进行简单讲解"><meta name=author content="sirius1y"><link rel=canonical href=//localhost:1313/posts/notes/dev/%E6%8C%87%E5%8D%97%E5%9B%A2%E9%98%9Fgit%E5%8D%8F%E4%BD%9C/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=//localhost:1313/images/icon.png><link rel=icon type=image/png sizes=16x16 href=//localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=//localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=//localhost:1313/apple-touch-icon.png><link rel=mask-icon href=//localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=//localhost:1313/posts/notes/dev/%E6%8C%87%E5%8D%97%E5%9B%A2%E9%98%9Fgit%E5%8D%8F%E4%BD%9C/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Git正确使用姿势"><meta property="og:description" content="记录使用git的常用命令，以及对git的工作模式进行简单讲解"><meta property="og:type" content="article"><meta property="og:url" content="//localhost:1313/posts/notes/dev/%E6%8C%87%E5%8D%97%E5%9B%A2%E9%98%9Fgit%E5%8D%8F%E4%BD%9C/"><meta property="og:image" content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-27T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-27T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Git正确使用姿势"><meta name=twitter:description content="记录使用git的常用命令，以及对git的工作模式进行简单讲解"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"//localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Git正确使用姿势","item":"//localhost:1313/posts/notes/dev/%E6%8C%87%E5%8D%97%E5%9B%A2%E9%98%9Fgit%E5%8D%8F%E4%BD%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git正确使用姿势","name":"Git正确使用姿势","description":"记录使用git的常用命令，以及对git的工作模式进行简单讲解","keywords":["git"],"articleBody":"Git正确使用姿势 Git工作区域和流程 工作区域 **远程仓库：**就是我们托管在github或者其他代码托管平台上的仓库。\n**本地仓库：**就是在我们本地通过git init命令初始化的新建的仓库。\n**工作区：**就是我们写代码、编辑文件的地方。\n**暂存区：**当工作区的内容写好了之后，就会通过add命令，将工作区的内容放到暂存区，等待commit命令提交到本地仓库中。\n文件状态 **未跟踪的（untracked）：**表示在工作区新建了某个文件，还没有add。 **已修改（modofied）：**表示在工作区中修改了某个文件，还没有 add。 **已暂存（staged）：**表示把已修改的文件已add到暂存区域。 **已提交（commit）：**表示文件已经commit到本地仓库保存起来了。 Git常见命令 仓库初始化和克隆 # git仓库初始化 git init # 从远程仓库中进行克隆代码到本地仓库 git clone [远程仓库的HTTP/SSH的URL] # 查看当前git仓库的状态 git status 远程仓库管理 Git正确使用姿势 Git工作区域和流程 工作区域 远程仓库： 就是我们托管在github或者其他代码托管平台上的仓库。 本地仓库： 就是在我们本地通过git init命令初始化的新建的仓库。 工作区# git remote 是用来管理远程仓库的命令 git remote\t# 查看已配置的远程仓库 git remote -v # 查看远程仓库的URL git remote add \u003c远程仓库名称\u003e \u003c远程仓库URL\u003e\t# 添加一个新的远程仓库 # e.g git remote add origin \u003c远程仓库URL\u003e，一般采用origin作为远程仓库的名字 git remote remove origin # 删除名为origin的远程仓库 git remote rename origin newname # 将origin的名字改为newname # 设置本地仓库的上游分支 git branch --set-upstream-to=origin/main main # 给本地仓库的分支重命名 ## 把master分支更名为main分支 git branch -m master main 从工作区提交代码到远程仓库 # git add 将更改过的代码添加到暂存区 git add .\t# 将工作区中所有更改添加到暂存区 git add index.html\t# 添加更改的单个文件到暂存区 git add src/\t# 添加该目录下的更改到暂存区 # git commit 将暂存区的代码提交到本地仓库 git commit -m \"提交说明\"\t# 最常用的提交方式，一定要写提交说明，不然版本管理会非常痛苦 # git push 用于将本地的代码提交推送到远程仓库，将本地仓库中的提交上传到Git服务器上，使其成为远程仓库的一部分 git push \u003c远程仓库名称\u003e \u003c本地分支名称\u003e:\u003c远程分支名称\u003e git push -f origin master\t# 强制推送到origin的master分支，远程仓库origin的master分支上的之前的代码会被覆盖！非常危险的操作！ \u003c远程仓库名称\u003e：指定要推送到的远程仓库的名称，通常为\"origin\"，这是Git默认的远程仓库名称。 \u003c本地分支名称\u003e：指定要推送的本地分支的名称，这是你当前所在的分支，例如\"main\"、“master\"等。 \u003c远程分支名称\u003e：指定远程仓库中要接收提交的分支名称。 默认情况下，git push命令会将当前分支的代码推送到与之相对应的远程分支。例如，如果你当前在\"main\"分支上，并且与远程仓库\"origin\"关联，那么git push origin main命令将把\"main\"分支的提交推送到\"origin\"的\"main\"分支；如果远程分支不存在，则git push会自动创建一个新的远程分支。\n从远程仓库中拉取代码 fetch git fetch命令用于从远程仓库获取最新的代码提交和分支信息，但它不会将获取到的内容应用到你的工作目录或当前分支，也不会改变你本地仓库的历史记录。相当于是将远程仓库的最新信息下载到你的本地仓库，你可以通过git merge或git rebase将这些更新合并到你的当前分支。\n以下是git fetch命令的用法：\ngit fetch \u003c远程仓库名称\u003e 在执行命令时，Git会连接到指定的远程仓库，并获取远程仓库中最新的分支和提交信息。它会将获取到的内容保存在本地仓库的\"FETCH_HEAD\"引用中。\n关于git merge和git rebase的区别在这里引用了另外一个博主的文章进行介绍。\n文章原链接：https://blog.csdn.net/kevinxxw/article/details/123980372\nmerge 将 master 分支合并到 feature 分支最简单的办法就是用下面这些命令：\ngit checkout feature git merge master 也可以把它们压缩在一行里。\ngit merge master feature feature 分支中新的合并提交（merge commit）将两个分支的历史连在了一起。你会得到下面这样的分支结构：\nrebase 作为 merge 的替代选择，你可以像下面这样将 feature 分支并入 master 分支：\ngit checkout feature git rebase master 它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。\n关于git rebase的黄金法则就是永远不要在公共分支上使用它。\nrebase最大的好处是你的项目历史会非常整洁。首先，它不像 git merge 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史。\n不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。\n交互式rebase 交互式的 rebase 允许你更改并入新分支的提交。这比自动的 rebase 更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将 feature 分支并入 master 分支之前，清理混乱的历史。\n把 -i 传入 git rebase 选项来开始一个交互式的rebase过程：\ngit checkout feature git rebase -i master 它会打开一个文本编辑器，显示所有将被移动的提交：\npick 33d5b7a Message for commit #1 pick 9480b3d Message for commit #2 pick 5c67e61 Message for commit #3 这个列表定义了 rebase 将被执行后分支会是什么样的。更改 pick 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个提交修复了第一个提交中的小问题，你可以用 fixup 命令把它们合到一个提交中：\npick 33d5b7a Message for commit #1 fixup 9480b3d Message for commit #2 pick 5c67e61 Message for commit #3 保存后关闭文件，Git 会根据你的指令来执行 rebase，项目历史看上去会是这样：\n忽略不重要的提交会让你的 feature 分支的历史更清晰易读。这是 git merge 做不到的。\n分支管理 # git branch 命令用于查看、创建和管理分支 git branch # 查看本地所有分支 git branch -a\t# 查看本地和远程的分支 git branch \u003c新分支名称\u003e\t# 创建一个新分支 git branch -d \u003c分支名称\u003e\t# 删除一个分支 git branch -D \u003c分支名称\u003e # 强制删除一个分支 # git checkout 用于在Git中切换分支、查看文件的不同版本或还原文件到之前的状态 关于git rebase的黄金法则就是永远不要在公共分支上使用它。 git checkout \u003c分支名称\u003e\t# 切换到其他分支上 # 新版本git中采用git switch \u003c分支名称\u003e 切换分支 git checkout \u003c文件名\u003e\t# 查看文件的不同版本 git checkout -- \u003c文件名\u003e\t# 还原文件到之前的状态 清空暂存区 git reset # 所有文件的变更撤销 如何进行团队协作 建立仓库 在github上建立组织和仓库，看起来也酷酷的；\n在组织里面新建一个仓库。\n添加SSH秘钥 最好是使用SSH，所以在仓库里面添加上各位团队成员的SSH秘钥\nSSH秘钥的生成 在Windows上 打开Windows PowerShell或者Git Bash（如果你已经安装了Git）。 输入以下命令来生成SSH密钥对： ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" -t rsa: 指定生成RSA密钥对。 -b 4096: 指定密钥的位数。4096位提供更高的安全性，但生成时间可能稍长。 -C \"your_email@example.com\": 用你的邮箱地址替换这部分内容，这将作为你的密钥的注释。 系统会提示你选择密钥保存的位置，默认会保存在~/.ssh目录下，你可以按照提示选择保存位置或直接回车使用默认位置。 然后系统会让你输入一个密码来保护你的私钥。这是可选的，如果你不想设置密码，可以直接回车跳过。 在Ubuntu上 打开终端（Terminal）。 输入以下命令来生成SSH密钥对： ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" -t rsa: 指定生成RSA密钥对。 -b 4096: 指定密钥的位数。4096位提供更高的安全性，但生成时间可能稍长。 -C \"your_email@example.com\": 用你的邮箱地址替换这部分内容，这将作为你的密钥的注释。 系统会提示你选择密钥保存的位置，默认会保存在~/.ssh目录下，你可以按照提示选择保存位置或直接回车使用默认位置。 然后系统会让你输入一个密码来保护你的私钥。这是可选的，如果你不想设置密码，可以直接回车跳过。 完成上述步骤后，你会在指定的位置（默认为~/.ssh目录）找到生成的SSH密钥对。其中，私钥文件为id_rsa，公钥文件为id_rsa.pub。将公钥文件（id_rsa.pub）的内容复制并粘贴到需要使用该SSH密钥的服务器或Git托管服务中，以便进行身份验证。私钥文件请妥善保管，不要分享给他人，以保障账户的安全性。\nJust do it! 剩下就是团队一起约定项目开发计划是什么呀？\n变量命名要遵循什么规则啊？\n大家一起加油吧！\n","wordCount":"424","inLanguage":"en","image":"//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-08-27T00:00:00Z","dateModified":"2023-08-27T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"//localhost:1313/posts/notes/dev/%E6%8C%87%E5%8D%97%E5%9B%A2%E9%98%9Fgit%E5%8D%8F%E4%BD%9C/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"//localhost:1313/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=//localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=//localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=//localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=//localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=//localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=//localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=//localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=//localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Git正确使用姿势</h1><div class=post-description>记录使用git的常用命令，以及对git的工作模式进行简单讲解</div><div class=post-meta><span title='2023-08-27 00:00:00 +0000 UTC'>August 27, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;424 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#git%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8%e5%a7%bf%e5%8a%bf aria-label=Git正确使用姿势>Git正确使用姿势</a><ul><li><a href=#git%e5%b7%a5%e4%bd%9c%e5%8c%ba%e5%9f%9f%e5%92%8c%e6%b5%81%e7%a8%8b aria-label=Git工作区域和流程>Git工作区域和流程</a><ul><li><a href=#%e5%b7%a5%e4%bd%9c%e5%8c%ba%e5%9f%9f aria-label=工作区域>工作区域</a></li><li><a href=#%e6%96%87%e4%bb%b6%e7%8a%b6%e6%80%81 aria-label=文件状态>文件状态</a></li></ul></li><li><a href=#git%e5%b8%b8%e8%a7%81%e5%91%bd%e4%bb%a4 aria-label=Git常见命令>Git常见命令</a><ul><li><a href=#%e4%bb%93%e5%ba%93%e5%88%9d%e5%a7%8b%e5%8c%96%e5%92%8c%e5%85%8b%e9%9a%86 aria-label=仓库初始化和克隆>仓库初始化和克隆</a></li><li><a href=#%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93%e7%ae%a1%e7%90%86 aria-label=远程仓库管理>远程仓库管理</a></li><li><a href=#%e4%bb%8e%e5%b7%a5%e4%bd%9c%e5%8c%ba%e6%8f%90%e4%ba%a4%e4%bb%a3%e7%a0%81%e5%88%b0%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93 aria-label=从工作区提交代码到远程仓库>从工作区提交代码到远程仓库</a></li><li><a href=#%e4%bb%8e%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93%e4%b8%ad%e6%8b%89%e5%8f%96%e4%bb%a3%e7%a0%81 aria-label=从远程仓库中拉取代码>从远程仓库中拉取代码</a><ul><li><a href=#fetch aria-label=fetch>fetch</a></li><li><a href=#merge aria-label=merge><strong>merge</strong></a></li><li><a href=#rebase aria-label=rebase><strong>rebase</strong></a></li><li><a href=#%e4%ba%a4%e4%ba%92%e5%bc%8frebase aria-label=交互式rebase><strong>交互式rebase</strong></a></li></ul></li><li><a href=#%e5%88%86%e6%94%af%e7%ae%a1%e7%90%86 aria-label=分支管理>分支管理</a></li><li><a href=#%e6%b8%85%e7%a9%ba%e6%9a%82%e5%ad%98%e5%8c%ba aria-label=清空暂存区>清空暂存区</a></li></ul></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e5%9b%a2%e9%98%9f%e5%8d%8f%e4%bd%9c aria-label=如何进行团队协作>如何进行团队协作</a><ul><li><a href=#%e5%bb%ba%e7%ab%8b%e4%bb%93%e5%ba%93 aria-label=建立仓库>建立仓库</a></li><li><a href=#%e6%b7%bb%e5%8a%a0ssh%e7%a7%98%e9%92%a5 aria-label=添加SSH秘钥>添加SSH秘钥</a><ul><li><a href=#ssh%e7%a7%98%e9%92%a5%e7%9a%84%e7%94%9f%e6%88%90 aria-label=SSH秘钥的生成>SSH秘钥的生成</a><ul><li><a href=#%e5%9c%a8windows%e4%b8%8a aria-label=在Windows上>在Windows上</a></li><li><a href=#%e5%9c%a8ubuntu%e4%b8%8a aria-label=在Ubuntu上>在Ubuntu上</a></li></ul></li></ul></li><li><a href=#just-do-it aria-label="Just do it!">Just do it!</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=git正确使用姿势>Git正确使用姿势<a hidden class=anchor aria-hidden=true href=#git正确使用姿势>#</a></h1><h2 id=git工作区域和流程>Git工作区域和流程<a hidden class=anchor aria-hidden=true href=#git工作区域和流程>#</a></h2><h3 id=工作区域>工作区域<a hidden class=anchor aria-hidden=true href=#工作区域>#</a></h3><ul><li><p>**远程仓库：**就是我们托管在github或者其他代码托管平台上的仓库。</p></li><li><p>**本地仓库：**就是在我们本地通过<code>git init</code>命令初始化的新建的仓库。</p></li><li><p>**工作区：**就是我们写代码、编辑文件的地方。</p></li><li><p>**暂存区：**当工作区的内容写好了之后，就会通过add命令，将工作区的内容放到暂存区，等待commit命令提交到本地仓库中。</p></li></ul><h3 id=文件状态>文件状态<a hidden class=anchor aria-hidden=true href=#文件状态>#</a></h3><ul><li>**未跟踪的（untracked）：**表示在工作区新建了某个文件，还没有add。</li><li>**已修改（modofied）：**表示在工作区中修改了某个文件，还没有 add。</li><li>**已暂存（staged）：**表示把已修改的文件已add到暂存区域。</li><li>**已提交（commit）：**表示文件已经commit到本地仓库保存起来了。</li></ul><h2 id=git常见命令>Git常见命令<a hidden class=anchor aria-hidden=true href=#git常见命令>#</a></h2><h3 id=仓库初始化和克隆>仓库初始化和克隆<a hidden class=anchor aria-hidden=true href=#仓库初始化和克隆>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># git仓库初始化</span>
</span></span><span class=line><span class=cl>git init
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 从远程仓库中进行克隆代码到本地仓库</span>
</span></span><span class=line><span class=cl>git clone <span class=o>[</span>远程仓库的HTTP/SSH的URL<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看当前git仓库的状态</span>
</span></span><span class=line><span class=cl>git status
</span></span></code></pre></div><h3 id=远程仓库管理>远程仓库管理<a hidden class=anchor aria-hidden=true href=#远程仓库管理>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Git正确使用姿势 Git工作区域和流程 工作区域 远程仓库： 就是我们托管在github或者其他代码托管平台上的仓库。 本地仓库： 就是在我们本地通过git init命令初始化的新建的仓库。 工作区# git remote 是用来管理远程仓库的命令
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git remote		<span class=c1># 查看已配置的远程仓库</span>
</span></span><span class=line><span class=cl>git remote -v 	<span class=c1># 查看远程仓库的URL</span>
</span></span><span class=line><span class=cl>git remote add &lt;远程仓库名称&gt; &lt;远程仓库URL&gt;	<span class=c1># 添加一个新的远程仓库</span>
</span></span><span class=line><span class=cl><span class=c1># e.g git remote add origin &lt;远程仓库URL&gt;，一般采用origin作为远程仓库的名字</span>
</span></span><span class=line><span class=cl>git remote remove origin 			<span class=c1># 删除名为origin的远程仓库</span>
</span></span><span class=line><span class=cl>git remote rename origin newname 	<span class=c1># 将origin的名字改为newname</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 设置本地仓库的上游分支</span>
</span></span><span class=line><span class=cl>git branch --set-upstream-to<span class=o>=</span>origin/main main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 给本地仓库的分支重命名</span>
</span></span><span class=line><span class=cl><span class=c1>## 把master分支更名为main分支</span>
</span></span><span class=line><span class=cl>git branch -m master main
</span></span></code></pre></div><h3 id=从工作区提交代码到远程仓库>从工作区提交代码到远程仓库<a hidden class=anchor aria-hidden=true href=#从工作区提交代码到远程仓库>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># git add 将更改过的代码添加到暂存区</span>
</span></span><span class=line><span class=cl>git add .	<span class=c1># 将工作区中所有更改添加到暂存区</span>
</span></span><span class=line><span class=cl>git add index.html	<span class=c1># 添加更改的单个文件到暂存区</span>
</span></span><span class=line><span class=cl>git add src/		<span class=c1># 添加该目录下的更改到暂存区</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># git commit 将暂存区的代码提交到本地仓库</span>
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;提交说明&#34;</span>	<span class=c1># 最常用的提交方式，一定要写提交说明，不然版本管理会非常痛苦</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># git push 用于将本地的代码提交推送到远程仓库，将本地仓库中的提交上传到Git服务器上，使其成为远程仓库的一部分</span>
</span></span><span class=line><span class=cl>git push &lt;远程仓库名称&gt; &lt;本地分支名称&gt;:&lt;远程分支名称&gt;
</span></span><span class=line><span class=cl>git push -f origin master	<span class=c1># 强制推送到origin的master分支，远程仓库origin的master分支上的之前的代码会被覆盖！非常危险的操作！</span>
</span></span></code></pre></div><ul><li><code>&lt;远程仓库名称></code>：指定要推送到的远程仓库的名称，通常为"origin"，这是Git默认的远程仓库名称。</li><li><code>&lt;本地分支名称></code>：指定要推送的本地分支的名称，这是你当前所在的分支，例如"main"、&ldquo;master"等。</li><li><code>&lt;远程分支名称></code>：指定远程仓库中要接收提交的分支名称。</li></ul><p>默认情况下，<code>git push</code>命令会将当前分支的代码推送到与之相对应的远程分支。例如，如果你当前在"main"分支上，并且与远程仓库"origin"关联，那么<code>git push origin main</code>命令将把"main"分支的提交推送到"origin"的"main"分支；如果远程分支不存在，则<code>git push</code>会自动创建一个新的远程分支。</p><h3 id=从远程仓库中拉取代码>从远程仓库中拉取代码<a hidden class=anchor aria-hidden=true href=#从远程仓库中拉取代码>#</a></h3><h4 id=fetch>fetch<a hidden class=anchor aria-hidden=true href=#fetch>#</a></h4><p><code>git fetch</code>命令用于从远程仓库获取最新的代码提交和分支信息，但它<strong>不会将获取到的内容应用到你的工作目录或当前分支</strong>，也不会改变你本地仓库的历史记录。相当于是将远程仓库的最新信息下载到你的本地仓库，你可以通过<code>git merge</code>或<code>git rebase</code>将这些更新合并到你的当前分支。</p><p>以下是<code>git fetch</code>命令的用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git fetch &lt;远程仓库名称&gt;
</span></span></code></pre></div><p>在执行命令时，Git会连接到指定的远程仓库，并获取远程仓库中最新的分支和提交信息。它会将获取到的内容<strong>保存在本地仓库的"FETCH_HEAD"引用</strong>中。</p><hr><p>关于git merge和git rebase的区别在这里引用了另外一个博主的文章进行介绍。</p><p>文章原链接：https://blog.csdn.net/kevinxxw/article/details/123980372</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/08/upgit_20230825_1692964880.png alt=两个分支></p><h4 id=merge><strong>merge</strong><a hidden class=anchor aria-hidden=true href=#merge>#</a></h4><p>将 master 分支合并到 feature 分支最简单的办法就是用下面这些命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout feature
</span></span><span class=line><span class=cl>git merge master
</span></span></code></pre></div><p>也可以把它们压缩在一行里。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git merge master feature
</span></span></code></pre></div><p>feature 分支中新的合并提交（merge commit）将两个分支的历史连在了一起。你会得到下面这样的分支结构：</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/08/upgit_20230825_1692965624.png alt=b96eb877e38c4ab55242b7068cd8a8c6></p><h4 id=rebase><strong>rebase</strong><a hidden class=anchor aria-hidden=true href=#rebase>#</a></h4><p>作为 merge 的替代选择，你可以像下面这样将 feature 分支并入 master 分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout feature
</span></span><span class=line><span class=cl>git rebase master
</span></span></code></pre></div><p>它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p><p><strong>关于git rebase的黄金法则就是永远不要在公共分支上使用它。</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/08/upgit_20230825_1692964942.png alt=755e949c6c111fae02b4c178545e619a></p><p>rebase最大的好处是你的项目历史会非常整洁。首先，它不像 <code>git merge</code> 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 <code>git log</code>、<code>git bisect</code> 和 <code>gitk</code> 来查看项目历史。</p><p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。</p><h4 id=交互式rebase><strong>交互式rebase</strong><a hidden class=anchor aria-hidden=true href=#交互式rebase>#</a></h4><p>交互式的 rebase 允许你更改并入新分支的提交。这比自动的 rebase 更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将 feature 分支并入 master 分支之前，清理混乱的历史。</p><p>把 <code>-i</code> 传入 <code>git rebase</code> 选项来开始一个交互式的rebase过程：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout feature
</span></span><span class=line><span class=cl>git rebase -i master
</span></span></code></pre></div><p>它会打开一个文本编辑器，显示所有将被移动的提交：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>pick 33d5b7a Message <span class=k>for</span> commit <span class=c1>#1</span>
</span></span><span class=line><span class=cl>pick 9480b3d Message <span class=k>for</span> commit <span class=c1>#2</span>
</span></span><span class=line><span class=cl>pick 5c67e61 Message <span class=k>for</span> commit <span class=c1>#3</span>
</span></span></code></pre></div><p>这个列表定义了 rebase 将被执行后分支会是什么样的。更改 <code>pick</code> 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个提交修复了第一个提交中的小问题，你可以用 <code>fixup</code> 命令把它们合到一个提交中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>pick 33d5b7a Message <span class=k>for</span> commit <span class=c1>#1</span>
</span></span><span class=line><span class=cl>fixup 9480b3d Message <span class=k>for</span> commit <span class=c1>#2</span>
</span></span><span class=line><span class=cl>pick 5c67e61 Message <span class=k>for</span> commit <span class=c1>#3</span>
</span></span></code></pre></div><p>保存后关闭文件，Git 会根据你的指令来执行 rebase，项目历史看上去会是这样：</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/08/upgit_20230825_1692964942.png alt=755e949c6c111fae02b4c178545e619a></p><p>忽略不重要的提交会让你的 feature 分支的历史更清晰易读。这是 <code>git merge</code> 做不到的。</p><h3 id=分支管理>分支管理<a hidden class=anchor aria-hidden=true href=#分支管理>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># git branch 命令用于查看、创建和管理分支</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git branch 					<span class=c1># 查看本地所有分支</span>
</span></span><span class=line><span class=cl>git branch -a				<span class=c1># 查看本地和远程的分支</span>
</span></span><span class=line><span class=cl>git branch &lt;新分支名称&gt;		<span class=c1># 创建一个新分支</span>
</span></span><span class=line><span class=cl>git branch -d &lt;分支名称&gt;	<span class=c1># 删除一个分支</span>
</span></span><span class=line><span class=cl>git branch -D &lt;分支名称&gt; 	<span class=c1># 强制删除一个分支</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># git checkout 用于在Git中切换分支、查看文件的不同版本或还原文件到之前的状态</span>
</span></span><span class=line><span class=cl>关于git rebase的黄金法则就是永远不要在公共分支上使用它。
</span></span><span class=line><span class=cl>git checkout &lt;分支名称&gt;						 <span class=c1># 切换到其他分支上</span>
</span></span><span class=line><span class=cl>											 <span class=c1># 新版本git中采用git switch &lt;分支名称&gt; 切换分支</span>
</span></span><span class=line><span class=cl>git checkout &lt;commit哈希值&gt; &lt;文件名&gt;			<span class=c1># 查看文件的不同版本</span>
</span></span><span class=line><span class=cl>git checkout &lt;commit哈希值&gt; -- &lt;文件名&gt;		<span class=c1># 还原文件到之前的状态</span>
</span></span></code></pre></div><h3 id=清空暂存区>清空暂存区<a hidden class=anchor aria-hidden=true href=#清空暂存区>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git reset <span class=c1># 所有文件的变更撤销</span>
</span></span></code></pre></div><h1 id=如何进行团队协作>如何进行团队协作<a hidden class=anchor aria-hidden=true href=#如何进行团队协作>#</a></h1><h2 id=建立仓库>建立仓库<a hidden class=anchor aria-hidden=true href=#建立仓库>#</a></h2><ul><li><p>在github上建立组织和仓库，看起来也酷酷的；</p></li><li><p>在组织里面新建一个仓库。</p></li></ul><h2 id=添加ssh秘钥>添加SSH秘钥<a hidden class=anchor aria-hidden=true href=#添加ssh秘钥>#</a></h2><p>最好是使用SSH，所以在仓库里面添加上各位团队成员的SSH秘钥</p><h3 id=ssh秘钥的生成>SSH秘钥的生成<a hidden class=anchor aria-hidden=true href=#ssh秘钥的生成>#</a></h3><h4 id=在windows上>在Windows上<a hidden class=anchor aria-hidden=true href=#在windows上>#</a></h4><ol><li>打开Windows PowerShell或者Git Bash（如果你已经安装了Git）。</li><li>输入以下命令来生成SSH密钥对：</li></ol><pre tabindex=0><code>ssh-keygen -t rsa -b 4096 -C &#34;your_email@example.com&#34;
</code></pre><ul><li><code>-t rsa</code>: 指定生成RSA密钥对。</li><li><code>-b 4096</code>: 指定密钥的位数。4096位提供更高的安全性，但生成时间可能稍长。</li><li><code>-C "your_email@example.com"</code>: 用你的邮箱地址替换这部分内容，这将作为你的密钥的注释。</li></ul><ol><li>系统会提示你选择密钥保存的位置，默认会保存在<code>~/.ssh</code>目录下，你可以按照提示选择保存位置或直接回车使用默认位置。</li><li>然后系统会让你输入一个密码来保护你的私钥。这是可选的，如果你不想设置密码，可以直接回车跳过。</li></ol><h4 id=在ubuntu上>在Ubuntu上<a hidden class=anchor aria-hidden=true href=#在ubuntu上>#</a></h4><ol><li>打开终端（Terminal）。</li><li>输入以下命令来生成SSH密钥对：</li></ol><pre tabindex=0><code>ssh-keygen -t rsa -b 4096 -C &#34;your_email@example.com&#34;
</code></pre><ul><li><code>-t rsa</code>: 指定生成RSA密钥对。</li><li><code>-b 4096</code>: 指定密钥的位数。4096位提供更高的安全性，但生成时间可能稍长。</li><li><code>-C "your_email@example.com"</code>: 用你的邮箱地址替换这部分内容，这将作为你的密钥的注释。</li></ul><ol><li>系统会提示你选择密钥保存的位置，默认会保存在<code>~/.ssh</code>目录下，你可以按照提示选择保存位置或直接回车使用默认位置。</li><li>然后系统会让你输入一个密码来保护你的私钥。这是可选的，如果你不想设置密码，可以直接回车跳过。</li></ol><p>完成上述步骤后，你会在指定的位置（默认为<code>~/.ssh</code>目录）找到生成的SSH密钥对。其中，私钥文件为<code>id_rsa</code>，公钥文件为<code>id_rsa.pub</code>。将公钥文件（<code>id_rsa.pub</code>）的内容复制并粘贴到需要使用该SSH密钥的服务器或Git托管服务中，以便进行身份验证。私钥文件请妥善保管，不要分享给他人，以保障账户的安全性。</p><h2 id=just-do-it>Just do it!<a hidden class=anchor aria-hidden=true href=#just-do-it>#</a></h2><p>剩下就是团队一起约定项目开发计划是什么呀？</p><p>变量命名要遵循什么规则啊？</p><p>大家一起加油吧！</p></div><footer class=post-footer><ul class=post-tags><li><a href=//localhost:1313/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=//localhost:1313/posts/notes/ubuntu/ubuntu-tips/><span class=title>« Prev</span><br><span>Ubuntu使用记录</span>
</a><a class=next href=//localhost:1313/posts/notes/database/%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8-gorm%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/><span class=title>Next »</span><br><span>使用GORM操作数据库</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2024 <a href=//localhost:1313/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>