<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes学习和实践 | Sirius' Blog</title>
<meta name=keywords content="Kubernetes,分布式"><meta name=description content="这篇文章记录了阅读Kubernetes inAction的学习记录，以及使用k8s进行一些实战的过程"><meta name=author content="sirius1y"><link rel=canonical href=//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=//localhost:1313/images/icon.png><link rel=icon type=image/png sizes=16x16 href=//localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=//localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=//localhost:1313/apple-touch-icon.png><link rel=mask-icon href=//localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Kubernetes学习和实践"><meta property="og:description" content="这篇文章记录了阅读Kubernetes inAction的学习记录，以及使用k8s进行一些实战的过程"><meta property="og:type" content="article"><meta property="og:url" content="//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><meta property="og:image" content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-30T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kubernetes学习和实践"><meta name=twitter:description content="这篇文章记录了阅读Kubernetes inAction的学习记录，以及使用k8s进行一些实战的过程"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"//localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes学习和实践","item":"//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes学习和实践","name":"Kubernetes学习和实践","description":"这篇文章记录了阅读Kubernetes inAction的学习记录，以及使用k8s进行一些实战的过程","keywords":["Kubernetes","分布式"],"articleBody":"Service类型 在 Kubernetes 中，Service 是一种抽象的概念，用于将一组 Pod 组织在一起，并为它们提供统一的访问入口。Service 可以通过一组稳定的 IP 地址和端口号，为其他容器或外部用户提供对这些 Pod 的访问。\n为什么需要服务？ pod的存在是短暂的，当pod因为节点故障或者人为原因下线的时候，ReplicationController可以上线一个新的pod。但是新的pod和原来的pod的IP是不相同的——为了解决不断变化的pod IP地址的问题，以及在一个固定的IP和端口对外暴露多个pod。\n当一个服务被创建时，他会得到一个静态的IP，在服务的生命周期中这个IP不会发生变化。客户端应该通过这个固定IP地址连接到服务，而不是直接连接到pod。\n服务的类型 Kubernetes 中的 Service 有以下四种类型：\n1、ClusterIP 这是默认的 Service 类型，用于将 Service 暴露在集群内部。它为每个 Service 分配一个虚拟 IP 地址，可以通过该地址访问 Service 中的 Pod。ClusterIP 只能从集群内部访问，不能从集群外部访问。\n2、NodePort 这种类型的 Service 将 Service 暴露到集群外部，通过将每个节点上的端口映射到 Service 上，可以让外部用户通过任意节点的 IP 地址和映射端口访问 Service 中的 Pod。NodePort 通常用于测试和开发环境，不太适合生产环境。\n3、LoadBalancer 这种类型的 Service 可以将 Service 暴露到集群外部，并使用云提供商的负载均衡器将流量路由到 Service 中的 Pod。LoadBalancer 只能在云提供商支持的环境中使用，并且需要正确配置云提供商的负载均衡器才能正常工作。\n4、ExternalName 这种类型的 Service 可以将 Service 暴露到集群外部，但它并不会创建任何代理或负载均衡器，而只是将 Service 映射到一个 DNS 名称。这可以让您在 Kubernetes 中使用外部服务，或者在不同的命名空间中重用服务。\n这些 Service 类型之间的主要差异在于它们暴露 Service 的方式、访问方式和使用场景不同。在选择 Service 类型时，您应该考虑您的应用程序的访问需求，以及您正在使用的 Kubernetes 部署环境的限制和要求。\nReplication Controller与Deployment Replication Controller 中文翻译：复制控制器\nReplication Controller为Kubernetes的一个核心内容，应用托管到Kubernetes之后，需要保证应用能够持续的运行，Replication Controller就是这个保证的key，主要的功能如下：\n确保pod数量：它会确保Kubernetes中有指定数量的Pod在运行。如果少于指定数量的pod，Replication Controller会创建新的，反之则会删除掉多余的以保证Pod数量不变。\n确保pod健康：当pod不健康，运行出错或者无法提供服务时，Replication Controller也会杀死不健康的pod，重新创建新的。\n弹性伸缩 ：在业务高峰或者低峰期的时候，可以通过Replication Controller动态的调整pod的数量来提高资源的利用率。同时，配置相应的监控功能（Hroizontal Pod Autoscaler），会定时自动从监控平台获取Replication Controller关联pod的整体资源使用情况，做到自动伸缩。\n滚动升级：滚动升级为一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定，在初始化升级的时候就可以及时发现和解决问题，避免问题不断扩大。\nDeployment Deployment同样为Kubernetes的一个核心内容，主要职责同样是为了保证pod的数量和健康，90%的功能与Replication Controller完全一样，可以看做新一代的Replication Controller。但是，它又具备了Replication Controller之外的新特性：\nReplication Controller全部功能：Deployment继承了上面描述的Replication Controller全部功能。\n事件和状态查看：可以查看Deployment的升级详细进度和状态。\n回滚：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。\n版本记录: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。\n暂停和启动：对于每一次升级，都能够随时暂停和启动。\n多种升级方案：Recreate：删除所有已存在的pod,重新创建新的; RollingUpdate：滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。 ———————————————— 版权声明：本文为CSDN博主「小魏的博客」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/w2009211777/article/details/124014770\nLinux指令 sudo su //以root身份登录 lsof -i //打印进程和监听端口 【实践】在腾讯云轻量级服务器上搭建网站 实践内容 在腾讯云上，有首月免费的轻量级服务器可以租借。\n本次实训的内容是，租借一台服务器，部署《kubernetes in action》当中的网站例子。至少包含 deployment（部署） nodeport(服务的类型) prometheus grafna 这些功能。\n解释：\nphometheus：当前一套非常流行的开源监控和报警系统\nGrafana 是一个用于可视化大型测量数据的开源系统，它的功能非常强大，界面也非常漂亮，\nPrometheus + Grafana 虽然 Prometheus 提供的 Web UI 也可以很好的查看不同指标的视图，但是这个功能非常简单，只适合用来调试。要实现一个强大的监控系统，还需要一个能定制展示不同指标的面板，能支持不同类型的展现方式（曲线图、饼状图、热点图、TopN 等），这就是仪表盘（Dashboard）功能。\n因此 Prometheus 开发了一套仪表盘系统 PromDash，不过很快这套系统就被废弃了，官方开始推荐使用 Grafana 来对 Prometheus 的指标数据进行可视化，这不仅是因为 Grafana 的功能非常强大，而且它和 Prometheus 可以完美的无缝融合。 ———————————————— 版权声明：本文为CSDN博主「40岁资深老架构师尼恩」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/crazymakercircle/article/details/127206293\n实践步骤 要完成这个任务，您需要执行以下步骤：\n购买一台虚拟服务器，可以使用云计算服务商如阿里云、腾讯云、AWS等提供的虚拟机实例，也可以使用自己的物理服务器。 在服务器上安装 Kubernetes，您可以选择手动安装或使用 Kubernetes 安装程序（如 kubeadm）进行安装。安装过程可以参考《Kubernetes in Action》书籍中的相关章节。 部署网站示例，可以使用书中提供的示例或者使用自己编写的应用程序，将其打包成 Docker 镜像并上传至 Docker 镜像仓库。 使用 Kubernetes 的 Deployment 功能创建应用程序的部署，确保应用程序能够正常运行。 通过 Kubernetes 的 NodePort 功能暴露应用程序的服务，以便能够从外部访问应用程序。 安装 Prometheus 和 Grafana，用于监控应用程序的性能和运行状况。 将应用程序和监控系统的指标数据通过 Kubernetes 的 Service 功能进行关联，以便监控系统能够收集和分析应用程序的指标数据。 在 Grafana 中创建仪表盘，用于显示应用程序的监控数据。 完成以上步骤后，您就可以在服务器上部署《Kubernetes in Action》书籍中的网站示例，并使用 Prometheus 和 Grafana 监控应用程序的性能和运行状况。\n实践提示 在腾讯云上安装K8S 在腾讯云上安装 Kubernetes，可以按照以下步骤进行：\n登录腾讯云控制台，选择容器服务（TKE）。 创建 Kubernetes 集群：在容器服务（TKE）控制台上，选择创建集群，按照页面提示填写集群名称、节点数量、实例规格等信息，选择集群网络和安全组等配置。 安装和配置 kubectl：在 Kubernetes 集群创建完成后，进入集群管理页面，下载并安装 kubectl 工具，配置集群连接信息。 部署 Kubernetes 组件：在集群管理页面上，选择组件管理，按照页面提示部署 Kubernetes 组件，如 kube-apiserver、kube-controller-manager、kube-scheduler、etcd 等。 部署网络插件：在集群管理页面上，选择网络插件，选择并部署一个合适的网络插件，如 Flannel、Calico、Weave Net 等。 部署存储插件：如果需要在 Kubernetes 集群中使用持久化存储，可以选择并部署一个存储插件，如 Ceph、GlusterFS 等。 部署应用程序：使用 kubectl 工具，在 Kubernetes 集群上部署和管理自己的应用程序，如创建 Pod、Deployment、Service 等 Kubernetes 对象。 总之，在腾讯云上安装 Kubernetes，需要根据具体的需求，选择不同的配置和插件，按照腾讯云容器服务（TKE）提供的文档和指南进行操作，最终构建出一个稳定、可靠的 Kubernetes 集群。\n搭建一个网页并制作成Docker镜像 选择一个网页框架：您可以选择一个合适的网页框架，比如 Flask、Django、Vue.js、React 等。这些框架都有各自的优缺点和使用场景，您可以根据自己的需要进行选择。 编写网页代码：根据您选择的框架，编写网页代码，实现您想要的功能。您可以在本地开发环境中进行调试和测试，确保代码能够正常运行。 配置 Dockerfile：在您的代码目录下创建一个名为 Dockerfile 的文件，该文件包含构建 Docker 镜像的指令。您需要根据您的应用程序和所选框架进行相应的配置，包括设置基础镜像、安装所需的依赖项、将代码复制到容器中等。 构建 Docker 镜像：使用 Docker 命令构建 Docker 镜像，将您的网页代码打包成 Docker 镜像。例如，使用以下命令构建一个名为 my-web 的 Docker 镜像： docker build -t my-web . 测试 Docker 镜像：使用 Docker 命令运行您的 Docker 镜像，测试您的网页能否正常工作。例如，使用以下命令启动一个名为 my-web 的 Docker 容器： docker run -p 8080:80 my-web ​\t其中，-p 8080:80 表示将容器内部的 80 端口映射到主机的 8080 端口。\n上传 Docker 镜像：将您的 Docker 镜像上传到 Docker Hub 或其他 Docker 镜像仓库中，以便其他人可以访问和使用您的镜像。 以上是一个简单的搭建网页并制作 Docker 镜像的步骤。具体的步骤可能会因为您选择的框架和工具而略有不同，您需要根据实际情况进行调整和优化。\n实践报告 1.实践步骤 1.1 完成网页代码的编写 网页文件 版本v1 index.html：\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e随机生成字符串\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e随机生成字符串\u003c/h1\u003e \u003cp id=\"result\"\u003e\u003c/p\u003e \u003cbutton onclick=\"generate()\"\u003e生成\u003c/button\u003e \u003cscript\u003e function generate() { // 定义生成字符串的所有字符 var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; // 定义生成字符串的长度 var length = 10; var result = \"\"; // 循环生成字符串 for (var i = 0; i \u003c length; i++) { result += chars.charAt(Math.floor(Math.random() * chars.length)); } // 将生成的字符串显示在页面上 document.getElementById(\"result\").innerHTML = result; } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 网页文件 版本v2 index-with-error.html:\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e访问出错\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style=\"text-align: center;\"\u003eError!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 网页版本v1是正常的网页，而版本v2用来模拟版本更新中出现错误的版本，利用deployment进行历史版本的回滚。\n1.2 完成镜像的打包 分别编写两个网站的Dockerfile，将他们打包成不同的镜像。\n版本v1Dockerfile：\n# 指定基础镜像 FROM nginx # 将工作目录切换到 /usr/share/nginx/html WORKDIR /usr/share/nginx/html # 将当前目录下的 index.html 和 main.js 文件复制到镜像中的 /usr/share/nginx/html 目录下 COPY index.html . # 暴露容器的 80 端口 EXPOSE 80 # 运行 nginx 服务器 CMD [\"nginx\", \"-g\", \"daemon off;\"] 版本v2 Dockerfile：\n# 指定基础镜像 FROM nginx # 将工作目录切换到 /usr/share/nginx/html WORKDIR /usr/share/nginx/html # 将当前目录下的 index.html 和 main.js 文件复制到镜像中的 /usr/share/nginx/html 目录下 COPY index-with-error.html . # 暴露容器的 80 端口 EXPOSE 80 # 运行 nginx 服务器 CMD [\"nginx\", \"-g\", \"daemon off;\"] 在启动docker桌面版之后在终端中执行命令：\ndocker build -t frontend:v1 . docker build -t frontend:v2 . 1.3 完成上传至腾讯云镜像仓库 完成登陆指令：\ndocker login ccr.ccs.tencentyun.com --username=100029754889 完成镜像的更名和推送到腾讯云上的镜像仓库：\ndocker tag 500112082598e896cd70b459fccf2e3c5f39874bf854589626eec751a3933a5b ccr.ccs.tencentyun.com/siriusspace/sirius:v2 docker push ccr.ccs.tencentyun.com/siriusspace/sirius:v2 docker tag f79982b77bfbe0f92a7de6a2fabdc21e818de3370aed1c38a6ab3c73d1dd0b32 ccr.ccs.tencentyun.com/siriusspace/sirius:v3 docker push ccr.ccs.tencentyun.com/siriusspace/sirius:v3 1.4 在腾讯云上面申请一个轻量级应用服务器 在腾讯云上申请一个基于容器镜像的Ubuntu20.04-Docker20系统，用于此次计算思维实训的工作环境。\n1.5 服务器环境配置 在腾讯云的OracTerm上登陆，把当前用户设置成超级管理员，并且在上面安装必要的环境，如kubernetes，docker；\n也可以使用SSH工具进行远程登陆进行操作，在首次使用SSH远程登陆，需要重置密码；并且当服务器重装系统之后，需要将本地的known_hosts中的文件注释掉，再重新进行登录。\n1.5.1 安装docker的步骤： 更新 apt 包索引：\nsudo apt-get update 安装依赖包，用于让 apt 能够通过 HTTPS 使用 Docker 仓库：\nsudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release 添加 Docker 的 GPG 密钥：\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 添加 Docker APT 仓库：\necho \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 更新 apt 包索引：\nsudo apt-get update 安装 Docker：\nsudo apt-get install docker-ce docker-ce-cli containerd.io 验证 Docker 是否安装成功 sudo docker version 1.5.2 安装kubernetes的步骤： 1.安装Kubernetes的工具包：kubeadm、kubelet和kubectl //阿里云镜像仓库 sudo apt-get update \u0026\u0026 sudo apt-get install -y apt-transport-https curl curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - cat \u003c","wordCount":"1193","inLanguage":"en","image":"//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-10-30T00:00:00Z","dateModified":"2022-10-30T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"//localhost:1313/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=//localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=//localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=//localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=//localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=//localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=//localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=//localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=//localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kubernetes学习和实践</h1><div class=post-description>这篇文章记录了阅读Kubernetes inAction的学习记录，以及使用k8s进行一些实战的过程</div><div class=post-meta><span title='2022-10-30 00:00:00 +0000 UTC'>October 30, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1193 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#service%e7%b1%bb%e5%9e%8b aria-label=Service类型>Service类型</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%9c%8d%e5%8a%a1 aria-label=为什么需要服务？>为什么需要服务？</a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=服务的类型>服务的类型</a><ul><li><a href=#1clusterip aria-label=1、ClusterIP><strong>1、ClusterIP</strong></a></li><li><a href=#2nodeport aria-label=2、NodePort><strong>2、NodePort</strong></a></li><li><a href=#3loadbalancer aria-label=3、LoadBalancer><strong>3、LoadBalancer</strong></a></li><li><a href=#4externalname aria-label=4、ExternalName><strong>4、ExternalName</strong></a></li></ul></li></ul></li><li><a href=#replication-controller%e4%b8%8edeployment aria-label="Replication Controller与Deployment">Replication Controller与Deployment</a><ul><li><a href=#replication-controller aria-label="Replication Controller">Replication Controller</a></li><li><a href=#deployment aria-label=Deployment>Deployment</a></li></ul></li><li><a href=#linux%e6%8c%87%e4%bb%a4 aria-label=Linux指令>Linux指令</a></li><li><a href=#%e5%ae%9e%e8%b7%b5%e5%9c%a8%e8%85%be%e8%ae%af%e4%ba%91%e8%bd%bb%e9%87%8f%e7%ba%a7%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%8a%e6%90%ad%e5%bb%ba%e7%bd%91%e7%ab%99 aria-label=【实践】在腾讯云轻量级服务器上搭建网站>【实践】在腾讯云轻量级服务器上搭建网站</a><ul><li><a href=#%e5%ae%9e%e8%b7%b5%e5%86%85%e5%ae%b9 aria-label=实践内容>实践内容</a><ul><li><a href=#prometheus--grafana aria-label="Prometheus + Grafana">Prometheus + Grafana</a></li></ul></li><li><a href=#%e5%ae%9e%e8%b7%b5%e6%ad%a5%e9%aa%a4 aria-label=实践步骤>实践步骤</a></li><li><a href=#%e5%ae%9e%e8%b7%b5%e6%8f%90%e7%a4%ba aria-label=实践提示>实践提示</a><ul><ul><li><a href=#%e5%9c%a8%e8%85%be%e8%ae%af%e4%ba%91%e4%b8%8a%e5%ae%89%e8%a3%85k8s aria-label=在腾讯云上安装K8S>在腾讯云上安装K8S</a></li><li><a href=#%e6%90%ad%e5%bb%ba%e4%b8%80%e4%b8%aa%e7%bd%91%e9%a1%b5%e5%b9%b6%e5%88%b6%e4%bd%9c%e6%88%90docker%e9%95%9c%e5%83%8f aria-label=搭建一个网页并制作成Docker镜像>搭建一个网页并制作成Docker镜像</a></li></ul></ul></li><li><a href=#%e5%ae%9e%e8%b7%b5%e6%8a%a5%e5%91%8a aria-label=实践报告>实践报告</a><ul><li><a href=#1%e5%ae%9e%e8%b7%b5%e6%ad%a5%e9%aa%a4 aria-label=1.实践步骤>1.实践步骤</a><ul><li><a href=#11-%e5%ae%8c%e6%88%90%e7%bd%91%e9%a1%b5%e4%bb%a3%e7%a0%81%e7%9a%84%e7%bc%96%e5%86%99 aria-label="1.1 完成网页代码的编写">1.1 完成网页代码的编写</a></li><li><a href=#12-%e5%ae%8c%e6%88%90%e9%95%9c%e5%83%8f%e7%9a%84%e6%89%93%e5%8c%85 aria-label="1.2 完成镜像的打包">1.2 完成镜像的打包</a></li><li><a href=#13-%e5%ae%8c%e6%88%90%e4%b8%8a%e4%bc%a0%e8%87%b3%e8%85%be%e8%ae%af%e4%ba%91%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93 aria-label="1.3 完成上传至腾讯云镜像仓库">1.3 完成上传至腾讯云镜像仓库</a></li><li><a href=#14-%e5%9c%a8%e8%85%be%e8%ae%af%e4%ba%91%e4%b8%8a%e9%9d%a2%e7%94%b3%e8%af%b7%e4%b8%80%e4%b8%aa%e8%bd%bb%e9%87%8f%e7%ba%a7%e5%ba%94%e7%94%a8%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="1.4 在腾讯云上面申请一个轻量级应用服务器">1.4 在腾讯云上面申请一个轻量级应用服务器</a></li><li><a href=#15-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae aria-label="1.5 服务器环境配置">1.5 服务器环境配置</a><ul><li><a href=#151-%e5%ae%89%e8%a3%85docker%e7%9a%84%e6%ad%a5%e9%aa%a4 aria-label="1.5.1 安装docker的步骤：">1.5.1 安装docker的步骤：</a><ul><li><a href=#%e9%aa%8c%e8%af%81-docker-%e6%98%af%e5%90%a6%e5%ae%89%e8%a3%85%e6%88%90%e5%8a%9f aria-label="验证 Docker 是否安装成功">验证 Docker 是否安装成功</a></li></ul></li><li><a href=#152-%e5%ae%89%e8%a3%85kubernetes%e7%9a%84%e6%ad%a5%e9%aa%a4 aria-label="1.5.2 安装kubernetes的步骤：">1.5.2 安装kubernetes的步骤：</a><ul><li><a href=#1%e5%ae%89%e8%a3%85kubernetes%e7%9a%84%e5%b7%a5%e5%85%b7%e5%8c%85kubeadmkubelet%e5%92%8ckubectl aria-label=1.安装Kubernetes的工具包：kubeadm、kubelet和kubectl>1.安装Kubernetes的工具包：kubeadm、kubelet和kubectl</a></li><li><a href=#2%e5%88%9d%e5%a7%8b%e5%8c%96kubernetes%e9%9b%86%e7%be%a4 aria-label=2.初始化Kubernetes集群>2.初始化Kubernetes集群</a></li><li><a href=#3%e5%ae%89%e8%a3%85%e7%bd%91%e7%bb%9c%e6%8f%92%e4%bb%b6 aria-label=3.安装网络插件>3.安装网络插件</a></li><li><a href=#4%e5%b0%86%e5%85%b6%e4%bb%96%e8%8a%82%e7%82%b9%e5%8a%a0%e5%85%a5%e9%9b%86%e7%be%a4 aria-label=4.将其他节点加入集群>4.将其他节点加入集群</a></li><li><a href=#5%e9%aa%8c%e8%af%81%e9%9b%86%e7%be%a4 aria-label=5.验证集群>5.验证集群</a></li></ul></li></ul></li><li><a href=#16-%e7%bc%96%e5%86%99%e9%83%a8%e7%bd%b2%e6%96%87%e4%bb%b6 aria-label="1.6 编写部署文件">1.6 编写部署文件</a><ul><li><a href=#161-%e7%bc%96%e5%86%99deploymentyaml%e6%96%87%e4%bb%b6 aria-label="1.6.1 编写deployment.yaml文件">1.6.1 编写deployment.yaml文件</a></li><li><a href=#162-%e9%80%9a%e8%bf%87nodeport%e6%9a%b4%e9%9c%b2%e6%9c%8d%e5%8a%a1 aria-label="1.6.2 通过NodePort暴露服务">1.6.2 通过NodePort暴露服务</a></li></ul></li><li><a href=#17-%e9%85%8d%e7%bd%ae-prometheus-%e5%92%8c-grafna-%e7%9b%b8%e5%85%b3%e5%8a%9f%e8%83%bd aria-label="1.7 配置 prometheus 和 grafna 相关功能">1.7 配置 prometheus 和 grafna 相关功能</a><ul><li><a href=#171-%e5%ae%89%e8%a3%85helm aria-label="1.7.1 安装Helm">1.7.1 安装Helm</a></li><li><a href=#172-%e5%ae%89%e8%a3%85-prometheus aria-label="1.7.2 安装 Prometheus">1.7.2 安装 Prometheus</a></li><li><a href=#173-%e5%ae%89%e8%a3%85-grafana aria-label="1.7.3 安装 Grafana">1.7.3 安装 Grafana</a></li><li><a href=#174-%e9%85%8d%e7%bd%ae-grafana aria-label="1.7.4 配置 Grafana">1.7.4 配置 Grafana</a></li></ul></li></ul></li><li><a href=#2%e5%ae%9e%e8%b7%b5%e4%b8%ad%e9%81%87%e5%88%b0%e7%9a%84%e5%9b%b0%e9%9a%be aria-label=2.实践中遇到的困难>2.实践中遇到的困难</a><ul><li><a href=#21-%e5%88%a9%e7%94%a8dockerfile%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8f%e5%87%ba%e7%8e%b0%e9%94%99%e8%af%af aria-label="2.1 利用Dockerfile构建镜像出现错误">2.1 利用Dockerfile构建镜像出现错误</a></li><li><a href=#22-%e9%95%9c%e5%83%8f%e6%8b%89%e5%8f%96%e8%af%b7%e6%b1%82%e8%b6%85%e6%97%b6 aria-label="2.2 镜像拉取请求超时">2.2 镜像拉取请求超时</a></li><li><a href=#23-%e5%9c%a8ubuntu%e5%92%8ccentos%e4%b8%8a%e7%9a%84%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4%e4%b8%8d%e5%90%8c aria-label="2.3 在Ubuntu和CentOS上的操作命令不同">2.3 在Ubuntu和CentOS上的操作命令不同</a></li><li><a href=#24-kubectl%e7%9a%84%e5%ae%89%e8%a3%85%e9%85%8d%e7%bd%ae aria-label="2.4 kubectl的安装配置">2.4 kubectl的安装配置</a></li><li><a href=#25-%e4%bd%bf%e7%94%a8ssh%e8%bf%9c%e7%a8%8b%e7%99%bb%e9%99%86%e9%94%99%e8%af%af aria-label="2.5 使用SSH远程登陆错误">2.5 使用SSH远程登陆错误</a></li></ul></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=service类型>Service类型<a hidden class=anchor aria-hidden=true href=#service类型>#</a></h1><p>在 Kubernetes 中，Service 是一种抽象的概念，用于将一组 Pod 组织在一起，并为它们提供统一的访问入口。Service 可以通过一组稳定的 IP 地址和端口号，为其他容器或外部用户提供对这些 Pod 的访问。</p><h2 id=为什么需要服务>为什么需要服务？<a hidden class=anchor aria-hidden=true href=#为什么需要服务>#</a></h2><p>pod的存在是短暂的，当pod因为节点故障或者人为原因下线的时候，ReplicationController可以上线一个新的pod。但是新的pod和原来的pod的IP是不相同的——为了解决不断变化的pod IP地址的问题，以及在一个固定的IP和端口对外暴露多个pod。</p><p>当一个服务被创建时，他会得到一个静态的IP，在服务的生命周期中这个IP不会发生变化。客户端应该通过这个固定IP地址连接到服务，而不是直接连接到pod。</p><h2 id=服务的类型>服务的类型<a hidden class=anchor aria-hidden=true href=#服务的类型>#</a></h2><p>Kubernetes 中的 Service 有以下四种类型：</p><h3 id=1clusterip><strong>1、ClusterIP</strong><a hidden class=anchor aria-hidden=true href=#1clusterip>#</a></h3><p>这是默认的 Service 类型，用于将 Service <strong>暴露在集群内部</strong>。它为每个 Service 分配一个虚拟 IP 地址，可以通过该地址访问 Service 中的 Pod。ClusterIP 只能从集群内部访问，不能从集群外部访问。</p><h3 id=2nodeport><strong>2、NodePort</strong><a hidden class=anchor aria-hidden=true href=#2nodeport>#</a></h3><p>这种类型的 Service 将 Service <strong>暴露到集群外部</strong>，通过将每个节点上的端口映射到 Service 上，可以让外部用户通过任意节点的 IP 地址和映射端口访问 Service 中的 Pod。<strong>NodePort 通常用于测试和开发环境</strong>，不太适合生产环境。</p><h3 id=3loadbalancer><strong>3、LoadBalancer</strong><a hidden class=anchor aria-hidden=true href=#3loadbalancer>#</a></h3><p>这种类型的 Service 可以将 Service <strong>暴露到集群外部</strong>，并使用云提供商的负载均衡器将流量路由到 Service 中的 Pod。LoadBalancer <strong>只能在云提供商支持的环境中使用</strong>，并且需要正确配置云提供商的负载均衡器才能正常工作。</p><h3 id=4externalname><strong>4、ExternalName</strong><a hidden class=anchor aria-hidden=true href=#4externalname>#</a></h3><p>这种类型的 Service 可以将 Service <strong>暴露到集群外部</strong>，但它并不会创建任何代理或负载均衡器，而只是将 Service 映射到一个 DNS 名称。这可以让您在 Kubernetes 中使用外部服务，或者在不同的命名空间中重用服务。</p><p>这些 Service 类型之间的主要差异在于它们暴露 Service 的方式、访问方式和使用场景不同。在选择 Service 类型时，您应该考虑您的应用程序的访问需求，以及您正在使用的 Kubernetes 部署环境的限制和要求。</p><h1 id=replication-controller与deployment>Replication Controller与Deployment<a hidden class=anchor aria-hidden=true href=#replication-controller与deployment>#</a></h1><h2 id=replication-controller>Replication Controller<a hidden class=anchor aria-hidden=true href=#replication-controller>#</a></h2><p>中文翻译：复制控制器</p><p>Replication Controller为Kubernetes的一个核心内容，应用托管到Kubernetes之后，需要保证应用能够持续的运行，Replication Controller就是这个保证的key，<strong>主要的功能</strong>如下：</p><p><strong>确保pod数量</strong>：它会确保Kubernetes中有指定数量的Pod在运行。如果少于指定数量的pod，Replication Controller会创建新的，反之则会删除掉多余的以保证Pod数量不变。</p><p><strong>确保pod健康</strong>：当pod不健康，运行出错或者无法提供服务时，Replication Controller也会杀死不健康的pod，重新创建新的。</p><p><strong>弹性伸缩</strong> ：在业务高峰或者低峰期的时候，可以通过Replication Controller动态的调整pod的数量来提高资源的利用率。同时，配置相应的监控功能（Hroizontal Pod Autoscaler），会定时自动从监控平台获取Replication Controller关联pod的整体资源使用情况，做到自动伸缩。</p><p><strong>滚动升级</strong>：滚动升级为一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定，在初始化升级的时候就可以及时发现和解决问题，避免问题不断扩大。</p><h2 id=deployment>Deployment<a hidden class=anchor aria-hidden=true href=#deployment>#</a></h2><p>Deployment同样为Kubernetes的一个核心内容，主要职责同样是为了保证pod的数量和健康，90%的功能与Replication Controller完全一样，可以看做新一代的Replication Controller。但是，它又具备了Replication Controller之外的新特性：</p><p>Replication Controller全部功能：Deployment继承了上面描述的Replication Controller全部功能。</p><p><strong>事件和状态查看</strong>：可以查看Deployment的升级详细进度和状态。</p><p><strong>回滚</strong>：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。</p><p><strong>版本记录</strong>: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。</p><p><strong>暂停和启动</strong>：对于每一次升级，都能够随时暂停和启动。</p><p><strong>多种升级方案</strong>：Recreate：删除所有已存在的pod,重新创建新的; RollingUpdate：滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。
————————————————
版权声明：本文为CSDN博主「小魏的博客」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/w2009211777/article/details/124014770</p><h1 id=linux指令>Linux指令<a hidden class=anchor aria-hidden=true href=#linux指令>#</a></h1><pre tabindex=0><code>sudo su  //以root身份登录
lsof -i  //打印进程和监听端口
</code></pre><h1 id=实践在腾讯云轻量级服务器上搭建网站>【实践】在腾讯云轻量级服务器上搭建网站<a hidden class=anchor aria-hidden=true href=#实践在腾讯云轻量级服务器上搭建网站>#</a></h1><h2 id=实践内容>实践内容<a hidden class=anchor aria-hidden=true href=#实践内容>#</a></h2><p><strong>在腾讯云上，有首月免费的轻量级服务器可以租借。</strong></p><p><strong>本次实训的内容是，租借一台服务器，部署《kubernetes in action》当中的网站例子。至少包含 deployment（部署） nodeport(服务的类型) prometheus grafna 这些功能。</strong></p><p>解释：</p><p>phometheus：当前一套非常流行的开源监控和报警系统</p><p><a href=https://grafana.com/>Grafana</a> 是一个用于可视化大型测量数据的开源系统，它的功能非常强大，界面也非常漂亮，</p><h3 id=prometheus--grafana>Prometheus + Grafana<a hidden class=anchor aria-hidden=true href=#prometheus--grafana>#</a></h3><p>虽然 Prometheus 提供的 Web UI 也可以很好的查看不同指标的视图，但是这个功能非常简单，只适合用来调试。要实现一个强大的监控系统，还需要一个能定制展示不同指标的面板，能支持不同类型的展现方式（曲线图、饼状图、热点图、TopN 等），这就是仪表盘（Dashboard）功能。</p><p>因此 Prometheus 开发了一套仪表盘系统 PromDash，不过很快这套系统就被废弃了，官方开始推荐使用 Grafana 来对 Prometheus 的指标数据进行可视化，这不仅是因为 Grafana 的功能非常强大，而且它和 Prometheus 可以完美的无缝融合。
————————————————
版权声明：本文为CSDN博主「40岁资深老架构师尼恩」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/crazymakercircle/article/details/127206293</p><h2 id=实践步骤>实践步骤<a hidden class=anchor aria-hidden=true href=#实践步骤>#</a></h2><p>要完成这个任务，您需要执行以下步骤：</p><ol><li>购买一台虚拟服务器，可以使用云计算服务商如阿里云、腾讯云、AWS等提供的虚拟机实例，也可以使用自己的物理服务器。</li><li><strong>在服务器上安装 Kubernetes</strong>，您可以选择手动安装或使用 Kubernetes 安装程序（如 kubeadm）进行安装。安装过程可以参考《Kubernetes in Action》书籍中的相关章节。</li><li><strong>部署网站示例</strong>，可以使用书中提供的示例或者使用自己编写的应用程序，将其<strong>打包成 Docker 镜像并上传至 Docker 镜像仓库</strong>。</li><li>使用 Kubernetes 的 <strong>Deployment</strong> 功能创建应用程序的部署，确保应用程序能够正常运行。</li><li>通过 Kubernetes 的 <strong>NodePort</strong> 功能暴露应用程序的服务，以便能够从外部访问应用程序。</li><li>安装 <strong>Prometheus 和 Grafana</strong>，用于监控应用程序的性能和运行状况。</li><li>将<strong>应用程序和监控系统的指标数据通过 Kubernetes 的 Service 功能进行关联</strong>，以便监控系统能够收集和分析应用程序的指标数据。</li><li><strong>在 Grafana 中创建仪表盘</strong>，用于显示应用程序的监控数据。</li></ol><p>完成以上步骤后，您就可以在服务器上部署《Kubernetes in Action》书籍中的网站示例，并使用 Prometheus 和 Grafana 监控应用程序的性能和运行状况。</p><h2 id=实践提示>实践提示<a hidden class=anchor aria-hidden=true href=#实践提示>#</a></h2><h4 id=在腾讯云上安装k8s>在腾讯云上安装K8S<a hidden class=anchor aria-hidden=true href=#在腾讯云上安装k8s>#</a></h4><p>在腾讯云上安装 Kubernetes，可以按照以下步骤进行：</p><ol><li>登录腾讯云控制台，选择容器服务（TKE）。</li><li>创建 Kubernetes 集群：在容器服务（TKE）控制台上，选择创建集群，按照页面提示填写集群名称、节点数量、实例规格等信息，选择集群网络和安全组等配置。</li><li>安装和配置 kubectl：在 Kubernetes 集群创建完成后，进入集群管理页面，下载并安装 kubectl 工具，配置集群连接信息。</li><li>部署 Kubernetes 组件：在集群管理页面上，选择组件管理，按照页面提示部署 Kubernetes 组件，如 kube-apiserver、kube-controller-manager、kube-scheduler、etcd 等。</li><li>部署网络插件：在集群管理页面上，选择网络插件，选择并部署一个合适的网络插件，如 Flannel、Calico、Weave Net 等。</li><li>部署存储插件：如果需要在 Kubernetes 集群中使用持久化存储，可以选择并部署一个存储插件，如 Ceph、GlusterFS 等。</li><li>部署应用程序：使用 kubectl 工具，在 Kubernetes 集群上部署和管理自己的应用程序，如创建 Pod、Deployment、Service 等 Kubernetes 对象。</li></ol><p>总之，在腾讯云上安装 Kubernetes，需要根据具体的需求，选择不同的配置和插件，按照腾讯云容器服务（TKE）提供的文档和指南进行操作，最终构建出一个稳定、可靠的 Kubernetes 集群。</p><h4 id=搭建一个网页并制作成docker镜像>搭建一个网页并制作成Docker镜像<a hidden class=anchor aria-hidden=true href=#搭建一个网页并制作成docker镜像>#</a></h4><ol><li>选择一个网页框架：您可以选择一个合适的网页框架，比如 Flask、Django、Vue.js、React 等。这些框架都有各自的优缺点和使用场景，您可以根据自己的需要进行选择。</li><li>编写网页代码：根据您选择的框架，编写网页代码，实现您想要的功能。您可以在本地开发环境中进行调试和测试，确保代码能够正常运行。</li><li>配置 Dockerfile：在您的代码目录下创建一个名为 Dockerfile 的文件，该文件包含构建 Docker 镜像的指令。您需要根据您的应用程序和所选框架进行相应的配置，包括设置基础镜像、安装所需的依赖项、将代码复制到容器中等。</li><li>构建 Docker 镜像：使用 Docker 命令构建 Docker 镜像，将您的网页代码打包成 Docker 镜像。例如，使用以下命令构建一个名为 my-web 的 Docker 镜像：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl>docker build -t my-web .<span class=err>
</span></span></span></code></pre></div><ol start=5><li>测试 Docker 镜像：使用 Docker 命令运行您的 Docker 镜像，测试您的网页能否正常工作。例如，使用以下命令启动一个名为 my-web 的 Docker 容器：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-docker data-lang=docker><span class=line><span class=cl>docker run -p 8080:80 my-web<span class=err>
</span></span></span></code></pre></div><p>​ 其中，-p 8080:80 表示将容器内部的 80 端口映射到主机的 8080 端口。</p><ol start=6><li>上传 Docker 镜像：将您的 Docker 镜像上传到 Docker Hub 或其他 Docker 镜像仓库中，以便其他人可以访问和使用您的镜像。</li></ol><p>以上是一个简单的搭建网页并制作 Docker 镜像的步骤。具体的步骤可能会因为您选择的框架和工具而略有不同，您需要根据实际情况进行调整和优化。</p><h2 id=实践报告>实践报告<a hidden class=anchor aria-hidden=true href=#实践报告>#</a></h2><h3 id=1实践步骤>1.实践步骤<a hidden class=anchor aria-hidden=true href=#1实践步骤>#</a></h3><h4 id=11-完成网页代码的编写>1.1 完成网页代码的编写<a hidden class=anchor aria-hidden=true href=#11-完成网页代码的编写>#</a></h4><p>网页文件 版本v1 index.html：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-HTML data-lang=HTML><span class=line><span class=cl><span class=cp>&lt;!DOCTYPE html&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=p>&lt;</span><span class=nt>meta</span> <span class=na>charset</span><span class=o>=</span><span class=s>&#34;UTF-8&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>随机生成字符串<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>随机生成字符串<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=p>&lt;</span><span class=nt>p</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;result&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=p>&lt;</span><span class=nt>button</span> <span class=na>onclick</span><span class=o>=</span><span class=s>&#34;generate()&#34;</span><span class=p>&gt;</span>生成<span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=p>&lt;</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>		<span class=kd>function</span> <span class=nx>generate</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 定义生成字符串的所有字符
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=kd>var</span> <span class=nx>chars</span> <span class=o>=</span> <span class=s2>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 定义生成字符串的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=kd>var</span> <span class=nx>length</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=kd>var</span> <span class=nx>result</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 循环生成字符串
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>result</span> <span class=o>+=</span> <span class=nx>chars</span><span class=p>.</span><span class=nx>charAt</span><span class=p>(</span><span class=nb>Math</span><span class=p>.</span><span class=nx>floor</span><span class=p>(</span><span class=nb>Math</span><span class=p>.</span><span class=nx>random</span><span class=p>()</span> <span class=o>*</span> <span class=nx>chars</span><span class=p>.</span><span class=nx>length</span><span class=p>));</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 将生成的字符串显示在页面上
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;result&#34;</span><span class=p>).</span><span class=nx>innerHTML</span> <span class=o>=</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>网页文件 版本v2 index-with-error.html:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=cp>&lt;!DOCTYPE html&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span> <span class=na>lang</span><span class=o>=</span><span class=s>&#34;en&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>charset</span><span class=o>=</span><span class=s>&#34;UTF-8&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>http-equiv</span><span class=o>=</span><span class=s>&#34;X-UA-Compatible&#34;</span> <span class=na>content</span><span class=o>=</span><span class=s>&#34;IE=edge&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>name</span><span class=o>=</span><span class=s>&#34;viewport&#34;</span> <span class=na>content</span><span class=o>=</span><span class=s>&#34;width=device-width, initial-scale=1.0&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>访问出错<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>h1</span> <span class=na>style</span><span class=o>=</span><span class=s>&#34;text-align: center;&#34;</span><span class=p>&gt;</span>Error!<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>网页版本v1是正常的网页，而版本v2用来模拟版本更新中出现错误的版本，利用deployment进行历史版本的回滚。</p><h4 id=12-完成镜像的打包>1.2 完成镜像的打包<a hidden class=anchor aria-hidden=true href=#12-完成镜像的打包>#</a></h4><p>分别编写两个网站的Dockerfile，将他们打包成不同的镜像。</p><p>版本v1Dockerfile：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># 指定基础镜像</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> nginx</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 将工作目录切换到 /usr/share/nginx/html</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /usr/share/nginx/html</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 将当前目录下的 index.html 和 main.js 文件复制到镜像中的 /usr/share/nginx/html 目录下</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> index.html .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 暴露容器的 80 端口</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 80</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 运行 nginx 服务器</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;nginx&#34;</span><span class=p>,</span> <span class=s2>&#34;-g&#34;</span><span class=p>,</span> <span class=s2>&#34;daemon off;&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>版本v2 Dockerfile：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># 指定基础镜像</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> nginx</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 将工作目录切换到 /usr/share/nginx/html</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /usr/share/nginx/html</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 将当前目录下的 index.html 和 main.js 文件复制到镜像中的 /usr/share/nginx/html 目录下</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> index-with-error.html .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 暴露容器的 80 端口</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 80</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 运行 nginx 服务器</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;nginx&#34;</span><span class=p>,</span> <span class=s2>&#34;-g&#34;</span><span class=p>,</span> <span class=s2>&#34;daemon off;&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>在启动docker桌面版之后在终端中执行命令：</p><pre tabindex=0><code>docker build -t frontend:v1 .
docker build -t frontend:v2 .
</code></pre><h4 id=13-完成上传至腾讯云镜像仓库>1.3 完成上传至腾讯云镜像仓库<a hidden class=anchor aria-hidden=true href=#13-完成上传至腾讯云镜像仓库>#</a></h4><p>完成登陆指令：</p><pre tabindex=0><code>docker login ccr.ccs.tencentyun.com --username=100029754889
</code></pre><p>完成镜像的更名和推送到腾讯云上的镜像仓库：</p><pre tabindex=0><code>docker tag 500112082598e896cd70b459fccf2e3c5f39874bf854589626eec751a3933a5b ccr.ccs.tencentyun.com/siriusspace/sirius:v2
docker push ccr.ccs.tencentyun.com/siriusspace/sirius:v2

docker tag f79982b77bfbe0f92a7de6a2fabdc21e818de3370aed1c38a6ab3c73d1dd0b32 ccr.ccs.tencentyun.com/siriusspace/sirius:v3
docker push ccr.ccs.tencentyun.com/siriusspace/sirius:v3
</code></pre><h4 id=14-在腾讯云上面申请一个轻量级应用服务器>1.4 在腾讯云上面申请一个轻量级应用服务器<a hidden class=anchor aria-hidden=true href=#14-在腾讯云上面申请一个轻量级应用服务器>#</a></h4><p>在腾讯云上申请一个基于容器镜像的Ubuntu20.04-Docker20系统，用于此次计算思维实训的工作环境。</p><h4 id=15-服务器环境配置>1.5 服务器环境配置<a hidden class=anchor aria-hidden=true href=#15-服务器环境配置>#</a></h4><p>在腾讯云的OracTerm上登陆，把当前用户设置成超级管理员，并且在上面安装必要的环境，如kubernetes，docker；</p><p>也可以使用SSH工具进行远程登陆进行操作，在首次使用SSH远程登陆，需要重置密码；并且当服务器重装系统之后，需要将本地的known_hosts中的文件注释掉，再重新进行登录。</p><h5 id=151-安装docker的步骤>1.5.1 安装docker的步骤：<a hidden class=anchor aria-hidden=true href=#151-安装docker的步骤>#</a></h5><ol><li><p>更新 apt 包索引：</p><pre tabindex=0><code>sudo apt-get update
</code></pre></li><li><p>安装依赖包，用于让 apt 能够通过 HTTPS 使用 Docker 仓库：</p><pre tabindex=0><code>sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release
</code></pre></li><li><p>添加 Docker 的 GPG 密钥：</p><pre tabindex=0><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
</code></pre></li><li><p>添加 Docker APT 仓库：</p><pre tabindex=0><code>echo \
  &#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable&#34; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</code></pre></li><li><p>更新 apt 包索引：</p><pre tabindex=0><code>sudo apt-get update
</code></pre></li><li><p>安装 Docker：</p><pre tabindex=0><code>sudo apt-get install docker-ce docker-ce-cli containerd.io
</code></pre></li><li><h6 id=验证-docker-是否安装成功>验证 Docker 是否安装成功<a hidden class=anchor aria-hidden=true href=#验证-docker-是否安装成功>#</a></h6><pre tabindex=0><code>sudo docker version
</code></pre></li></ol><h5 id=152-安装kubernetes的步骤>1.5.2 安装kubernetes的步骤：<a hidden class=anchor aria-hidden=true href=#152-安装kubernetes的步骤>#</a></h5><h6 id=1安装kubernetes的工具包kubeadmkubelet和kubectl>1.安装Kubernetes的工具包：kubeadm、kubelet和kubectl<a hidden class=anchor aria-hidden=true href=#1安装kubernetes的工具包kubeadmkubelet和kubectl>#</a></h6><pre tabindex=0><code>//阿里云镜像仓库
sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl
curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
EOF
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
</code></pre><h6 id=2初始化kubernetes集群>2.初始化Kubernetes集群<a hidden class=anchor aria-hidden=true href=#2初始化kubernetes集群>#</a></h6><p>​ 在安装完成kubeadm和kubelet后，使用kubeadm初始化Kubernetes集群。首先，选择腾讯云的轻量级服务器作为主节点，然后在该节点上运行以下命令：</p><pre tabindex=0><code>sudo kubeadm init --image-repository=registry.aliyuncs.com/google_containers --pod-network-cidr=10.244.0.0/16
</code></pre><p>​ 运行 kubeadm init初始化主节点Kubeadm部署了所有必要的控制面板组件，包括etcd、API服务器、Scheduler和Controller Manager，此外他还部署了kube-proxy，使得主节点可以使用Kubernetes服务。`</p><p>​ <code>--image-repository</code>选项指定Docker镜像仓库，这里使用阿里云的镜像仓库。<code>--pod-network-cidr</code>选项指定Pod网络的CIDR。</p><p>​ 该命令将自动下载并安装必要的组件，并初始化Kubernetes集群。在安装完成后，kubeadm将输出一个join命令，将此命令保存，以便于复制到另一个节点上运行以加入集群。</p><h6 id=3安装网络插件>3.安装网络插件<a hidden class=anchor aria-hidden=true href=#3安装网络插件>#</a></h6><p>​ 在Kubernetes集群中，Pod之间需要进行通信。要实现这一点，需要安装一个网络插件。</p><p>​ 使用Flannel作为网络插件，用以下命令安装Flannel：</p><pre tabindex=0><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre><h6 id=4将其他节点加入集群>4.将其他节点加入集群<a hidden class=anchor aria-hidden=true href=#4将其他节点加入集群>#</a></h6><p>​ 在工作节点上使用特定的token以及主节点的IP地址端口信息。执行kubeadm join命令，然后节点将自己的信息注册到主节点，可以在主节点上再次执行kubectl get node 命令，检查是否注册完成。</p><p>​ 对于要加入集群的节点，需要在其中一台Master节点上运行以下命令获取加入集群所需的token和证书：</p><pre tabindex=0><code>luaCopy code
sudo kubeadm token create --print-join-command
</code></pre><p>​ 将输出的命令复制到要加入集群的节点上运行，例如：</p><pre tabindex=0><code>rubyCopy code
sudo kubeadm join &lt;master-node-ip&gt;:&lt;master-node-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash &lt;hash&gt;
</code></pre><p>​ 其中<code>&lt;master-node-ip></code>是主节点的IP地址，<code>&lt;master-node-port></code>是主节点的端口，<code>&lt;token></code>是之前获取的加入集群的token，<code>&lt;hash></code>是证书的哈希值，也可以从主节点上获取。</p><p>​ 运行以上命令后，节点将会自动加入Kubernetes集群。</p><h6 id=5验证集群>5.验证集群<a hidden class=anchor aria-hidden=true href=#5验证集群>#</a></h6><p>​ 安装完成后，使用以下命令验证集群是否正常工作：</p><pre tabindex=0><code>csharpCopy code
kubectl get nodes
</code></pre><p>​ 该命令将输出所有已连接的节点的信息，如果节点显示为Ready状态，则表示节点已成功加入集群。</p><h4 id=16-编写部署文件>1.6 编写部署文件<a hidden class=anchor aria-hidden=true href=#16-编写部署文件>#</a></h4><h5 id=161-编写deploymentyaml文件>1.6.1 编写deployment.yaml文件<a hidden class=anchor aria-hidden=true href=#161-编写deploymentyaml文件>#</a></h5><p>在本地编写sirius-deployment-v1.yaml文件，上传至腾讯云服务器上的文件目录中，在执行kubectl指令，进行相关部署。</p><p>sirius-deployment-v1.yaml文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web-v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>ccr.ccs.tencentyun.com/siriusspace/sirius:v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span></code></pre></div><p>sirius-deployment-v2.yaml文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web-v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>ccr.ccs.tencentyun.com/siriusspace/sirius:v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span></code></pre></div><p>执行指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>kubectl create -f sirius-deployment-v1.yaml</span><span class=w>
</span></span></span></code></pre></div><p>可以通过命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>kubectl get deployments</span><span class=w>
</span></span></span></code></pre></div><p>查看deployment的状态。</p><h5 id=162-通过nodeport暴露服务>1.6.2 通过NodePort暴露服务<a hidden class=anchor aria-hidden=true href=#162-通过nodeport暴露服务>#</a></h5><p>编写sirius-svc-nodeport.yaml文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>sirius-nodeport</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>NodePort</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>sirius</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>nodePort</span><span class=p>:</span><span class=w> </span><span class=m>30123</span><span class=w>
</span></span></span></code></pre></div><p>执行指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>kubectl create -f sirius-svc-nodeport.yaml</span><span class=w>
</span></span></span></code></pre></div><p>可以通过命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>kubectl get svc</span><span class=w>
</span></span></span></code></pre></div><h4 id=17-配置-prometheus-和-grafna-相关功能>1.7 配置 prometheus 和 grafna 相关功能<a hidden class=anchor aria-hidden=true href=#17-配置-prometheus-和-grafna-相关功能>#</a></h4><h5 id=171-安装helm>1.7.1 安装Helm<a hidden class=anchor aria-hidden=true href=#171-安装helm>#</a></h5><p>Helm 是 Kubernetes 的包管理工具，可以用来部署各种 Kubernetes 应用，包括 Prometheus 和 Grafana。可以在终端中使用以下命令安装 Helm：</p><pre tabindex=0><code>curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash
</code></pre><h5 id=172-安装-prometheus>1.7.2 安装 Prometheus<a hidden class=anchor aria-hidden=true href=#172-安装-prometheus>#</a></h5><p>可以使用 Helm 来安装 Prometheus。先添加 Prometheus Helm chart 的仓库：</p><pre tabindex=0><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
</code></pre><p>然后更新本地的 Helm chart 缓存：</p><pre tabindex=0><code>helm repo update
</code></pre><p>使用 Helm 安装 Prometheus 了：</p><pre tabindex=0><code>helm install prometheus prometheus-community/kube-prometheus-stack
</code></pre><h5 id=173-安装-grafana>1.7.3 安装 Grafana<a hidden class=anchor aria-hidden=true href=#173-安装-grafana>#</a></h5><p>可以使用 Helm 来安装 Grafana。先添加 Grafana Helm chart 的仓库：</p><pre tabindex=0><code>helm repo add grafana https://grafana.github.io/helm-charts
</code></pre><p>然后更新本地的 Helm chart 缓存：</p><pre tabindex=0><code>helm repo update
</code></pre><p>接下来就可以使用 Helm 安装 Grafana 了：</p><pre tabindex=0><code>helm install grafana grafana/grafana
</code></pre><h5 id=174-配置-grafana>1.7.4 配置 Grafana<a hidden class=anchor aria-hidden=true href=#174-配置-grafana>#</a></h5><p>安装完成后，可以通过以下命令来获取 Grafana 的 admin 密码：</p><pre tabindex=0><code>kubectl get secret --namespace default grafana -o jsonpath=&#34;{.data.admin-password}&#34; | base64 --decode ; echo
</code></pre><p>将输出的密码复制下来，并使用浏览器访问 Grafana 的 Web 界面。默认的服务地址是 <code>http://&lt;Node-IP>:3000</code>，其中 <code>&lt;Node-IP></code> 是 Kubernetes 节点的 IP 地址。在第一次登录时需要输入管理员用户名和密码，可以使用默认的 <code>admin</code> 用户名和上面获取到的密码登录。</p><p>接下来，需要配置 Grafana 的数据源，用于连接到 Prometheus 数据库。可以通过以下步骤来配置：</p><ol><li>登录到 Grafana 的 Web 界面，点击左侧的“Configuration”按钮，然后选择“Data Sources”。</li><li>点击“Add data source”按钮，选择“Prometheus”作为数据源类型。</li><li>在“HTTP”一栏中，输入 Prometheus 的服务地址，即 <code>http://prometheus-server</code>。</li><li>点击“Save & Test”按钮，测试连接是否成功。</li></ol><p>配置完成后，就可以在 Grafana 中创建 Dashboard 并展示 Prometheus 数据了。</p><h3 id=2实践中遇到的困难>2.实践中遇到的困难<a hidden class=anchor aria-hidden=true href=#2实践中遇到的困难>#</a></h3><h4 id=21-利用dockerfile构建镜像出现错误>2.1 利用Dockerfile构建镜像出现错误<a hidden class=anchor aria-hidden=true href=#21-利用dockerfile构建镜像出现错误>#</a></h4><p>在刚开始部署的网站版本中，将网站分为了前端和后端，后端中还包含了一个MySQL数据库。网站主要实现的功能是，当用户在前端点击网页上的按钮之后，就会生成随机字符串。随机字符串是通过后端的服务产生的，并将随机产生的字符串。存储到后端的数据库中。但是它们的依赖项有很多，所以当时在用dockerfile构建镜像的时候，由于一些依赖项并没有包含进去，会导致构建镜像时和运行镜像时出现错误。</p><p>这个时候需要将所有的依赖项通过命令行打印出来，再复制到一个文件中，将该文件包含在dockerfile中才能正确运行。有的时候，在构建镜像的时候，因为网络的原因，即使没有对需要打包的文件进行调整，也会出现因为网络问题而导致的镜像构建失败的问题。然后有时候会。进行多次操作，直至镜像构建成功。</p><h4 id=22-镜像拉取请求超时>2.2 镜像拉取请求超时<a hidden class=anchor aria-hidden=true href=#22-镜像拉取请求超时>#</a></h4><pre tabindex=0><code>Error response from daemon: Get &#34;https://k8s.gcr.io/v2/&#34;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
[root@VM-4-3-centos lighthouse]# sudo docker pull k8s.gcr.io/coredns/coredns:v1.8.4
Error response from daemon: Get &#34;https://k8s.gcr.io/v2/&#34;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
</code></pre><p>有时候因为网络连接和服务器无法访问谷歌镜像仓库的原因，会导致镜像拉取出现请求超时。可以使用国内的阿里云和网易云的镜像仓库进行替换。</p><h4 id=23-在ubuntu和centos上的操作命令不同>2.3 在Ubuntu和CentOS上的操作命令不同<a hidden class=anchor aria-hidden=true href=#23-在ubuntu和centos上的操作命令不同>#</a></h4><p>有一些命令比如安装，在Ubuntu和CentOS上的不同，在Ubuntu上是apt-get指令，在CentOS上是yum的指令。需要对指令进行熟悉操作。Ubuntu和CentOS是两种常见的Linux操作系统，它们的命令行操作有很多不同之处。其中一个主要的区别是软件包管理器的不同。在Ubuntu中，软件包管理器是APT（Advanced Package Tool），而在CentOS中，软件包管理器是Yum（Yellowdog Updater, Modified）。</p><p>因此，安装软件包的命令在Ubuntu和CentOS上是不同的。在Ubuntu上，使用apt-get命令来安装软件包，例如：</p><pre tabindex=0><code>sudo apt-get install &lt;package-name&gt;
</code></pre><p>而在CentOS上，则使用yum命令来安装软件包，例如：</p><pre tabindex=0><code>sudo yum install &lt;package-name&gt;
</code></pre><h4 id=24-kubectl的安装配置>2.4 kubectl的安装配置<a hidden class=anchor aria-hidden=true href=#24-kubectl的安装配置>#</a></h4><p>在使用"kubectl cluster-info"查看集群相关信息的时候，会出现错误：</p><pre tabindex=0><code>The connection to the server 10.0.4.3:6443 was refused - did you specify the right host or port?
</code></pre><p>这个错误通常表示kubectl无法与Kubernetes API Server建立连接，这可能是由于以下原因之一造成的：</p><ol><li>Kubernetes API Server未运行或不可访问。可以尝试使用kubectl get pods &ndash;all-namespaces命令来检查集群中的所有Pod是否正在运行。</li><li>Kubernetes API Server绑定到了错误的IP地址或端口。确保正在使用正确的IP地址和端口。</li><li>防火墙或网络策略阻止了连接。请确保网络设置允许与Kubernetes API Server建立连接。</li><li>Kubectl配置文件可能配置不正确。请检查您的Kubectl配置文件，确保您的API Server端口、IP地址和证书等信息正确。</li></ol><h4 id=25-使用ssh远程登陆错误>2.5 使用SSH远程登陆错误<a hidden class=anchor aria-hidden=true href=#25-使用ssh远程登陆错误>#</a></h4><pre tabindex=0><code>ssh ubuntu@101.35.249.58
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:8T8WjRenPMEsyVejntM6DsJ1wWAjiRp1TSTHRasRRhY.
Please contact your system administrator.
Add correct host key in /home/sirius/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/sirius/.ssh/known_hosts:2
  remove with:
  ssh-keygen -f &#34;/home/sirius/.ssh/known_hosts&#34; -R &#34;101.35.249.58&#34;
Host key for 101.35.249.58 has changed and you have requested strict checking.
Host key verification failed.
</code></pre><p>这个错误提示表明SSH客户端检测到远程主机的公钥与之前存储在本地known_hosts文件中的公钥不匹配。 这可能是由于中间人攻击或远程主机重新安装操作系统等原因导致的。所以，当服务器重装系统之后，需要将本地的known_hosts中的文件注释掉，再重新进行登录。</p></div><footer class=post-footer><ul class=post-tags><li><a href=//localhost:1313/tags/kubernetes/>Kubernetes</a></li><li><a href=//localhost:1313/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></li></ul><nav class=paginav><a class=prev href=//localhost:1313/posts/notes/security/encryption-authentication/><span class=title>« Prev</span><br><span>加密与认证</span>
</a><a class=next href=//localhost:1313/posts/notes/professional-classes/data_structure/><span class=title>Next »</span><br><span>数据结构学习笔记</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2024 <a href=//localhost:1313/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>