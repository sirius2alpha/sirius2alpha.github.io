<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据结构学习笔记 | Sirius' Blog</title>
<meta name=keywords content="数据结构,学习笔记"><meta name=description content="一、绪论 数据（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。
数据的最小单位的是数据项；
数据的基本单位是数据元素，一个数据元素可由若干个数据项组成。
数据结构分为两大类：线性结构和非线性结构
两类结构通常分为四类基本结构：
1）集合：结构中的数据元素之间同属于一个集合，此外没有其他关系；
2）线性结构：结构中的数据元素之间存在一种线性关系，一对一的关系；
3）树形结构：一对多的关系；
4）图形结构或网状结构：多对多的关系。
根据视点的不同又可分为：逻辑结构和物理结构：
逻辑结构：面向问题，描述数据元素之间的逻辑关系；
物理结构：又称存储结构，面向计算机，是数据结构在计算机中的表示（映像）
算法的特性：输入性、输出性、确定性、有穷性、有效性（可行性）
算法的标准：正确性（满足所要求界的问题的需求，最重要最基本）、可用性（便于用户使用，良好的界面、完备的用户文档）、可读性（易于理解）、效率（存储单元的开销和运行时间的耗费）、健壮性（对于非法数据的处理）
算法复杂度：（渐进）时间复杂度和空间复杂度
二、线性结构 1、线性表 1.1	顺序表示：顺序表 用顺序结构存储的线性表为顺序表（sequential list）。
顺序表一般用数组进行存储
类模板定义：T* elems，int length，int maxLength
1.2	链表表示 1)	单链表 分为带头结点和不带头结点的单链表；
带头结点的单链表相对不带头结点的单链表在涉及会更改头节点的任务时，操作会更加统一。
类模板定义：
（结点）T data，Node* next
（单链表）Node* head，int length
2)	双向循环链表 类模板定义：
（结点）T data，Node* prior，Node* next
（双向循环链表）Node* head，int length
*带头结点的双向循环列表只有一个元素结点的条件：head->next!=head && head->next->next==head
3)	静态链表 利用数组来模拟存储空间实现链表。
类模板定义：
（结点）T data，Node* next
（静态链表）Node* head，Node* avail
设数组a放置了一个静态链表，当链表未使用的时候，其中所有的结点都是形成了一个链表，用avail进行管理，代表未使用的结点。
当进行插入操作的时候，就从avail中取出一个头节点，进行赋值，再放入head链表之中。
在完成每一步操作之后，记得要将next域中更改
插入元素操作：
i=avail; avail=a[avail].next; a[i].next=a[head],next; a[head]。next=i; 当需要释放由j所指向的结点时，只需要把结点j放到avail表的最前端，并让avail指向它即可。"><meta name=author content="sirius1y"><link rel=canonical href=//localhost:1313/posts/notes/professional-classes/data_structure/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=//localhost:1313/images/icon.png><link rel=icon type=image/png sizes=16x16 href=//localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=//localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=//localhost:1313/apple-touch-icon.png><link rel=mask-icon href=//localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=//localhost:1313/posts/notes/professional-classes/data_structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="数据结构学习笔记"><meta property="og:description" content="一、绪论 数据（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。
数据的最小单位的是数据项；
数据的基本单位是数据元素，一个数据元素可由若干个数据项组成。
数据结构分为两大类：线性结构和非线性结构
两类结构通常分为四类基本结构：
1）集合：结构中的数据元素之间同属于一个集合，此外没有其他关系；
2）线性结构：结构中的数据元素之间存在一种线性关系，一对一的关系；
3）树形结构：一对多的关系；
4）图形结构或网状结构：多对多的关系。
根据视点的不同又可分为：逻辑结构和物理结构：
逻辑结构：面向问题，描述数据元素之间的逻辑关系；
物理结构：又称存储结构，面向计算机，是数据结构在计算机中的表示（映像）
算法的特性：输入性、输出性、确定性、有穷性、有效性（可行性）
算法的标准：正确性（满足所要求界的问题的需求，最重要最基本）、可用性（便于用户使用，良好的界面、完备的用户文档）、可读性（易于理解）、效率（存储单元的开销和运行时间的耗费）、健壮性（对于非法数据的处理）
算法复杂度：（渐进）时间复杂度和空间复杂度
二、线性结构 1、线性表 1.1	顺序表示：顺序表 用顺序结构存储的线性表为顺序表（sequential list）。
顺序表一般用数组进行存储
类模板定义：T* elems，int length，int maxLength
1.2	链表表示 1)	单链表 分为带头结点和不带头结点的单链表；
带头结点的单链表相对不带头结点的单链表在涉及会更改头节点的任务时，操作会更加统一。
类模板定义：
（结点）T data，Node* next
（单链表）Node* head，int length
2)	双向循环链表 类模板定义：
（结点）T data，Node* prior，Node* next
（双向循环链表）Node* head，int length
*带头结点的双向循环列表只有一个元素结点的条件：head->next!=head && head->next->next==head
3)	静态链表 利用数组来模拟存储空间实现链表。
类模板定义：
（结点）T data，Node* next
（静态链表）Node* head，Node* avail
设数组a放置了一个静态链表，当链表未使用的时候，其中所有的结点都是形成了一个链表，用avail进行管理，代表未使用的结点。
当进行插入操作的时候，就从avail中取出一个头节点，进行赋值，再放入head链表之中。
在完成每一步操作之后，记得要将next域中更改
插入元素操作：
i=avail; avail=a[avail].next; a[i].next=a[head],next; a[head]。next=i; 当需要释放由j所指向的结点时，只需要把结点j放到avail表的最前端，并让avail指向它即可。"><meta property="og:type" content="article"><meta property="og:url" content="//localhost:1313/posts/notes/professional-classes/data_structure/"><meta property="og:image" content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-26T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-26T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="数据结构学习笔记"><meta name=twitter:description content="一、绪论 数据（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。
数据的最小单位的是数据项；
数据的基本单位是数据元素，一个数据元素可由若干个数据项组成。
数据结构分为两大类：线性结构和非线性结构
两类结构通常分为四类基本结构：
1）集合：结构中的数据元素之间同属于一个集合，此外没有其他关系；
2）线性结构：结构中的数据元素之间存在一种线性关系，一对一的关系；
3）树形结构：一对多的关系；
4）图形结构或网状结构：多对多的关系。
根据视点的不同又可分为：逻辑结构和物理结构：
逻辑结构：面向问题，描述数据元素之间的逻辑关系；
物理结构：又称存储结构，面向计算机，是数据结构在计算机中的表示（映像）
算法的特性：输入性、输出性、确定性、有穷性、有效性（可行性）
算法的标准：正确性（满足所要求界的问题的需求，最重要最基本）、可用性（便于用户使用，良好的界面、完备的用户文档）、可读性（易于理解）、效率（存储单元的开销和运行时间的耗费）、健壮性（对于非法数据的处理）
算法复杂度：（渐进）时间复杂度和空间复杂度
二、线性结构 1、线性表 1.1	顺序表示：顺序表 用顺序结构存储的线性表为顺序表（sequential list）。
顺序表一般用数组进行存储
类模板定义：T* elems，int length，int maxLength
1.2	链表表示 1)	单链表 分为带头结点和不带头结点的单链表；
带头结点的单链表相对不带头结点的单链表在涉及会更改头节点的任务时，操作会更加统一。
类模板定义：
（结点）T data，Node* next
（单链表）Node* head，int length
2)	双向循环链表 类模板定义：
（结点）T data，Node* prior，Node* next
（双向循环链表）Node* head，int length
*带头结点的双向循环列表只有一个元素结点的条件：head->next!=head && head->next->next==head
3)	静态链表 利用数组来模拟存储空间实现链表。
类模板定义：
（结点）T data，Node* next
（静态链表）Node* head，Node* avail
设数组a放置了一个静态链表，当链表未使用的时候，其中所有的结点都是形成了一个链表，用avail进行管理，代表未使用的结点。
当进行插入操作的时候，就从avail中取出一个头节点，进行赋值，再放入head链表之中。
在完成每一步操作之后，记得要将next域中更改
插入元素操作：
i=avail; avail=a[avail].next; a[i].next=a[head],next; a[head]。next=i; 当需要释放由j所指向的结点时，只需要把结点j放到avail表的最前端，并让avail指向它即可。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"//localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"数据结构学习笔记","item":"//localhost:1313/posts/notes/professional-classes/data_structure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据结构学习笔记","name":"数据结构学习笔记","description":"一、绪论 数据（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。\n数据的最小单位的是数据项；\n数据的基本单位是数据元素，一个数据元素可由若干个数据项组成。\n数据结构分为两大类：线性结构和非线性结构\n两类结构通常分为四类基本结构：\n1）集合：结构中的数据元素之间同属于一个集合，此外没有其他关系；\n2）线性结构：结构中的数据元素之间存在一种线性关系，一对一的关系；\n3）树形结构：一对多的关系；\n4）图形结构或网状结构：多对多的关系。\n根据视点的不同又可分为：逻辑结构和物理结构：\n逻辑结构：面向问题，描述数据元素之间的逻辑关系；\n物理结构：又称存储结构，面向计算机，是数据结构在计算机中的表示（映像）\n算法的特性：输入性、输出性、确定性、有穷性、有效性（可行性）\n算法的标准：正确性（满足所要求界的问题的需求，最重要最基本）、可用性（便于用户使用，良好的界面、完备的用户文档）、可读性（易于理解）、效率（存储单元的开销和运行时间的耗费）、健壮性（对于非法数据的处理）\n算法复杂度：（渐进）时间复杂度和空间复杂度\n二、线性结构 1、线性表 1.1\t顺序表示：顺序表 用顺序结构存储的线性表为顺序表（sequential list）。\n顺序表一般用数组进行存储\n类模板定义：T* elems，int length，int maxLength\n1.2\t链表表示 1)\t单链表 分为带头结点和不带头结点的单链表；\n带头结点的单链表相对不带头结点的单链表在涉及会更改头节点的任务时，操作会更加统一。\n类模板定义：\n（结点）T data，Node* next\n（单链表）Node* head，int length\n2)\t双向循环链表 类模板定义：\n（结点）T data，Node* prior，Node* next\n（双向循环链表）Node* head，int length\n*带头结点的双向循环列表只有一个元素结点的条件：head-\u0026gt;next!=head \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;next==head\n3)\t静态链表 利用数组来模拟存储空间实现链表。\n类模板定义：\n（结点）T data，Node* next\n（静态链表）Node* head，Node* avail\n设数组a放置了一个静态链表，当链表未使用的时候，其中所有的结点都是形成了一个链表，用avail进行管理，代表未使用的结点。\n当进行插入操作的时候，就从avail中取出一个头节点，进行赋值，再放入head链表之中。\n在完成每一步操作之后，记得要将next域中更改\n插入元素操作：\ni=avail; avail=a[avail].next; a[i].next=a[head],next; a[head]。next=i; 当需要释放由j所指向的结点时，只需要把结点j放到avail表的最前端，并让avail指向它即可。","keywords":["数据结构","学习笔记"],"articleBody":"一、绪论 数据（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。\n数据的最小单位的是数据项；\n数据的基本单位是数据元素，一个数据元素可由若干个数据项组成。\n数据结构分为两大类：线性结构和非线性结构\n两类结构通常分为四类基本结构：\n1）集合：结构中的数据元素之间同属于一个集合，此外没有其他关系；\n2）线性结构：结构中的数据元素之间存在一种线性关系，一对一的关系；\n3）树形结构：一对多的关系；\n4）图形结构或网状结构：多对多的关系。\n根据视点的不同又可分为：逻辑结构和物理结构：\n逻辑结构：面向问题，描述数据元素之间的逻辑关系；\n物理结构：又称存储结构，面向计算机，是数据结构在计算机中的表示（映像）\n算法的特性：输入性、输出性、确定性、有穷性、有效性（可行性）\n算法的标准：正确性（满足所要求界的问题的需求，最重要最基本）、可用性（便于用户使用，良好的界面、完备的用户文档）、可读性（易于理解）、效率（存储单元的开销和运行时间的耗费）、健壮性（对于非法数据的处理）\n算法复杂度：（渐进）时间复杂度和空间复杂度\n二、线性结构 1、线性表 1.1\t顺序表示：顺序表 用顺序结构存储的线性表为顺序表（sequential list）。\n顺序表一般用数组进行存储\n类模板定义：T* elems，int length，int maxLength\n1.2\t链表表示 1)\t单链表 分为带头结点和不带头结点的单链表；\n带头结点的单链表相对不带头结点的单链表在涉及会更改头节点的任务时，操作会更加统一。\n类模板定义：\n（结点）T data，Node* next\n（单链表）Node* head，int length\n2)\t双向循环链表 类模板定义：\n（结点）T data，Node* prior，Node* next\n（双向循环链表）Node* head，int length\n*带头结点的双向循环列表只有一个元素结点的条件：head-\u003enext!=head \u0026\u0026 head-\u003enext-\u003enext==head\n3)\t静态链表 利用数组来模拟存储空间实现链表。\n类模板定义：\n（结点）T data，Node* next\n（静态链表）Node* head，Node* avail\n设数组a放置了一个静态链表，当链表未使用的时候，其中所有的结点都是形成了一个链表，用avail进行管理，代表未使用的结点。\n当进行插入操作的时候，就从avail中取出一个头节点，进行赋值，再放入head链表之中。\n在完成每一步操作之后，记得要将next域中更改\n插入元素操作：\ni=avail; avail=a[avail].next; a[i].next=a[head],next; a[head]。next=i; 当需要释放由j所指向的结点时，只需要把结点j放到avail表的最前端，并让avail指向它即可。\n所设j所指结点的前一个结点的指针是p，则\n删除元素操作：\na[p].next=a[j],next; a[j].next=avail; avail=j; 2、栈和队列 2.1\t栈 特点：先进后出 FILO\n1)\t顺序栈（SeqStack） 类模板定义：\nint top（栈顶指针），int maxsize（栈最大容量），T* elems（元素存储空间）\n初始化时top=-1\n入栈操作push：elems[++top] = e\n出栈操作pop：e = elems[top--];\n取栈顶元素：e = elems[top];\n两个顺序栈共享一个数组空间：两个栈的栈底在数组两端，只有当两个栈的栈顶指针相遇时，才会出现栈满溢出\n2)\t链式栈（LinkStack） 与顺序栈相比，链式栈对于同时使用多个栈的情况下可以共享存储。\n类模板定义：\n（链栈）Node* top\n用单链表表示的栈，栈顶在head，栈底在链表的尾部\n3)\t应用：表达式求值 后缀表达式的计算 ​\t方法：栈放操作数，遇到数字入栈，遇到操作符就将对应数目的操作符出栈并进行运算。\n​\t判断出错：如果操作数栈中的操作数数目不到两个，或者计算结束时栈中有多个操作数时候说明后缀式出错。\n中缀表达式转为后缀表达式（用栈实现） ​\t方法：栈放操作符\n中缀表达式转为后缀表达式的简单方法 ​\t1.将中缀表达式中的每一步操作加上括号\n​\t2.每个操作符一道对应该操作的右边括号外\n​\t3.删除所有括号\n​\t验证方法：用中缀表达式构建二叉树（注意要按照顺序来构建），用后序遍历\n2.2\t队列 特点：先进先出 FIFO\n1)\t顺序循环队列 队头：允许出队；队尾：允许入队\n类模板定义：\n（队头指针）int front，（队尾指针）int rear\nint maxsize（最大容量），T* elems（元素存储空间）\n初始化队列为空，front=rear=0；（教材上的定义是这样写的，具体在做题的时候要看是否符合题目的要求）\n当队头指针front或者队尾指针rear达到maxsize-1时，就要进行求模操作。\n由于队列空和队列满的状态都是rear==front，所以用少一个存储空间的方法进行解决：\n循环队列满的条件为：(rear+1)%maxsize==front\n循环队列空的条件为：front==rear\n入队操作：rear=(rear+1)%maxsize，要先判断队列是不是满了\n出队操作：front=(fornt+1)%maxsize，要先判断队列是不是已经空了\n2)\t链式队列 用单链表表示的链队列适合数据元素变化较大的情形。\n类模板定义：（带头结点）\nNode* front（指向队列的头节点），rear（指向队尾结点）\n3)\t应用：车厢调度 2.3\t递归 尾递归\n单向递归（循环）\n用栈模拟递归\nF(m,n)=m+n+1; m*n=0; 栈和队列的应用： 数值转换，括号匹配，回文，车厢调度\n表达式求值：中缀、后缀、前缀表达式（二叉树）先序中序后序遍历\n后缀表达式求值（栈放操作数）\n中缀转后缀（栈放操作符）\n3、串、数组、广义表 1、字符串的模式匹配算法 定义：子串定位\n1)\tBrute-Force算法 BF算法基本思想：从一个位置开始向后面开始比较，当匹配失败的时候回到刚开始比较的位置的下一个位置重新开始比较。\ni表示ob中的下标，j表示模式串pat中的下标\n相等：i++;j++;继续比较\n不相等：i=i-j+1;j=0;回到原来的地方，再往前进一个位置\n最坏情况下的运行时间O(m*n)，简单但是效率低下，带回溯\n2)\tKMP算法 改进：消除了BF算法中主串下标i在对应字符中比较不相等需要回退的现象\n真子串的概念：\n在字符串“t0，t1，….，tn-1”中最长的相等前缀和后缀称为该字符串的真子串，也就是说在字串“t0，t1，…，tn-1”中存在一个最大的k(0","wordCount":"3943","inLanguage":"en","image":"//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-10-26T00:00:00Z","dateModified":"2022-10-26T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"//localhost:1313/posts/notes/professional-classes/data_structure/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"//localhost:1313/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=//localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=//localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=//localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=//localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=//localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=//localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=//localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=//localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">数据结构学习笔记</h1><div class=post-meta><span title='2022-10-26 00:00:00 +0000 UTC'>October 26, 2022</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;3943 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e7%bb%aa%e8%ae%ba aria-label=一、绪论>一、绪论</a></li><li><a href=#%e4%ba%8c%e7%ba%bf%e6%80%a7%e7%bb%93%e6%9e%84 aria-label=二、线性结构>二、线性结构</a><ul><li><a href=#1%e7%ba%bf%e6%80%a7%e8%a1%a8 aria-label=1、线性表>1、线性表</a><ul><li><a href=#11%e9%a1%ba%e5%ba%8f%e8%a1%a8%e7%a4%ba%e9%a1%ba%e5%ba%8f%e8%a1%a8 aria-label="1.1	顺序表示：顺序表">1.1 顺序表示：顺序表</a></li><li><a href=#12%e9%93%be%e8%a1%a8%e8%a1%a8%e7%a4%ba aria-label="1.2	链表表示">1.2 链表表示</a><ul><li><a href=#1%e5%8d%95%e9%93%be%e8%a1%a8 aria-label="1)	单链表">1) 单链表</a></li><li><a href=#2%e5%8f%8c%e5%90%91%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8 aria-label="2)	双向循环链表">2) 双向循环链表</a></li><li><a href=#3%e9%9d%99%e6%80%81%e9%93%be%e8%a1%a8 aria-label="3)	静态链表">3) 静态链表</a></li></ul></li></ul></li><li><a href=#2%e6%a0%88%e5%92%8c%e9%98%9f%e5%88%97 aria-label=2、栈和队列>2、栈和队列</a><ul><li><a href=#21%e6%a0%88 aria-label="2.1	栈">2.1 栈</a><ul><li><a href=#1%e9%a1%ba%e5%ba%8f%e6%a0%88seqstack aria-label="1)	顺序栈（SeqStack）">1) 顺序栈（SeqStack）</a></li><li><a href=#2%e9%93%be%e5%bc%8f%e6%a0%88linkstack aria-label="2)	链式栈（LinkStack）">2) 链式栈（LinkStack）</a></li><li><a href=#3%e5%ba%94%e7%94%a8%e8%a1%a8%e8%be%be%e5%bc%8f%e6%b1%82%e5%80%bc aria-label="3)	应用：表达式求值">3) 应用：表达式求值</a></li></ul></li><li><a href=#22%e9%98%9f%e5%88%97 aria-label="2.2	队列">2.2 队列</a><ul><li><a href=#1%e9%a1%ba%e5%ba%8f%e5%be%aa%e7%8e%af%e9%98%9f%e5%88%97 aria-label="1)	顺序循环队列">1) 顺序循环队列</a></li><li><a href=#2%e9%93%be%e5%bc%8f%e9%98%9f%e5%88%97 aria-label="2)	链式队列">2) 链式队列</a></li><li><a href=#3%e5%ba%94%e7%94%a8%e8%bd%a6%e5%8e%a2%e8%b0%83%e5%ba%a6 aria-label="3)	应用：车厢调度">3) 应用：车厢调度</a></li></ul></li><li><a href=#23%e9%80%92%e5%bd%92 aria-label="2.3	递归">2.3 递归</a></li><li><a href=#%e6%a0%88%e5%92%8c%e9%98%9f%e5%88%97%e7%9a%84%e5%ba%94%e7%94%a8 aria-label=栈和队列的应用：>栈和队列的应用：</a></li></ul></li><li><a href=#3%e4%b8%b2%e6%95%b0%e7%bb%84%e5%b9%bf%e4%b9%89%e8%a1%a8 aria-label=3、串、数组、广义表>3、串、数组、广义表</a><ul><li><a href=#1%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95 aria-label=1、字符串的模式匹配算法>1、字符串的模式匹配算法</a><ul><li><a href=#1brute-force%e7%ae%97%e6%b3%95 aria-label="1)	Brute-Force算法">1) Brute-Force算法</a></li><li><a href=#2kmp%e7%ae%97%e6%b3%95 aria-label="2)	KMP算法">2) KMP算法</a></li></ul></li><li><a href=#2%e6%95%b0%e7%bb%84 aria-label=2、数组>2、数组</a></li><li><a href=#3%e7%a8%80%e7%96%8f%e7%9f%a9%e9%98%b5 aria-label=3、稀疏矩阵>3、稀疏矩阵</a><ul><li><a href=#1-%e9%a1%ba%e5%ba%8f%e7%bb%93%e6%9e%84%e5%ad%98%e5%82%a8%e4%b8%89%e5%85%83%e7%bb%84%e9%a1%ba%e5%ba%8f%e8%a1%a8 aria-label="1、 顺序结构存储：三元组顺序表">1、 顺序结构存储：三元组顺序表</a><ul><li><a href=#1%e4%b8%89%e5%85%83%e7%bb%84%e8%a1%a8%e8%bd%ac%e7%bd%ae%e5%87%bd%e6%95%b0%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="1)	三元组表转置函数的实现">1) 三元组表转置函数的实现</a></li><li><a href=#2%e4%b8%89%e5%85%83%e7%bb%84%e8%a1%a8%e7%9a%84%e7%bb%98%e5%88%b6 aria-label="2)	三元组表的绘制">2) 三元组表的绘制</a></li></ul></li><li><a href=#2%e9%93%be%e5%bc%8f%e7%bb%93%e6%9e%84%e5%ad%98%e5%82%a8%e5%8d%81%e5%ad%97%e9%93%be%e8%a1%a8 aria-label=2、链式结构存储：十字链表>2、链式结构存储：十字链表</a></li><li><a href=#3%e5%85%b6%e4%bb%96%e7%89%b9%e6%ae%8a%e7%9f%a9%e9%98%b5 aria-label=3、其他特殊矩阵>3、其他特殊矩阵</a><ul><li><a href=#1%e5%af%b9%e7%a7%b0%e7%9f%a9%e9%98%b5-aij--aji aria-label="1、对称矩阵 Aij = Aji">1、对称矩阵 Aij = Aji</a></li><li><a href=#2%e4%b8%89%e5%af%b9%e8%a7%92%e7%9f%a9%e9%98%b5 aria-label=2、三对角矩阵>2、三对角矩阵</a></li></ul></li></ul></li><li><a href=#4%e5%b9%bf%e4%b9%89%e8%a1%a8 aria-label=4、广义表>4、广义表</a><ul><li><a href=#1%e5%b9%bf%e4%b9%89%e8%a1%a8%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=1、广义表的定义>1、广义表的定义</a></li><li><a href=#2%e5%b9%bf%e4%b9%89%e8%a1%a8%e7%9a%84%e7%bb%98%e5%88%b6 aria-label=2、广义表的绘制>2、广义表的绘制</a></li></ul></li></ul></li></ul></li><li><a href=#%e9%a1%b9%e7%9b%ae%e8%b0%83%e8%af%95%e4%b8%89%e5%85%83%e7%bb%84%e8%a1%a8 aria-label=【项目调试】三元组表>【项目调试】三元组表</a><ul><li><a href=#1lnk2019lnk2005 aria-label=1、LNK2019,LNK2005>1、LNK2019,LNK2005</a></li><li><a href=#2%e5%af%b9%e4%ba%8e%e6%9c%89%e5%be%88%e5%a4%9aif-else%e5%88%86%e6%94%af%e7%9a%84%e7%bb%93%e6%9e%84 aria-label=2、对于有很多if-else分支的结构>2、对于有很多if-else分支的结构</a></li><li><a href=#3%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e4%b8%b2%e6%9c%89%e6%b2%a1%e6%9c%89%e9%81%8d%e5%8e%86%e5%ae%8c aria-label=3、判断一个串有没有遍历完>3、判断一个串有没有遍历完</a></li></ul></li><li><a href=#%e4%b8%89%e6%a0%91%e5%92%8c%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=三、树和二叉树>三、树和二叉树</a><ul><li><a href=#1%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%80%a7%e8%b4%a8 aria-label=1、二叉树的性质>1、二叉树的性质</a></li><li><a href=#2%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label=2、二叉树的存储结构>2、二叉树的存储结构</a></li><li><a href=#3%e9%81%8d%e5%8e%86%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95 aria-label=3、遍历递归算法>3、遍历递归算法</a><ul><li><a href=#1%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86 aria-label="1)	前序遍历">1) 前序遍历</a></li><li><a href=#2%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86 aria-label="2)	中序遍历">2) 中序遍历</a></li><li><a href=#3%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86 aria-label="3)	后序遍历">3) 后序遍历</a></li></ul></li><li><a href=#4%e9%9d%9e%e9%80%92%e5%bd%92%e9%81%8d%e5%8e%86%e7%ae%97%e6%b3%95 aria-label=4、非递归遍历算法>4、非递归遍历算法</a><ul><ul><li><a href=#%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e9%9d%9e%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95 aria-label=中序遍历非递归算法>中序遍历非递归算法</a></li></ul></ul></li><li><a href=#5%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=5、线索二叉树>5、线索二叉树</a><ul><ul><li><a href=#1%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9e%84%e6%88%90 aria-label="1)	线索二叉树的构成">1) 线索二叉树的构成</a></li><li><a href=#2%e7%ba%bf%e7%b4%a2%e5%8c%96%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="2)	线索化二叉树">2) 线索化二叉树</a></li></ul></ul></li><li><a href=#6%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%ba%94%e7%94%a8 aria-label=6、二叉树的应用>6、二叉树的应用</a><ul><li><a href=#61%e5%a0%86 aria-label="6.1	堆">6.1 堆</a><ul><li><a href=#1filterup%e5%92%8cfilterdown%e7%ae%97%e6%b3%95 aria-label="1)	FilterUp和FilterDown算法">1) FilterUp和FilterDown算法</a></li></ul></li><li><a href=#62%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91 aria-label="6.2	哈夫曼树">6.2 哈夫曼树</a><ul><li><a href=#1%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91%e5%ae%9a%e4%b9%89 aria-label="1)	哈夫曼树定义">1) 哈夫曼树定义</a></li><li><a href=#2%e6%9e%84%e9%80%a0%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91 aria-label="2)	构造哈夫曼树">2) 构造哈夫曼树</a></li><li><a href=#3%e5%93%88%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81 aria-label="3)	哈夫曼编码">3) 哈夫曼编码</a></li></ul></li></ul></li><li><a href=#7%e7%a1%ae%e5%ae%9a%e4%b8%80%e6%a3%b5%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=7、确定一棵二叉树>7、确定一棵二叉树</a><ul><li><a href=#1%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86 aria-label=1、中序遍历+前序遍历/后序遍历>1、中序遍历+前序遍历/后序遍历</a><ul><li><a href=#11--%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3%e5%88%86%e6%9e%90 aria-label="1.1  算法思想分析">1.1 算法思想分析</a></li><li><a href=#12-%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b aria-label="1.2 算法流程">1.2 算法流程</a></li></ul></li><li><a href=#2%e5%8f%b7%e6%b3%95%e7%a1%ae%e5%ae%9a%e5%a6%82%e6%9e%9c%e6%b2%a1%e6%9c%89%e5%b7%a6%e5%8f%b3%e5%ad%90%e6%a0%91%e5%88%99%e4%bd%bf%e7%94%a8%e5%8f%b7%e4%bb%a3%e6%9b%bf%e9%81%8d%e5%8e%86%e6%97%b6%e7%94%a8%e4%bb%a3%e6%9b%bfnull aria-label=2、#号法确定：如果没有左右子树，则使用#号代替，遍历时用#代替NULL>2、#号法确定：如果没有左右子树，则使用#号代替，遍历时用#代替NULL</a><ul><li><a href=#21-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3%e5%88%86%e6%9e%90 aria-label="2.1 算法思想分析">2.1 算法思想分析</a></li><li><a href=#22-%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b aria-label="2.2 算法流程">2.2 算法流程</a></li><li><a href=#23%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0 aria-label=2.3算法实现>2.3算法实现</a></li></ul></li></ul></li><li><a href=#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%a0%91%e5%bd%a2%e6%98%be%e7%a4%ba aria-label=二叉树的树形显示>二叉树的树形显示</a><ul><ul><li><a href=#1%e5%9c%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%bb%93%e7%82%b9%e7%9a%84%e6%88%90%e5%91%98%e4%b8%ad%e5%a2%9e%e5%8a%a0xy%e5%9d%90%e6%a0%87%e7%9a%84%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98 aria-label=1、在二叉树结点的成员中增加x,y坐标的数据成员>1、在二叉树结点的成员中增加x,y坐标的数据成员</a></li><li><a href=#2%e7%bc%96%e5%86%99%e8%ae%be%e7%bd%ae%e4%ba%8c%e5%8f%89%e6%a0%91%e5%9d%90%e6%a0%87%e7%9a%84%e5%87%bd%e6%95%b0 aria-label=2、编写设置二叉树坐标的函数>2、编写设置二叉树坐标的函数</a></li><li><a href=#3%e9%80%9a%e8%bf%87%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86%e9%85%8d%e5%90%88xy%e5%9d%90%e6%a0%87%e8%bf%9b%e8%a1%8c%e8%be%93%e5%87%ba aria-label=3、通过二叉树的层次遍历，配合x,y坐标进行输出>3、通过二叉树的层次遍历，配合x,y坐标进行输出</a></li><li><a href=#4%e8%be%93%e5%87%ba%e7%bb%93%e6%9e%9c aria-label=4.输出结果>4.输出结果</a></li></ul></ul></li><li><a href=#8%e6%a0%91%e5%92%8c%e6%a3%ae%e6%9e%97%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=8、树和森林的实现>8、树和森林的实现</a><ul><li><a href=#1%e6%a0%91%e7%9a%84%e5%ad%98%e5%82%a8 aria-label=1、树的存储>1、树的存储</a><ul><li><a href=#1-%e5%8f%8c%e4%ba%b2%e6%95%b0%e7%bb%84%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label="1） 双亲数组表示法">1） <strong>双亲数组表示法</strong></a></li><li><a href=#2%e5%ad%a9%e5%ad%90%e7%bb%93%e7%82%b9%e4%b8%ba%e5%8d%95%e9%93%be%e8%a1%a8-%e5%ad%a9%e5%ad%90%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label="2）孩子结点为单链表 （孩子表示法）">2）<strong>孩子结点为单链表 （孩子表示法）</strong></a></li><li><a href=#3%e5%b8%a6%e5%8f%8c%e4%ba%b2%e7%9a%84%e5%ad%a9%e5%ad%90%e9%93%be%e8%a1%a8-%e5%8f%8c%e4%ba%b2-%e5%ad%a9%e5%ad%90%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label="3）带双亲的孩子链表 （双亲-孩子表示法）">3）<strong>带双亲的孩子链表 （双亲-孩子表示法）</strong></a></li><li><a href=#4%e5%8f%8c%e9%87%8d%e9%93%be%e8%a1%a8%e5%ad%a9%e5%ad%90-%e5%85%84%e5%bc%9f%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label=4）双重链表（孩子-兄弟表示法）>4）<strong>双重链表（孩子-兄弟表示法）</strong></a></li></ul></li><li><a href=#2%e6%a0%91%e6%a3%ae%e6%9e%97%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label=2、树、森林、二叉树的转换>2、树、森林、二叉树的转换</a><ul><li><a href=#1%e6%a0%91%e8%bd%ac%e6%8d%a2%e4%b8%ba%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=1）树转换为二叉树>1）树转换为二叉树</a></li><li><a href=#2%e6%a3%ae%e6%9e%97%e8%bd%ac%e6%8d%a2%e4%b8%ba%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=2）森林转换为二叉树>2）森林转换为二叉树</a></li><li><a href=#3%e4%ba%8c%e5%8f%89%e6%a0%91%e8%bd%ac%e5%8c%96%e4%b8%ba%e6%a0%91 aria-label=3）二叉树转化为树>3）二叉树转化为树</a></li><li><a href=#4%e4%ba%8c%e5%8f%89%e6%a0%91%e8%bd%ac%e5%8c%96%e4%b8%ba%e6%a3%ae%e6%9e%97 aria-label=4）二叉树转化为森林>4）<strong>二叉树转化为森林</strong></a></li></ul></li><li><a href=#3%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86 aria-label=3、树的遍历>3、树的遍历</a><ul><li><a href=#1%e5%85%88%e6%a0%b9%e9%81%8d%e5%8e%86 aria-label=1）先根遍历>1）先根遍历</a></li><li><a href=#2%e5%90%8e%e6%a0%b9%e9%81%8d%e5%8e%86 aria-label=2）后根遍历>2）后根遍历</a></li><li><a href=#3%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86 aria-label=3）层次遍历>3）层次遍历</a></li></ul></li><li><a href=#4%e6%a3%ae%e6%9e%97%e7%9a%84%e9%81%8d%e5%8e%86 aria-label=4、森林的遍历>4、森林的遍历</a><ul><li><a href=#1%e5%85%88%e6%a0%b9%e9%81%8d%e5%8e%86-1 aria-label=1.先根遍历>1.<strong>先根遍历</strong></a></li><li><a href=#2%e4%b8%ad%e6%a0%b9%e9%81%8d%e5%8e%86 aria-label=2.中根遍历>2.<strong>中根遍历</strong></a></li><li><a href=#3%e5%90%8e%e6%a0%b9%e9%81%8d%e5%8e%86 aria-label=3.后根遍历>3.<strong>后根遍历</strong></a></li></ul></li></ul></li><li><a href=#9%e7%ad%89%e4%bb%b7%e7%b1%bb%e5%8f%8a%e5%85%b6%e8%a1%a8%e7%a4%ba aria-label=9、等价类及其表示>9、等价类及其表示</a><ul><li><a href=#1%e7%ad%89%e4%bb%b7%e5%85%b3%e7%b3%bb%e4%b8%8e%e7%ad%89%e4%bb%b7%e7%b1%bb aria-label=1、等价关系与等价类>1、等价关系与等价类</a></li><li><a href=#2%e5%b9%b6%e6%9f%a5%e9%9b%86 aria-label=2、并查集>2、并查集</a></li></ul></li></ul></li><li><a href=#%e6%8b%93%e5%b1%95%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8-bloom-filter aria-label="【拓展】布隆过滤器 Bloom Filter">【拓展】布隆过滤器 Bloom Filter</a><ul><li><a href=#c aria-label=C++>C++</a><ul><li><a href=#%e7%bc%96%e8%af%91 aria-label=编译>编译</a></li><li><a href=#%e5%8f%8d%e7%bc%96%e8%af%91 aria-label=反编译>反编译</a></li></ul></li><li><a href=#java aria-label=Java>Java</a></li><li><a href=#python aria-label=python>python</a></li></ul></li><li><a href=#%e5%9b%9b%e5%9b%be aria-label=四、图>四、图</a><ul><li><a href=#1%e5%9b%be%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="1.	图的基本概念">1. 图的基本概念</a></li><li><a href=#2%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label="2.	图的存储结构">2. 图的存储结构</a><ul><li><a href=#21%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5 aria-label="2.1	邻接矩阵">2.1 邻接矩阵</a></li><li><a href=#22%e9%82%bb%e6%8e%a5%e8%a1%a8 aria-label="2.2	邻接表">2.2 邻接表</a></li><li><a href=#23%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e5%92%8c%e9%82%bb%e6%8e%a5%e8%a1%a8%e7%9a%84%e6%af%94%e8%be%83 aria-label="2.3	邻接矩阵和邻接表的比较">2.3 邻接矩阵和邻接表的比较</a></li><li><a href=#24%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84%e9%82%bb%e6%8e%a5%e5%a4%9a%e9%87%8d%e8%a1%a8 aria-label="2.4	无向图的邻接多重表">2.4 无向图的邻接多重表</a></li><li><a href=#25%e6%9c%89%e5%90%91%e8%a1%a8%e7%9a%84%e5%8d%81%e5%ad%97%e9%93%be%e8%a1%a8 aria-label="2.5	有向表的十字链表">2.5 有向表的十字链表</a></li></ul></li><li><a href=#3%e5%9b%be%e7%9a%84%e9%81%8d%e5%8e%86%e4%b8%8e%e8%bf%9e%e9%80%9a%e6%80%a7 aria-label="3.	图的遍历与连通性">3. 图的遍历与连通性</a><ul><li><a href=#31%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2 aria-label="3.1	深度优先搜索">3.1 深度优先搜索</a></li><li><a href=#32%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2 aria-label="3.2	广度优先搜索">3.2 广度优先搜索</a></li><li><a href=#33%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f aria-label="3.3	连通分量">3.3 连通分量</a></li></ul></li><li><a href=#4%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91 aria-label="4.	最小生成树">4. 最小生成树</a><ul><li><a href=#41kruskal%e7%ae%97%e6%b3%95 aria-label="4.1	Kruskal算法">4.1 Kruskal算法</a><ul><li><a href=#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3 aria-label=（1）算法思想>（1）<strong>算法思想</strong></a></li><li><a href=#2%e4%b8%bb%e8%a6%81%e9%97%ae%e9%a2%98 aria-label=（2）主要问题><strong>（2）主要问题</strong></a></li><li><a href=#3%e4%b8%bb%e8%a6%81%e6%ad%a5%e9%aa%a4 aria-label=（3）主要步骤><strong>（3）主要步骤</strong></a></li><li><a href=#4%e4%b8%be%e4%be%8b aria-label=（4）举例><strong>（4）举例</strong></a></li></ul></li><li><a href=#42prim%e7%ae%97%e6%b3%95 aria-label="4.2	Prim算法">4.2 Prim算法</a><ul><li><a href=#1%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-1 aria-label=（1）算法思想><strong>（1）算法思想</strong></a></li><li><a href=#2%e4%b8%bb%e8%a6%81%e9%97%ae%e9%a2%98-1 aria-label=（2）主要问题><strong>（2）主要问题</strong></a></li><li><a href=#3%e4%b8%bb%e8%a6%81%e6%ad%a5%e9%aa%a4-1 aria-label=（3）主要步骤><strong>（3）主要步骤</strong></a></li></ul></li><li><a href=#43prim%e4%b8%8ekruskal%e7%ae%97%e6%b3%95%e7%9a%84%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83 aria-label="4.3	Prim与Kruskal算法的性能比较">4.3 Prim与Kruskal算法的性能比较</a><ul><li><a href=#1-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e6%80%a7 aria-label="(1) 时间复杂性:"><strong>(1) 时间复杂性:</strong></a></li><li><a href=#2-%e9%80%82%e7%94%a8%e5%9c%ba%e5%90%88 aria-label="(2)	适用场合:"><strong>(2) 适用场合:</strong></a></li></ul></li></ul></li><li><a href=#5%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84 aria-label="5.	最短路径">5. 最短路径</a><ul><li><a href=#51dijkstra%e7%ae%97%e6%b3%95 aria-label="5.1	Dijkstra算法">5.1 Dijkstra算法</a><ul><li><a href=#1%e7%ae%97%e6%b3%95%e5%ae%9a%e4%b9%89 aria-label=（1）算法定义><strong>（1）算法定义</strong></a></li><li><a href=#2%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3 aria-label=（2）算法思想><strong>（2）算法思想</strong></a></li><li><a href=#3%e7%ae%97%e6%b3%95%e5%9b%be%e8%a7%a3 aria-label=（3）算法图解>（3）算法图解</a></li><li><a href=#4c%e4%bb%a3%e7%a0%81 aria-label=（4）C++代码>（4）C++代码</a></li></ul></li><li><a href=#52bellnam-ford%e7%ae%97%e6%b3%95 aria-label="5.2	Bellnam-Ford算法">5.2 Bellnam-Ford算法</a><ul><li><a href=#%e7%ae%97%e6%b3%95%e5%9b%be%e8%a7%a3 aria-label=算法图解>算法图解</a></li><li><a href=#c%e4%bb%a3%e7%a0%81 aria-label=C++代码><strong>C++代码</strong></a></li></ul></li><li><a href=#53floyd%e7%ae%97%e6%b3%95 aria-label="5.3	Floyd算法">5.3 Floyd算法</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3 aria-label=基本思想><strong>基本思想</strong></a></li><li><a href=#%e6%b1%82%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e6%ad%a5%e9%aa%a4 aria-label=求最短路径步骤><strong>求最短路径步骤</strong></a></li><li><a href=#c%e4%bb%a3%e7%a0%81-1 aria-label=C++代码><strong>C++代码</strong></a></li></ul></li></ul></li><li><a href=#6%e6%b4%bb%e5%8a%a8%e7%bd%91%e7%bb%9c-active-network aria-label="6.	活动网络, Active Network">6. 活动网络, Active Network</a><ul><li><a href=#61%e7%94%a8%e9%a1%b6%e7%82%b9%e8%a1%a8%e7%a4%ba%e7%9a%84%e6%b4%bb%e5%8a%a8%e7%bd%91%e7%bb%9c-aovactivity-on-vertex aria-label="6.1	用顶点表示的活动网络 AOV，Activity on Vertex">6.1 用顶点表示的活动网络 AOV，Activity on Vertex</a></li><li><a href=#62-%e8%be%b9%e8%a1%a8%e7%a4%ba%e7%9a%84%e6%b4%bb%e5%8a%a8%e7%bd%91%e7%bb%9caoe-activity-on-edges aria-label="6.2 边表示的活动网络，AOE, Activity on Edges">6.2 边表示的活动网络，AOE, Activity on Edges</a></li></ul></li></ul></li><li><a href=#%e4%ba%94%e6%9f%a5%e6%89%be aria-label=五、查找>五、查找</a><ul><li><a href=#51%e9%9d%99%e6%80%81%e6%9f%a5%e6%89%be aria-label="5.1	静态查找">5.1 静态查找</a><ul><li><a href=#511%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be aria-label="5.1.1	顺序查找">5.1.1 顺序查找</a></li><li><a href=#512%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e6%8a%98%e5%8d%8a%e6%9f%a5%e6%89%be aria-label="5.1.2	二分查找/折半查找">5.1.2 二分查找/折半查找</a><ul><li><a href=#%e7%ae%97%e6%b3%95%e8%a6%81%e6%b1%82 aria-label=算法要求>算法要求</a></li><li><a href=#%e7%ae%97%e6%b3%95%e5%8a%a8%e5%9b%be%e6%bc%94%e7%a4%ba aria-label=算法动图演示><strong>算法动图演示</strong></a></li><li><a href=#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0 aria-label=算法实现>算法实现</a></li><li><a href=#%e6%8b%93%e5%b1%95%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%9f%a5%e6%89%be%e5%92%8c%e6%8f%92%e5%80%bc%e6%9f%a5%e6%89%be aria-label=拓展：斐波那契查找和插值查找>拓展：斐波那契查找和插值查找</a><ul><li><a href=#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%9f%a5%e6%89%be aria-label=斐波那契查找>斐波那契查找</a></li><li><a href=#%e6%8f%92%e5%80%bc%e6%9f%a5%e6%89%be aria-label=插值查找>插值查找</a></li></ul></li><li><a href=#%e5%b9%b3%e5%9d%87%e6%9f%a5%e6%89%be%e9%95%bf%e5%ba%a6 aria-label=平均查找长度>平均查找长度</a></li></ul></li></ul></li><li><a href=#52%e5%8a%a8%e6%80%81%e6%9f%a5%e6%89%be aria-label="5.2	动态查找">5.2 动态查找</a><ul><li><a href=#521%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91 aria-label="5.2.1	二叉排序树">5.2.1 二叉排序树</a><ul><li><a href=#1%e5%ae%9a%e4%b9%89 aria-label="1	定义">1 定义</a></li><li><a href=#2%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e4%b8%8a%e7%9a%84%e6%9f%a5%e6%89%be aria-label="2	二叉排序树上的查找">2 二叉排序树上的查找</a></li><li><a href=#3%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e4%b8%8a%e7%9a%84%e6%8f%92%e5%85%a5 aria-label="3	二叉排序树上的插入">3 二叉排序树上的插入</a></li><li><a href=#4%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91%e4%b8%8a%e7%9a%84%e5%88%a0%e9%99%a4 aria-label="4	二叉排序树上的删除">4 二叉排序树上的删除</a></li></ul></li><li><a href=#522%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="5.2.2	平衡二叉树">5.2.2 平衡二叉树</a><ul><li><a href=#1%e5%ae%9a%e4%b9%89-1 aria-label="1	定义">1 <strong>定义</strong></a></li><li><a href=#2%e5%b9%b3%e8%a1%a1%e6%97%8b%e8%bd%ac aria-label="2	平衡旋转"><strong>2 平衡旋转</strong></a><ul><li><a href=#21ll%e5%b9%b3%e8%a1%a1%e6%97%8b%e8%bd%ac%e5%8f%b3%e5%8d%95%e6%97%8b%e8%bd%ac aria-label="2.1	LL平衡旋转—右单旋转">2.1 LL平衡旋转—右单旋转</a></li><li><a href=#22rr%e5%b9%b3%e8%a1%a1%e6%97%8b%e8%bd%ac%e5%b7%a6%e5%8d%95%e6%97%8b%e8%bd%ac aria-label="2.2	RR平衡旋转—左单旋转">2.2 RR平衡旋转—左单旋转</a></li><li><a href=#23lr%e5%b9%b3%e8%a1%a1%e6%97%8b%e8%bd%ac%e5%85%88%e5%b7%a6%e5%90%8e%e5%8f%b3%e5%8f%8c%e6%97%8b%e8%bd%ac aria-label="2.3	LR平衡旋转—先左后右双旋转">2.3 LR平衡旋转—先左后右双旋转</a></li><li><a href=#24rl%e5%b9%b3%e8%a1%a1%e6%97%8b%e8%bd%ac%e5%85%88%e5%8f%b3%e5%90%8e%e5%b7%a6%e5%8f%8c%e6%97%8b%e8%bd%ac aria-label="2.4	RL平衡旋转—先右后左双旋转">2.4 RL平衡旋转—先右后左双旋转</a></li></ul></li><li><a href=#3%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%8f%92%e5%85%a5 aria-label="3	平衡二叉树的插入"><strong>3 平衡二叉树的插入</strong></a></li><li><a href=#4%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%88%a0%e9%99%a4 aria-label="4	平衡二叉树的删除"><strong>4 平衡二叉树的删除</strong></a></li></ul></li><li><a href=#523b-%e6%a0%91 aria-label="5.2.3	B-树">5.2.3 B-树</a><ul><li><a href=#1%e5%8a%a8%e6%80%81%e7%9a%84m%e8%b7%af%e6%9f%a5%e6%89%be%e6%a0%91 aria-label="1	动态的m路查找树">1 动态的m路查找树</a></li><li><a href=#2b-%e6%a0%91 aria-label="2	B-树">2 B-树</a><ul><li><a href=#%e5%ae%9a%e4%b9%89 aria-label=定义>定义</a></li><li><a href=#b-%e6%a0%91%e7%9a%84%e6%8f%92%e5%85%a5 aria-label=B-树的插入>B-树的插入</a></li><li><a href=#b-%e6%a0%91%e7%9a%84%e5%88%a0%e9%99%a4 aria-label=B-树的删除>B-树的删除</a></li></ul></li><li><a href=#3b%e6%a0%91 aria-label="3	B+树">3 B+树</a></li></ul></li><li><a href=#53%e6%95%a3%e5%88%97%e8%a1%a8 aria-label="5.3	散列表">5.3 散列表</a><ul><li><a href=#1%e6%95%a3%e5%88%97%e8%a1%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="1	散列表的基本概念">1 散列表的基本概念</a></li><li><a href=#2%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0 aria-label="2	散列函数">2 散列函数</a></li><li><a href=#3%e5%a4%84%e7%90%86%e5%86%b2%e7%aa%81%e7%9a%84%e6%96%b9%e6%b3%95 aria-label="3	处理冲突的方法">3 处理冲突的方法</a><ul><li><a href=#31%e9%97%ad%e6%95%a3%e5%88%97%e5%bc%80%e6%94%be%e5%9c%b0%e5%9d%80%e6%b3%95 aria-label="3.1	闭散列——开放地址法">3.1 闭散列——开放地址法</a></li><li><a href=#32%e5%bc%80%e6%95%a3%e5%88%97%e9%93%be%e5%9c%b0%e5%9d%80%e6%b3%95 aria-label="3.2	开散列——链地址法">3.2 开散列——链地址法</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#%e5%85%ad%e6%8e%92%e5%ba%8f aria-label=六、排序>六、排序</a><ul><li><a href=#%e5%90%84%e4%b8%aa%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83 aria-label=各个排序算法的性能比较><strong>各个排序算法的性能比较</strong></a></li><li><a href=#%e4%ba%a4%e6%8d%a2%e6%8e%92%e5%ba%8f aria-label=交换排序>交换排序</a><ul><li><a href=#1%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f aria-label="1	冒泡排序">1 冒泡排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95 aria-label=排序算法>排序算法</a></li></ul></li><li><a href=#2%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f aria-label="2	快速排序">2 快速排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-1 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-1 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-1 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-1 aria-label=排序算法>排序算法</a></li></ul></li></ul></li><li><a href=#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f aria-label=插入排序>插入排序</a><ul><li><a href=#3%e7%9b%b4%e6%8e%a5%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f aria-label="3	直接插入排序">3 直接插入排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-2 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-2 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-2 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-2 aria-label=排序算法>排序算法</a></li><li><a href=#%e6%94%b9%e8%bf%9b%e6%8a%98%e5%8d%8a%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f aria-label="改进：	折半插入排序">改进： 折半插入排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-3 aria-label=排序思想>排序思想</a></li></ul></li></ul></li><li><a href=#4%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f aria-label="4	希尔排序">4 希尔排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-3 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-4 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-3 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-3 aria-label=排序算法>排序算法</a></li></ul></li></ul></li><li><a href=#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f aria-label=选择排序>选择排序</a><ul><li><a href=#5%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f aria-label="5	简单选择排序">5 简单选择排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-4 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-5 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-4 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-4 aria-label=排序算法>排序算法</a></li></ul></li><li><a href=#6%e9%94%a6%e6%a0%87%e8%b5%9b%e6%8e%92%e5%ba%8f aria-label="6	锦标赛排序">6 锦标赛排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-5 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-6 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-5 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-5 aria-label=排序算法>排序算法</a></li></ul></li><li><a href=#7%e5%a0%86%e6%8e%92%e5%ba%8f aria-label="7	堆排序">7 堆排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-6 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-7 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-6 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-6 aria-label=排序算法>排序算法</a></li></ul></li></ul></li><li><a href=#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f aria-label=归并排序>归并排序</a><ul><li><a href=#8%e4%b8%a4%e8%b7%af%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f aria-label="8	两路归并排序">8 两路归并排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-7 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-8 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-7 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-7 aria-label=排序算法>排序算法</a></li></ul></li></ul></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f aria-label=基数排序>基数排序</a><ul><li><a href=#9%e9%93%be%e5%bc%8f%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f aria-label="9	链式基数排序">9 链式基数排序</a><ul><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9-8 aria-label=排序性能和优缺点>排序性能和优缺点</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e6%80%9d%e6%83%b3-9 aria-label=排序思想>排序思想</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e8%bf%87%e7%a8%8b-8 aria-label=排序过程>排序过程</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95-8 aria-label=排序算法>排序算法</a></li></ul></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=一绪论>一、绪论<a hidden class=anchor aria-hidden=true href=#一绪论>#</a></h1><p><strong>数据</strong>（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。</p><p>数据的<strong>最小单位</strong>的是<strong>数据项</strong>；</p><p>数据的<strong>基本单位</strong>是<strong>数据元素</strong>，一个数据元素可由若干个数据项组成。</p><p>数据结构分为两大类：<strong>线性结构</strong>和<strong>非线性结构</strong></p><p>两类结构通常分为四类基本结构：</p><p>1）<strong>集合</strong>：结构中的数据元素之间同属于一个集合，此外没有其他关系；</p><p>2）<strong>线性结构</strong>：结构中的数据元素之间存在一种线性关系，一对一的关系；</p><p>3）<strong>树形结构</strong>：一对多的关系；</p><p>4）<strong>图形结构</strong>或网状结构：多对多的关系。</p><p>根据视点的不同又可分为：逻辑结构和物理结构：</p><p><strong>逻辑结构</strong>：面向问题，描述数据元素之间的逻辑关系；</p><p><strong>物理结构</strong>：又称存储结构，面向计算机，是数据结构在计算机中的表示（映像）</p><p>算法的<strong>特性</strong>：<strong>输入性、输出性、确定性、有穷性、有效性（可行性</strong>）</p><p>算法的<strong>标准</strong>：<strong>正确性</strong>（满足所要求界的问题的需求，最重要最基本）、<strong>可用性</strong>（便于用户使用，良好的界面、完备的用户文档）、<strong>可读性</strong>（易于理解）、<strong>效率</strong>（存储单元的开销和运行时间的耗费）、<strong>健壮性</strong>（对于非法数据的处理）</p><p>算法复杂度：（渐进）时间复杂度和空间复杂度</p><h1 id=二线性结构>二、线性结构<a hidden class=anchor aria-hidden=true href=#二线性结构>#</a></h1><h2 id=1线性表>1、线性表<a hidden class=anchor aria-hidden=true href=#1线性表>#</a></h2><h3 id=11顺序表示顺序表>1.1 顺序表示：顺序表<a hidden class=anchor aria-hidden=true href=#11顺序表示顺序表>#</a></h3><p>用顺序结构存储的线性表为顺序表（sequential list）。</p><p>顺序表一般用数组进行存储</p><p>类模板定义：T* elems，int length，int maxLength</p><h3 id=12链表表示>1.2 链表表示<a hidden class=anchor aria-hidden=true href=#12链表表示>#</a></h3><h4 id=1单链表>1) 单链表<a hidden class=anchor aria-hidden=true href=#1单链表>#</a></h4><p>分为带头结点和不带头结点的单链表；</p><p>带头结点的单链表相对不带头结点的单链表在涉及会更改头节点的任务时，操作会更加统一。</p><p>类模板定义：</p><p>（结点）T data，Node* next</p><p>（单链表）Node* head，int length</p><h4 id=2双向循环链表>2) 双向循环链表<a hidden class=anchor aria-hidden=true href=#2双向循环链表>#</a></h4><p>类模板定义：</p><p>（结点）T data，Node* prior，Node* next</p><p>（双向循环链表）Node* head，int length</p><p>*带头结点的双向循环列表只有一个元素结点的条件：<code>head->next!=head && head->next->next==head</code></p><h4 id=3静态链表>3) 静态链表<a hidden class=anchor aria-hidden=true href=#3静态链表>#</a></h4><p>利用数组来模拟存储空间实现链表。</p><p>类模板定义：</p><p>（结点）T data，Node* next</p><p>（静态链表）Node* head，Node* avail</p><p>设数组a放置了一个静态链表，当链表未使用的时候，其中所有的结点都是形成了一个链表，用avail进行管理，代表未使用的结点。</p><p>当进行插入操作的时候，就从avail中取出一个头节点，进行赋值，再放入head链表之中。</p><p>在完成每一步操作之后，记得要将next域中更改</p><p><strong>插入元素操作</strong>：</p><pre tabindex=0><code>i=avail;
avail=a[avail].next;
a[i].next=a[head],next;
a[head]。next=i;
</code></pre><p>当需要释放由j所指向的结点时，只需要把结点j放到avail表的最前端，并让avail指向它即可。</p><p>所设j所指结点的前一个结点的指针是p，则</p><p><strong>删除元素操作</strong>：</p><pre tabindex=0><code>a[p].next=a[j],next;
a[j].next=avail;
avail=j;
</code></pre><h2 id=2栈和队列>2、栈和队列<a hidden class=anchor aria-hidden=true href=#2栈和队列>#</a></h2><h3 id=21栈>2.1 栈<a hidden class=anchor aria-hidden=true href=#21栈>#</a></h3><p>特点：先进后出 FILO</p><h4 id=1顺序栈seqstack>1) 顺序栈（SeqStack）<a hidden class=anchor aria-hidden=true href=#1顺序栈seqstack>#</a></h4><p>类模板定义：</p><p>int top（栈顶指针），int maxsize（栈最大容量），T* elems（元素存储空间）</p><p>初始化时top=-1</p><p>入栈操作push：<code>elems[++top] = e</code></p><p>出栈操作pop：<code>e = elems[top--];</code></p><p>取栈顶元素：<code>e = elems[top];</code></p><p>两个顺序栈共享一个数组空间：两个栈的栈底在数组两端，只有当两个栈的栈顶指针相遇时，才会出现栈满溢出</p><h4 id=2链式栈linkstack>2) 链式栈（LinkStack）<a hidden class=anchor aria-hidden=true href=#2链式栈linkstack>#</a></h4><p>与顺序栈相比，链式栈对于同时使用多个栈的情况下可以共享存储。</p><p>类模板定义：</p><p>（链栈）Node* top</p><p>用单链表表示的栈，栈顶在head，栈底在链表的尾部</p><h4 id=3应用表达式求值>3) 应用：表达式求值<a hidden class=anchor aria-hidden=true href=#3应用表达式求值>#</a></h4><ol><li><strong>后缀表达式的计算</strong></li></ol><p>​ 方法：栈放操作数，遇到数字入栈，遇到操作符就将对应数目的操作符出栈并进行运算。</p><p>​ 判断出错：如果操作数栈中的操作数数目不到两个，或者计算结束时栈中有多个操作数时候说明后缀式出错。</p><ol start=2><li><strong>中缀表达式转为后缀表达式（用栈实现）</strong></li></ol><p>​ 方法：栈放操作符</p><ol start=2><li><strong>中缀表达式转为后缀表达式的简单方法</strong></li></ol><p>​ 1.将中缀表达式中的每一步操作加上括号</p><p>​ 2.每个操作符一道对应该操作的右边括号外</p><p>​ 3.删除所有括号</p><p>​ 验证方法：用中缀表达式构建二叉树（注意要按照顺序来构建），用后序遍历</p><h3 id=22队列>2.2 队列<a hidden class=anchor aria-hidden=true href=#22队列>#</a></h3><p>特点：先进先出 FIFO</p><h4 id=1顺序循环队列>1) 顺序循环队列<a hidden class=anchor aria-hidden=true href=#1顺序循环队列>#</a></h4><p>队头：允许出队；队尾：允许入队</p><p>类模板定义：</p><p>（队头指针）int front，（队尾指针）int rear</p><p>int maxsize（最大容量），T* elems（元素存储空间）</p><p>初始化队列为空，front=rear=0；（教材上的定义是这样写的，具体在做题的时候要看是否符合题目的要求）</p><p><strong>当队头指针front或者队尾指针rear达到maxsize-1时，就要进行求模操作。</strong></p><p>由于队列空和队列满的状态都是rear==front，所以用少一个存储空间的方法进行解决：</p><p><strong>循环队列满的条件</strong>为：<code>(rear+1)%maxsize==front</code></p><p><strong>循环队列空的条件</strong>为：<code>front==rear</code></p><p><strong>入队</strong>操作：<code>rear=(rear+1)%maxsize</code>，要先判断队列是不是满了</p><p><strong>出队</strong>操作：<code>front=(fornt+1)%maxsize</code>，要先判断队列是不是已经空了</p><h4 id=2链式队列>2) 链式队列<a hidden class=anchor aria-hidden=true href=#2链式队列>#</a></h4><p>用单链表表示的链队列适合数据元素变化较大的情形。</p><p>类模板定义：（带头结点）</p><p>Node* front（指向队列的头节点），rear（指向队尾结点）</p><h4 id=3应用车厢调度>3) 应用：车厢调度<a hidden class=anchor aria-hidden=true href=#3应用车厢调度>#</a></h4><h3 id=23递归>2.3 递归<a hidden class=anchor aria-hidden=true href=#23递归>#</a></h3><p>尾递归</p><p>单向递归（循环）</p><p>用栈模拟递归</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>F</span><span class=p>(</span><span class=n>m</span><span class=p>,</span><span class=n>n</span><span class=p>)</span><span class=o>=</span><span class=n>m</span><span class=o>+</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=o>*</span><span class=n>n</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=栈和队列的应用>栈和队列的应用：<a hidden class=anchor aria-hidden=true href=#栈和队列的应用>#</a></h3><p>数值转换，括号匹配，回文，车厢调度</p><p>表达式求值：中缀、后缀、前缀表达式（二叉树）先序中序后序遍历</p><p>后缀表达式求值（栈放操作数）</p><p>中缀转后缀（栈放操作符）</p><h2 id=3串数组广义表>3、串、数组、广义表<a hidden class=anchor aria-hidden=true href=#3串数组广义表>#</a></h2><h3 id=1字符串的模式匹配算法>1、字符串的模式匹配算法<a hidden class=anchor aria-hidden=true href=#1字符串的模式匹配算法>#</a></h3><p>定义：子串定位</p><h4 id=1brute-force算法>1) Brute-Force算法<a hidden class=anchor aria-hidden=true href=#1brute-force算法>#</a></h4><p><strong>BF算法基本思想</strong>：从一个位置开始向后面开始比较，当匹配失败的时候回到刚开始比较的位置的下一个位置重新开始比较。</p><p>i表示ob中的下标，j表示模式串pat中的下标</p><p>相等：<code>i++;j++;</code>继续比较</p><p>不相等：<code>i=i-j+1;j=0;</code>回到原来的地方，再往前进一个位置</p><p>最坏情况下的运行时间O(m*n)，简单但是效率低下，带回溯</p><h4 id=2kmp算法>2) KMP算法<a hidden class=anchor aria-hidden=true href=#2kmp算法>#</a></h4><p><strong>改进</strong>：消除了BF算法中主串下标i在对应字符中比较不相等需要回退的现象</p><p><strong>真子串的概念</strong>：</p><p>在字符串“t0，t1，&mldr;.，tn-1”中最长的相等前缀和后缀称为该字符串的真子串，也就是说在字串“t0，t1，&mldr;，tn-1”中存在一个最大的k(0&lt;k&lt;n),使得“t0,t1…tk-1” = “tn-k，tn-k+1，&mldr;，tn-1”，则“t0，t1，…，tk-1”就称为t0，t1，&mldr;，tn-1”的真子串。<em><strong>需要注意的是真子串的前缀和后缀可以有重叠部分，但不能完全重叠。</strong></em></p><p><strong>KMP算法基本思路</strong>：记录<strong>模式串</strong>每个位置前面的真子串的长度是多少，当模式串和主串在匹配的时候，遇到匹配到模式串中间部分然后不相等的情况，主串的下标i不用回溯，而模式串的下标j直接变为该位置的真子串的长度，继续比较当前的i和改变后的j。当失效函数返回-1时，表示模式串的第一个与主串中的当前对象都不相等<code>i++;j=0;</code></p><p><strong>失效函数</strong>：用函数f[j]表示模式串中tj之前的真子串的长度。即：</p><p>失效函数的求法：</p><p>根据f[j]求f[j+1]，模式串pat，设f[j]=k:</p><p>(1)pat[ j ] == pat[ k ] => f[ j+1 ] = f[ j ] + 1 = k + 1;</p><p>(2))pat[ j ] != pat[ k ] => 设f[ k ] = k&rsquo;，pat[ j ] == pat[ k&rsquo; ] => f[ k ] + 1 = k&rsquo; + 1;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//失效函数的求法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>GetFailure</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>pat</span><span class=p>,</span> <span class=kt>int</span> <span class=n>f</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>k</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>               
</span></span><span class=line><span class=cl>	<span class=n>f</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>				<span class=c1>// 初始f[0]的值为-1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>pat</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>==</span> <span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>			<span class=n>f</span><span class=p>[</span><span class=o>++</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=o>++</span><span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>          	  	<span class=c1>// pat[k]与pat[j]不匹配 
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>k</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>		<span class=c1>// 寻求新的匹配字符
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>改进：先执行完普通失效函数之后，再执行下面这个函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>GetFailurePlus</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>pat</span><span class=p>,</span> <span class=kt>int</span> <span class=n>f</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span> <span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>!=-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>pat</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>==</span> <span class=n>pat</span><span class=p>[</span><span class=n>f</span><span class=p>[</span><span class=n>k</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>			<span class=n>f</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>f</span><span class=p>[</span><span class=n>k</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>普通的KMP函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>KMP_find</span><span class=p>(</span><span class=k>const</span> <span class=n>String</span> <span class=o>&amp;</span><span class=n>ob</span><span class=p>,</span> <span class=k>const</span> <span class=n>String</span> <span class=o>&amp;</span><span class=n>pat</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=kt>int</span> <span class=o>*</span><span class=n>f</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>pat</span><span class=p>.</span><span class=n>GetLength</span><span class=p>()];</span> 
</span></span><span class=line><span class=cl>       <span class=n>GetFailure</span><span class=p>(</span><span class=n>pat</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>	<span class=c1>// 求模式串pat的f数组的元素值
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>p</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>			
</span></span><span class=line><span class=cl>       <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>ob</span><span class=p>.</span><span class=n>GetLength</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>pat</span><span class=p>.</span><span class=n>GetLength</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>pat</span><span class=p>.</span><span class=n>GetLength</span><span class=p>()</span> <span class=o>-</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>ob</span><span class=p>.</span><span class=n>GetLength</span><span class=p>()</span> <span class=o>-</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>ob</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>  <span class=p>{</span>   
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>	
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>	  
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>j</span><span class=p>];</span><span class=c1>// 寻找新的模式串pat的匹配字符位置
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=p>[]</span><span class=n>f</span><span class=p>;</span>		
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>pat</span><span class=p>.</span><span class=n>GetLength</span><span class=p>())</span>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>   <span class=c1>// 匹配失败
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span>        <span class=k>return</span> <span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>;</span>			    <span class=c1>// 匹配成功
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>KMP改进后的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>KMP_find_PLUS</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>ob</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>pat</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span><span class=c1>//从p位置开始查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//失效函数求解
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span><span class=o>*</span><span class=n>f</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()];</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>setw</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span> <span class=o>&lt;&lt;</span><span class=s>&#34;原来的失效函数值：&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>flush</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>GetFailure</span><span class=p>(</span><span class=n>pat</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>setw</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;改进后的失效函数值：&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>flush</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>GetFailurePlus</span><span class=p>(</span><span class=n>pat</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>p</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//******注意要把unsigned int（.length()方法的返回值）强制转换为int，不然会出现负数大于正数，导致判断出错********
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>ob</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>-</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>ob</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>-</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>//当i没有到终点，j没有到终点，模式串剩余长度小于主串的剩余长度
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>ob</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span> <span class=n>j</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span><span class=p>[]</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>     <span class=c1>//注意要把unsigned int（.length()方法的返回值）强制转换为int，不然会出现负数大于正数，导致判断出错
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>())</span><span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=k>return</span> <span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>;</span><span class=c1>//返回找到的起点
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=2数组>2、数组<a hidden class=anchor aria-hidden=true href=#2数组>#</a></h3><p>二维数组：行序存储和列序存储</p><p>高维数组：行序存储和列序存储</p><p>把它当作几个面的叠加3*4*5，当成三个4*5的面</p><h3 id=3稀疏矩阵>3、稀疏矩阵<a hidden class=anchor aria-hidden=true href=#3稀疏矩阵>#</a></h3><h4 id=1-顺序结构存储三元组顺序表>1、 顺序结构存储：三元组顺序表<a hidden class=anchor aria-hidden=true href=#1-顺序结构存储三元组顺序表>#</a></h4><p>对于稀疏矩阵中的非零元素可以用：&lt;row, col, value>进行描述他的位置</p><h5 id=1三元组表转置函数的实现>1) 三元组表转置函数的实现<a hidden class=anchor aria-hidden=true href=#1三元组表转置函数的实现>#</a></h5><p><strong>简单转置算法</strong>：将三元组顺序表中的各个三元素的row和col内容互换，然后按照新的row中的行号从小到大进行排放。</p><p>算法思路：把原矩阵的第i列元素通过遍历找出来，放到新矩阵的第i行，直到i遍历完cols</p><p>时间复杂度为：O(clos*num)</p><p><strong>快速转置算法</strong>：按照原三元组的次序进行转置，并将转置后的三元组放置到b中的恰当位置。</p><p>时间复杂度为：O(num)</p><h5 id=2三元组表的绘制>2) 三元组表的绘制<a hidden class=anchor aria-hidden=true href=#2三元组表的绘制>#</a></h5><h4 id=2链式结构存储十字链表>2、链式结构存储：十字链表<a hidden class=anchor aria-hidden=true href=#2链式结构存储十字链表>#</a></h4><p>如果矩阵中的非零元素的位置和个数经常变动，采用链式结构进行存储稀疏矩阵比较方便。</p><h4 id=3其他特殊矩阵>3、其他特殊矩阵<a hidden class=anchor aria-hidden=true href=#3其他特殊矩阵>#</a></h4><h5 id=1对称矩阵-aij--aji>1、对称矩阵 Aij = Aji<a hidden class=anchor aria-hidden=true href=#1对称矩阵-aij--aji>#</a></h5><p>矩阵的压缩存储，存储对称矩阵的上三角或者下三角，按行序存储或者按列序存储</p><p>用一维数组进行存放，注意i和j的范围，确定题目给出的i和j是在上三角还是下三角区域，按行存储还是按列存储的</p><p><code>k=i*(i-1)/2+j-1(i>=j)</code>(按行存储下三角、行列存储上三角)</p><p><code>k=j*(j-1)/2+i-1(i&lt;j)</code>(按行存储下三角、行列存储上三角)</p><h5 id=2三对角矩阵>2、三对角矩阵<a hidden class=anchor aria-hidden=true href=#2三对角矩阵>#</a></h5><p>用一维数组B[]，Bij=B[k]，则<code>k=2i+j-3</code></p><h3 id=4广义表>4、广义表<a hidden class=anchor aria-hidden=true href=#4广义表>#</a></h3><h4 id=1广义表的定义>1、广义表的定义<a hidden class=anchor aria-hidden=true href=#1广义表的定义>#</a></h4><ol><li><p>广义表的元素可以是数据元素，也可以是一个表（称为子表）</p></li><li><p>概念：表头、表尾、深度、长度</p></li></ol><p>​ LS=（k，（a，m，n），b，c，（x，y））</p><p>​ <strong>表头</strong>：k，是一个元素或者子表，是原本的元素</p><p>​ <strong>表尾</strong>：一定是个表，由 广义表中除了表头的元素 构成的一个表，在这里指的是（（a，m，n），b，c，（x，y））</p><p>​ <strong>深度</strong>：广义表的括号重数，在这里为2；</p><p>​ <strong>长度</strong>：广义表最高一层的元素个数，在这里为5</p><ol start=3><li>广义表通常采取<strong>链式存储</strong>结构，简称广义链表</li></ol><p>​ 广义链表中的结点由三个域构成：</p><p>​ &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p><p>​ <strong>tag域 ref/data/hlink域 tlink域</strong></p><p>​ tag=HEAD(0) 广义表被引用次数* 指向表头的指针</p><p>​ tag=ATOM(1) data 指向同层下一个的指针</p><p>​ tag=LIST(2) 指向子表的指针 指向同层下一个的指针</p><p>​ &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p><p>​ *ref：包括了头指针的引用和其他广义表的引用</p><p>​ 广义链表类的只有一个数据成员：Node* head</p><ol start=4><li>广义表的中的所有表，不论哪一层，都有一个表头结点</li></ol><h4 id=2广义表的绘制>2、广义表的绘制<a hidden class=anchor aria-hidden=true href=#2广义表的绘制>#</a></h4><h1 id=项目调试三元组表>【项目调试】三元组表<a hidden class=anchor aria-hidden=true href=#项目调试三元组表>#</a></h1><h2 id=1lnk2019lnk2005>1、LNK2019,LNK2005<a hidden class=anchor aria-hidden=true href=#1lnk2019lnk2005>#</a></h2><p>在模板函数的在头文件的定义方面，还是应该遵守模板函数的函数体和函数声明都放在头文件里</p><p>对于出现LNK2005的错误，此次出现的问题是重载运算符函数的时候，函数体虽然是在头文件里面，但是没有在函数类体内；</p><p>因为成员函数体有自动生成的inline内联标签，而这两个重载的运算符函数都是友元函数的形式，故应当写在函数类体内</p><h2 id=2对于有很多if-else分支的结构>2、对于有很多if-else分支的结构<a hidden class=anchor aria-hidden=true href=#2对于有很多if-else分支的结构>#</a></h2><p>应当把情况都考虑清楚，想不清楚的时候可以画一个流程图出来，帮助理清思路。</p><h2 id=3判断一个串有没有遍历完>3、判断一个串有没有遍历完<a hidden class=anchor aria-hidden=true href=#3判断一个串有没有遍历完>#</a></h2><p>可以设置flag，当最后一次进入，在执行目标操作之前，进行判断：当此次是最后一次，flag就为true</p><h1 id=三树和二叉树>三、树和二叉树<a hidden class=anchor aria-hidden=true href=#三树和二叉树>#</a></h1><h2 id=1二叉树的性质>1、二叉树的性质<a hidden class=anchor aria-hidden=true href=#1二叉树的性质>#</a></h2><p>1、有n(n>0)个结点的二叉树的分支数为n-1</p><p>2、若二叉树的高度为h（h≥0），则该二叉树最少有h个结点，最多有2h-1个结点</p><p>3、含有n个结点的二叉树的高度最大值为n，最小值为log2(n+1) 。</p><p>4、具有 n 个结点的完全二叉树的高度为log2(n+1) 。</p><p>5、如果将一棵有n个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号0、1、2、…、n-1。则有以下关系：
（1）若i＝0，则 i 无双亲，若i＞0，则 i 的双亲为i/2-1；
（2）若2<em>i+1&lt;n，则 i 的左孩子为2</em>i+1；
（3）若2<em>i+2&lt;n，则 i 的右孩子为2</em>i+2；
（4）若i为偶数，且i≥1，则 i 是其双亲的右孩子，且其有编号为i-1左兄弟；
（5）若i为奇数，且i＜n-1，则 i 是其双亲的左孩子，且其有编号为i+1右兄弟。</p><h2 id=2二叉树的存储结构>2、二叉树的存储结构<a hidden class=anchor aria-hidden=true href=#2二叉树的存储结构>#</a></h2><h2 id=3遍历递归算法>3、遍历递归算法<a hidden class=anchor aria-hidden=true href=#3遍历递归算法>#</a></h2><h3 id=1前序遍历>1) 前序遍历<a hidden class=anchor aria-hidden=true href=#1前序遍历>#</a></h3><p>若二叉树为空，遍历结束。否则，</p><p>(1)访问根结点；</p><p>(2)先序遍历根结点的左子树；</p><p>(3)先序遍历根结点的右子树。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>r</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>flush</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>PreOrder</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>PreOrder</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=2中序遍历>2) 中序遍历<a hidden class=anchor aria-hidden=true href=#2中序遍历>#</a></h3><p>若二叉树为空，遍历结束。否则，</p><p>(1)中序遍历根结点的左子树；</p><p>(2)访问根结点；</p><p>(3)中序遍历根结点的右子树。</p><h3 id=3后序遍历>3) 后序遍历<a hidden class=anchor aria-hidden=true href=#3后序遍历>#</a></h3><p>若二叉树为空，遍历结束。否则，</p><p>(1)后序遍历根结点的左子树；</p><p>(2)后序遍历根结点的右子树。</p><p>(3)访问根结点；</p><h2 id=4非递归遍历算法>4、非递归遍历算法<a hidden class=anchor aria-hidden=true href=#4非递归遍历算法>#</a></h2><h4 id=中序遍历非递归算法>中序遍历非递归算法<a hidden class=anchor aria-hidden=true href=#中序遍历非递归算法>#</a></h4><p>用栈进行处理</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>NonRecurringInOrder</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>SeqStack</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=n>stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>stack</span><span class=p>.</span><span class=n>Top</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>			<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>  <span class=c1>//出栈前输出栈顶节点的值
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=5线索二叉树>5、线索二叉树<a hidden class=anchor aria-hidden=true href=#5线索二叉树>#</a></h2><h4 id=1线索二叉树的构成>1) 线索二叉树的构成<a hidden class=anchor aria-hidden=true href=#1线索二叉树的构成>#</a></h4><h4 id=2线索化二叉树>2) 线索化二叉树<a hidden class=anchor aria-hidden=true href=#2线索化二叉树>#</a></h4><h2 id=6二叉树的应用>6、二叉树的应用<a hidden class=anchor aria-hidden=true href=#6二叉树的应用>#</a></h2><h3 id=61堆>6.1 堆<a hidden class=anchor aria-hidden=true href=#61堆>#</a></h3><h4 id=1filterup和filterdown算法>1) FilterUp和FilterDown算法<a hidden class=anchor aria-hidden=true href=#1filterup和filterdown算法>#</a></h4><h3 id=62哈夫曼树>6.2 哈夫曼树<a hidden class=anchor aria-hidden=true href=#62哈夫曼树>#</a></h3><h4 id=1哈夫曼树定义>1) 哈夫曼树定义<a hidden class=anchor aria-hidden=true href=#1哈夫曼树定义>#</a></h4><h4 id=2构造哈夫曼树>2) 构造哈夫曼树<a hidden class=anchor aria-hidden=true href=#2构造哈夫曼树>#</a></h4><h4 id=3哈夫曼编码>3) 哈夫曼编码<a hidden class=anchor aria-hidden=true href=#3哈夫曼编码>#</a></h4><h2 id=7确定一棵二叉树>7、确定一棵二叉树<a hidden class=anchor aria-hidden=true href=#7确定一棵二叉树>#</a></h2><h3 id=1中序遍历前序遍历后序遍历>1、中序遍历+前序遍历/后序遍历<a hidden class=anchor aria-hidden=true href=#1中序遍历前序遍历后序遍历>#</a></h3><h4 id=11--算法思想分析>1.1 算法思想分析<a hidden class=anchor aria-hidden=true href=#11--算法思想分析>#</a></h4><p>通过上面的介绍可以看到，使用两种遍历来确定一棵二叉树的时候一定要有中序遍历。其实，这和三种遍历的自身特点是有关系的，前序遍历的顺序是先根结点，然后左子树，最后右子树，所以根结点一定在遍历结果的第一个位置上；后序遍历的顺序是，先左子树，然后右子树，最后根结点，所以根结点一定是在遍历结果的最后一个位置上。通过前序遍历和后序遍历可以确定出根结点。中序遍历的顺序是，先左子树，然后根结点，最后右子树，在遍历结果中，左右子树分别在根结点的两侧，这样就可以把左右子树区分开。可以看出，前/后序遍历和中序遍历的作用分别是：</p><p>前序遍历或后序遍历用于确定根节点；
中序遍历用于区分左右子树；
通过两种遍历，找出了根结点，并区分开了左右子树，这样就可以确定一棵二叉树了，下面以前序遍历加中序遍历为例，一步步分析如何通过前序遍历结果和中序遍历结果来恢复一棵二叉树（后续+中序遍历的方法与之类似，此文不再分析）。</p><h4 id=12-算法流程>1.2 算法流程<a hidden class=anchor aria-hidden=true href=#12-算法流程>#</a></h4><p>首先给出两个序列</p><p>前序遍历结果：A B C D E F G</p><p>中序遍历结果：C D B A F E G</p><p>第一步：确定整棵树的根结点及左右子树
根据前序遍历结果确定整棵树的根结点为A ;
根据根结点和中序遍历确定左右子树的结点集合，因为A是整棵树的根结点，中序遍历的顺序是先左子树，然后根结点，最后右子树。所以，在中序遍历结果中，A结点的左侧为左子树结点集合{C, D, B}，A结点的右侧为右子树结点集合{F, E, G}；
根据分析，可以画出分析后的结果</p><p>这样就把问题分解为{C, D, B}和{F, E, G}两个子问题，首先分析左子树</p><p>第二步：分析左子树
找出{C, D, B}在前序遍历结果中对应的子序列A (B C D) E F G，将相应子序列拿出来{B C D}，根据前序遍历的结果可知，B为这棵子树的根结点；
找出中序遍历中该子树结点集合对应的子序列(C D B) A F E G，根据中序遍历的特点可知，{C D}为根结点B的左子树，B的右子树为空；
继续画出示意图</p><p>分析{C，D}子序列</p><p>第三步：继续分析左子树的左子树（B结点的左子树）
找出{C, D}在前序遍历结果中对应的子序列A B (C D) E F G，将相应子序列拿出来{C D}，根据前序遍历的结果可知，C为这棵子树的根结点；
找出中序遍历中该子树结点集合对应的子序列(C D) B A F E G，根据中序遍历的特点可知，{D}在根结点C的右侧，为根结点C的右子树，C的左子树为空；
继续画出示意图</p><p>至此，整棵二叉树的左子树分析完毕，再用第二、三步同样的方法分析右子树{F，E，G}。</p><p>第四步：分析右子树
找出{F，E，G}在前序遍历结果中对应的子序列A B C D (E F G)，将相应子序列拿出来{F，E，G}，根据前序遍历的特点可知，E为这棵子树的根结点；
找出中序遍历中该子树结点集合对应的子序列C D B A (F E G)，根据中序遍历的特点可知，{F}为根结点E的左子树，{G}为根结点E的右子树；
画出示意图</p><p>整棵二叉树分析完毕，并恢复出唯一的一棵二叉树，我们对该二叉树示意图进行前序遍历和中序遍历，结果分别为A B C D E F G和C D B A F E G，与题目中给的前序遍历序列和中序遍历序列一致，证明我们恢复得到树是正确的。
————————————————
版权声明：本文为CSDN博主「Mindtechnist」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43471489/article/details/123967360</p><h3 id=2号法确定如果没有左右子树则使用号代替遍历时用代替null>2、#号法确定：如果没有左右子树，则使用#号代替，遍历时用#代替NULL<a hidden class=anchor aria-hidden=true href=#2号法确定如果没有左右子树则使用号代替遍历时用代替null>#</a></h3><h4 id=21-算法思想分析>2.1 算法思想分析<a hidden class=anchor aria-hidden=true href=#21-算法思想分析>#</a></h4><p>#号法确定一棵树的思想是，如果一个结点没有左右子树，也就是说如果左子树或右子树为NULL，就用一个#号代替，在遍历时给出带有#的遍历结果，既然没有左右子树就用一个#代替，那么连续两个#号前的结点一定是叶子结点，也就能确定一棵子树的结束，这样通过一种遍历的结点序列就能唯一确定一棵二叉树。</p><h4 id=22-算法流程>2.2 算法流程<a hidden class=anchor aria-hidden=true href=#22-算法流程>#</a></h4><p>首先给出一个#号法前序遍历的结点序列</p><p>前序遍历：ABC#D###EF##G##</p><p>具体步骤：
找出后面有连续两个#的结点，D F G这三个结点就是叶子结点；
根据前序遍历可知，A是整棵树的根结点；
第一个出现连续两个#的位置为D，所以D结点应该是整棵树的左子树的结束，那么左右子树就区分开了，{B C D}为左子树，{E F G}为右子树；
分析左子树{B C D}的根结点以及左子树的左右子树。先分理出左子树序列BC#D###，因为是前序遍历，B为左子树的根结点，第一个连续两个#的位置是D，所以D结点是以B为根结点的树的左子树的结束，那么剩下的一个#就是B结点的右子树。因此，B结点的左子树集合为C#D##，B结点的右子树为#；
分析子树{C#D##}，由前序遍历特点可知，C为根结点，D为子树终点，因为D前面有一个#可知，C的左子树为#，右子树为D；
分析A的右子树{EF##G##}，E为根结点，F为左子树，G为右子树；</p><p>————————————————
版权声明：本文为CSDN博主「Mindtechnist」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43471489/article/details/123967360</p><h4 id=23算法实现>2.3算法实现<a hidden class=anchor aria-hidden=true href=#23算法实现>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>buildTree</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>,</span><span class=kt>int</span><span class=o>&amp;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>||</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;#&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>root</span><span class=o>-&gt;</span><span class=n>leftChild</span> <span class=o>=</span> <span class=n>buildTree</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>root</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=o>=</span> <span class=n>buildTree</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>this</span><span class=o>-&gt;</span><span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=二叉树的树形显示>二叉树的树形显示<a hidden class=anchor aria-hidden=true href=#二叉树的树形显示>#</a></h2><p>【原创】二叉树的树形显示步骤：设置好二叉树各个节点的X,Y坐标，再根据结点的xy坐标进行相关输出比较方便。</p><h4 id=1在二叉树结点的成员中增加xy坐标的数据成员>1、在二叉树结点的成员中增加x,y坐标的数据成员<a hidden class=anchor aria-hidden=true href=#1在二叉树结点的成员中增加xy坐标的数据成员>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-CPP data-lang=CPP><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>BinTreeNode</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//数据成员
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>ElemType</span> <span class=n>data</span><span class=p>;</span>						<span class=c1>//数据域
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>leftChild</span><span class=p>;</span>	<span class=c1>//左孩子指针域
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>rightChild</span><span class=p>;</span>	<span class=c1>//右孩子指针域
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//函数成员
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BinTreeNode</span><span class=p>();</span><span class=c1>//无参数的构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BinTreeNode</span><span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>,</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>lChild</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>rChild</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>);</span><span class=c1>//已知数据元素值，指向左右孩子的指针构造一个结点
</span></span></span><span class=line><span class=cl><span class=c1></span>	
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 id=2编写设置二叉树坐标的函数>2、编写设置二叉树坐标的函数<a hidden class=anchor aria-hidden=true href=#2编写设置二叉树坐标的函数>#</a></h4><p>思路：保证二叉树最底层的元素间隔三个位置，往上递推间隔。</p><p>记录第一层i=1,第二层i=2&mldr;</p><p>x坐标轴从左上向右延展，y坐标轴从左上向下延展</p><p>根据数学演算推理得：</p><p>y=(i-1)*2</p><p>公式表示，该层中首个结点的x坐标+该层中每个节点之间的空格*该结点是该层中的第几个节点</p><p>h为二叉树的高度；</p><p>i表示层数，从根节点1开始；</p><p>binary表示二进制到达该节点的路径，从根节点出发，访问左孩子的操作记为0，访问右孩子的操作记为1，最后将得到的二进制数转换为十进制数，再减1就是该节点的是该层中的第几个结点。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-CPP data-lang=CPP><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>ElemType</span><span class=o>&gt;</span><span class=c1>// 设置二叉树坐标
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>inline</span> <span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>SetXY</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>location</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>this</span><span class=o>-&gt;</span><span class=n>PreSet</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>location</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>	
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>bool</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>PreSet</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>r</span><span class=p>,</span> <span class=kt>int</span><span class=o>*</span> <span class=n>location</span><span class=p>,</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 操作结果：二叉树的每一个节点都用坐标XY标记
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//标记当前节点的坐标信息
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//设置y的坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>r</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>//设置x的坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>Height</span><span class=p>();</span><span class=c1>//h表示整个二叉树的高度
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>binary</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>interval</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>h</span> <span class=o>-</span> <span class=n>i</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>sum</span> <span class=o>+=</span> <span class=n>pow</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>i</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>binary</span> <span class=o>=</span> <span class=n>binary</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=n>location</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>h</span> <span class=o>-</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>interval</span> <span class=o>+=</span> <span class=n>pow</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>interval</span> <span class=o>+=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>r</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=n>sum</span> <span class=o>+</span> <span class=n>binary</span> <span class=o>*</span> <span class=p>(</span><span class=n>interval</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//标记左子树的坐标信息
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//当下面的结点不为空时，location[i]来记录从根节点走到当前节点是怎么走的，0表示走左边，1表示走右边
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>leftChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>location</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>PreSet</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>,</span><span class=n>location</span><span class=p>,</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>i</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>	<span class=c1>//标记右子树的坐标信息
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>rightChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>location</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>PreSet</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>,</span><span class=n>location</span><span class=p>,</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>i</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=3通过二叉树的层次遍历配合xy坐标进行输出>3、通过二叉树的层次遍历，配合x,y坐标进行输出<a hidden class=anchor aria-hidden=true href=#3通过二叉树的层次遍历配合xy坐标进行输出>#</a></h4><p>文本中注释的代码是还没有写好的，本来是想要把二叉树的左右分支“/“‘\”显示出来的，发现还有一些其他的问题需要解决，期末周比较紧，就没有花时间去研究了。</p><p>主要的问题：</p><p>1.打印树枝"/""\&ldquo;时需要分清楚左右孩子才能准确打印（可以通过增加状态量isRightchild进行判断）</p><p>2.（未解决）打印一个“/”最合适的位置是在上下两排结点中最居中的位置，但是需要同时知道上下两个结点的x坐标，才能够进行计算，但实际上，实现要输出上一排结点，再输出&rdquo;/&ldquo;或者&rdquo;\"，最后再输出下一排结点。当输出“/”无法知道下面的结点，还要顾及旁边的子树是否有节点等问题。</p><p>预想的解决方法是：</p><p>​ 1.把现有的结点坐标信息都输入到数组或者向量中去，转换为一个比较方便计算位置的数据结构</p><p>​ 2.在队列中，将除根结点以外的其他节点进行两次进栈操作，按层序为单位。第一次出栈的时候打印“/”，第二次出栈打印元素值。但此方法需要记录上一层元素的x坐标值（可能含有多个x坐标），操作起来感觉也比较麻烦。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>printTree</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>this</span><span class=o>-&gt;</span><span class=n>SetXY</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*&gt;</span> <span class=n>q</span><span class=p>;</span>		<span class=c1>//定义队列q
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span><span class=n>q</span><span class=p>.</span><span class=n>EnQueue</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>			<span class=c1>//如果根非空，则入队
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>							<span class=c1>//x和y记录上一结点的坐标信息
</span></span></span><span class=line><span class=cl><span class=c1>//	int xx = 0, yy = 0;							//控制打印&#34;/&#34;&#34;\&#34;
</span></span></span><span class=line><span class=cl><span class=c1>//	bool isRightChild = true;					//记录当前节点是不是双亲结点的右孩子
</span></span></span><span class=line><span class=cl><span class=c1>//	bool flag_twice = false;					//标记当前节点是不是打印过
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span> <span class=p>{</span>					    <span class=c1>//q非空，说明还有结点未访问
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>q</span><span class=p>.</span><span class=n>DelQueue</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>							<span class=c1>//队头元素出队，并访问它
</span></span></span><span class=line><span class=cl><span class=c1></span>		
</span></span><span class=line><span class=cl>		<span class=c1>//打印&#34;/&#34;和&#34; \&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>		if (p!=root &amp;&amp; flag_twice==false) {
</span></span></span><span class=line><span class=cl><span class=cm>			xx = (x + p-&gt;x) / 2;
</span></span></span><span class=line><span class=cl><span class=cm>			for (int i = p-&gt;y == y ? x : 0; i &lt; p-&gt;x; i++)			//打印前导空格
</span></span></span><span class=line><span class=cl><span class=cm>				cout &lt;&lt; &#34; &#34;;
</span></span></span><span class=line><span class=cl><span class=cm>			if (isRightChild)
</span></span></span><span class=line><span class=cl><span class=cm>				cout &lt;&lt; &#34;/&#34; &lt;&lt; flush;
</span></span></span><span class=line><span class=cl><span class=cm>			else cout &lt;&lt; &#34;\\&#34; &lt;&lt; flush;
</span></span></span><span class=line><span class=cl><span class=cm>			
</span></span></span><span class=line><span class=cl><span class=cm>		}*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>//打印元素值
</span></span></span><span class=line><span class=cl><span class=c1>//		if (flag_twice == true) {
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>!=</span> <span class=n>y</span><span class=p>)</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>				<span class=c1>//控制元素的换行
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>==</span> <span class=n>y</span> <span class=o>?</span> <span class=nl>x</span> <span class=p>:</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>			<span class=c1>//打印前导空格
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>&lt;&lt;</span> <span class=n>flush</span><span class=p>;</span>				<span class=c1>//打印结点值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>			<span class=n>x</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>y</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//		}
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//		if (flag_twice == false) {
</span></span></span><span class=line><span class=cl><span class=c1>//			q.EnQueue(p);
</span></span></span><span class=line><span class=cl><span class=c1>//			flag_twice = true;
</span></span></span><span class=line><span class=cl><span class=c1>//		}
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>				<span class=c1>//队头元素左孩子非空
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>q</span><span class=p>.</span><span class=n>EnQueue</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>);</span>			<span class=c1>//左孩子入队
</span></span></span><span class=line><span class=cl><span class=c1>//			isRightChild = false;
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rightChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>				<span class=c1>//队头元素右孩子非空
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>q</span><span class=p>.</span><span class=n>EnQueue</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>);</span>			<span class=c1>//右孩子入队
</span></span></span><span class=line><span class=cl><span class=c1>//			isRightChild = true;
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=4输出结果>4.输出结果<a hidden class=anchor aria-hidden=true href=#4输出结果>#</a></h4><h2 id=8树和森林的实现>8、树和森林的实现<a hidden class=anchor aria-hidden=true href=#8树和森林的实现>#</a></h2><h3 id=1树的存储>1、树的存储<a hidden class=anchor aria-hidden=true href=#1树的存储>#</a></h3><h4 id=1-双亲数组表示法>1） <strong>双亲数组表示法</strong><a hidden class=anchor aria-hidden=true href=#1-双亲数组表示法>#</a></h4><p>​ n个结点，type a[n]表示，每个结点有两个域data和parent，分别表示结点本身信息和父结点序号。</p><h4 id=2孩子结点为单链表-孩子表示法>2）<strong>孩子结点为单链表 （孩子表示法）</strong><a hidden class=anchor aria-hidden=true href=#2孩子结点为单链表-孩子表示法>#</a></h4><p>​ 把每个结点的孩子排列起来，看作以单链表作存储结构的线性表。n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表。</p><h4 id=3带双亲的孩子链表-双亲-孩子表示法>3）<strong>带双亲的孩子链表 （双亲-孩子表示法）</strong><a hidden class=anchor aria-hidden=true href=#3带双亲的孩子链表-双亲-孩子表示法>#</a></h4><p>结点前面的数字代表他的双亲</p><h4 id=4双重链表孩子-兄弟表示法>4）<strong>双重链表（孩子-兄弟表示法）</strong><a hidden class=anchor aria-hidden=true href=#4双重链表孩子-兄弟表示法>#</a></h4><p>​ n个结点，每个结点有一个域data和两个指针域，分别表示结点本身信息、指向第一个孩子及指向第一个【下一个】兄弟。</p><h3 id=2树森林二叉树的转换>2、树、森林、二叉树的转换<a hidden class=anchor aria-hidden=true href=#2树森林二叉树的转换>#</a></h3><h4 id=1树转换为二叉树>1）树转换为二叉树<a hidden class=anchor aria-hidden=true href=#1树转换为二叉树>#</a></h4><p><strong>条件：</strong> 树无序，二叉树左、右孩子结点有区别的。约定树中每一个结点的孩子结点按从左到右的次序顺序编号(有序树)。</p><p><strong>方法：</strong></p><p>（1）连线：树中所有<strong>相邻兄弟</strong>结点之间加一条线；</p><p>（2）删线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删去它与其他孩子结点之间的连线。</p><p>（3）美化：以树的根结点为轴心，将这棵树顺时针转动45度使其层次分明。</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/03/upgit_20230321_1679382410.png alt=image-20230321150650420></p><h4 id=2森林转换为二叉树>2）森林转换为二叉树<a hidden class=anchor aria-hidden=true href=#2森林转换为二叉树>#</a></h4><p>森林转化为二义树的方法：</p><p>（1）依次将森林中的每棵树转化成相应的二叉树；</p><p>（2）从第二棵二叉树开始，依次把当前的二叉树作为前一棵二叉树根结点的右子树，此时所得到的二叉树就是由森林转化得到的二叉树。</p><p><strong>树和森林都可以转化成二叉树，两者的不同之处：</strong></p><p><strong>树</strong>转化成的二叉树，他的<strong>根节点是没有右子树</strong>的；</p><p><strong>森林</strong>转化的二叉树，其<strong>根节点是有右子树</strong>的。</p><p><strong>可以根据二叉树根节点是否有右子树，将其转化为树或者森林。</strong></p><h4 id=3二叉树转化为树>3）二叉树转化为树<a hidden class=anchor aria-hidden=true href=#3二叉树转化为树>#</a></h4><p>（1）加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，……沿分支找到的所有右孩子，都与p的双亲用线连起来</p><p>（2）抹线：抹掉原二叉树中双亲与右孩子之间的连线</p><p>（3）调整：将结点按层次排列，形成树结构</p><h4 id=4二叉树转化为森林>4）<strong>二叉树转化为森林</strong><a hidden class=anchor aria-hidden=true href=#4二叉树转化为森林>#</a></h4><p>(1) **连线：**若结点P是其双亲结点F的左孩子，则把从结点P沿右分支所找到的所有结点和结点F用线连起来；</p><p>(2) **删线：**删除二叉树中所有结点和其右孩子结点之间的连线；</p><p>(3) **美化：**整理由前两步所得到的树或森林，使之结构层次分明。</p><h3 id=3树的遍历>3、树的遍历<a hidden class=anchor aria-hidden=true href=#3树的遍历>#</a></h3><p><strong>先根遍历</strong>、<strong>后根遍历</strong>和<strong>层次遍历</strong>。</p><h4 id=1先根遍历>1）先根遍历<a hidden class=anchor aria-hidden=true href=#1先根遍历>#</a></h4><p><strong>树的先根遍历与二叉树的先序遍历相同</strong></p><p>树的先根遍历的定义：若树为空，遍历结束。否则，</p><p>​ (1) 访问根结点；</p><p>​ (2) 按照<strong>从左到右</strong>的顺序<strong>先根</strong>遍历根结点的每一棵子树。</p><p>结果序列：A、B、E、F、K、L、C、G、D、H、I、M、N、J。</p><h4 id=2后根遍历>2）后根遍历<a hidden class=anchor aria-hidden=true href=#2后根遍历>#</a></h4><p><strong>树的后根遍历与二叉树的中序遍历相同</strong></p><p>树的后根遍历的定义：若树为空，遍历结束。否则，</p><p>​ (1) 按照<strong>从左到右</strong>的顺序<strong>后根</strong>遍历根结点的每一棵子树；</p><p>​ (2) 访问根结点。</p><p>结果序列： E、K、L、F、B、G、C、H、M、N、I、J、D、A。</p><h4 id=3层次遍历>3）层次遍历<a hidden class=anchor aria-hidden=true href=#3层次遍历>#</a></h4><p><strong>定义</strong></p><p>树的层序遍历也称为树的广度遍历，就是从树的第一层(根结点)开始，自上至下逐层遍历，在同一层中，则按从左到右的顺序对结点逐个访问。</p><p>遍历序列为：A、B、C、D、E、F、G、H、I、J、K、L、M、N。</p><p><strong>算法思想</strong></p><p>设置一个队列结构，并按下述步骤层序遍历树：</p><p>​ 1) 初始化队列，并将根结点入队。</p><p>​ 2) 当队列非空时，取出队头结点p，转步骤3；如果队列为空，则结束遍历。</p><p>​ 3) 访问取出的结点p；如果结点p有孩子，则依次将它们入队列。</p><p>​ 4) 重复步骤2)、3)，直到队列为空。</p><h3 id=4森林的遍历>4、森林的遍历<a hidden class=anchor aria-hidden=true href=#4森林的遍历>#</a></h3><p>方式：<strong>先根遍历</strong>、<strong>中根遍历</strong>和<strong>后根遍历</strong>。</p><h4 id=1先根遍历-1>1.<strong>先根遍历</strong><a hidden class=anchor aria-hidden=true href=#1先根遍历-1>#</a></h4><p><strong>小结：每一棵树先根遍历，下一颗树</strong></p><p>若森林为空，返回；否则</p><p>(1) 访问森林中第一棵树的根结点；</p><p>(2) 先根遍历第一棵树的根结点的子树森林；</p><p>(3) 先根遍历除第一棵外其它树组成的森林。</p><p>结果序列：A、B、 E、 C、D、F、G、H、I 、 J、K 。</p><h4 id=2中根遍历>2.<strong>中根遍历</strong><a hidden class=anchor aria-hidden=true href=#2中根遍历>#</a></h4><p><strong>小结：中序遍历访问完第一棵树的所有子树后访问根节点，再下一颗树。</strong></p><p>若森林为空，返回；否则</p><p>(1) 中根遍历第一棵树的根结点的子树森林；</p><p>(2) 访问森林中第一棵树的根结点；</p><p>(3) 中根遍历除第一棵外其它树组成的森林。</p><p>结果序列：E、B、C、D、A 、G、F、I、K、J 、H 。</p><h4 id=3后根遍历>3.<strong>后根遍历</strong><a hidden class=anchor aria-hidden=true href=#3后根遍历>#</a></h4><p><strong>小结：对同一层次的结点从顺序上来看是同一棵树下的从右到左访问，优先更深层次的访问，是一层一层回来的。</strong></p><p>若森林为空，返回；否则</p><p>(1) 后根遍历第一棵树的根结点的子树森林；</p><p>(2) 后根遍历除第一棵外其它树组成的森林；</p><p>(3) 访问森林中第一棵树的根结点。</p><p>结果序列：E、D 、 C、 B、G、K、J、 I、 H、F、A 。（易错）</p><p>根据森林与二叉树的转化关系以及森林和二叉树的遍历定义可以得知，</p><p><strong>森林的先根遍历与其转化后相应二叉树的前序遍历的结果序列相同；</strong></p><p><strong>森林的中根遍历与其转化后相应二叉树的中序遍历的结果序列相同；</strong></p><p><strong>森林的后根遍历与其转化后相应二叉树的后序遍历的结果序列相同。</strong></p><p>因此，森林的遍历算法也可采用相应的二叉树的遍历算法实现。</p><h2 id=9等价类及其表示>9、等价类及其表示<a hidden class=anchor aria-hidden=true href=#9等价类及其表示>#</a></h2><h3 id=1等价关系与等价类>1、等价关系与等价类<a hidden class=anchor aria-hidden=true href=#1等价关系与等价类>#</a></h3><p>利用等价关系把集合S划分成若干等价类的算法步骤：</p><p>​ 1）首先把S中的每一个对象看成是一个等价类；</p><p>​ 2）依次处理各个等价对（x等价y）：若x属于Si、y属于Sj，且Si不等于Sj，则把集合Si、Sj合并成一个集合。</p><h3 id=2并查集>2、并查集<a hidden class=anchor aria-hidden=true href=#2并查集>#</a></h3><p><strong>1.</strong> <strong>定义</strong></p><p>能够完成<strong>以上</strong>功能(首先把每一个对象看成是一个单元素集合，然后依次将属于同一个等价类的元素所在的集合合并)的集合就是<strong>并查集</strong>。</p><p><strong>2.</strong> <strong>操作</strong></p><p>并查集支持以下三种操作：</p><p>（1） Ufsets(n)：构造函数，将并查集中n个元素初始化为n个 只有一个单元素的子集合。</p><p>（2） Find(d)：查找单元素d所在的集合，并返回该集合的名 字或id之类的标识。</p><p>（3） Union(S1，S2)：把集合S2并入集合S1中。要求S1与S2互 不相交，否则没有结果。</p><h1 id=拓展布隆过滤器-bloom-filter>【拓展】布隆过滤器 Bloom Filter<a hidden class=anchor aria-hidden=true href=#拓展布隆过滤器-bloom-filter>#</a></h1><p>编译和反编译</p><h2 id=c>C++<a hidden class=anchor aria-hidden=true href=#c>#</a></h2><h3 id=编译>编译<a hidden class=anchor aria-hidden=true href=#编译>#</a></h3><ol><li><p>在终端中导航到存储C++源代码的目录中。</p></li><li><p>使用以下命令将C++源代码汇编为汇编文件：</p><pre tabindex=0><code>g++ -S -fverbose-asm -g BloomFilter.cpp -o BloomFilter-cpp.s
</code></pre><p>这个命令将使用g++编译器将BloomFilter.cpp文件汇编为汇编文件BloomFilter-cpp.asm。</p></li></ol><p>​ 3.使用as命令查看汇编代码，并重定向输出保存为 <code>asm</code> 文件</p><pre tabindex=0><code>as -alhnd BloomFilter-cpp.s &gt; BloomFilter-cpp-front.asm
</code></pre><h3 id=反编译>反编译<a hidden class=anchor aria-hidden=true href=#反编译>#</a></h3><p>将C++程序转换为汇编代码的过程可以分为两个步骤：首先将C++程序编译为目标文件，然后将目标文件反汇编为汇编代码。以下是详细的步骤：</p><p><strong>编译C++程序为目标文件</strong></p><p>编译器将C++源代码编译为目标文件，这是一个二进制文件，它包含了程序的机器代码以及其他与程序执行有关的元数据。</p><p>对于C++程序，通常使用GCC编译器。可以使用以下命令将C++源代码编译为目标文件：</p><p><code>g++ -c BloomFilter.cpp -o BloomFilter.o</code></p><p><code>g++ -g BloomFilter.cpp -o executable</code></p><p>其中，.cpp是C++源代码文件的名称，.o是目标文件的名称。-c选项表示只进行编译而不进行链接，因此生成的文件是目标文件而不是可执行文件。</p><p><strong>反汇编目标文件为汇编代码</strong></p><p>反汇编目标文件的过程将机器代码转换回汇编语言，以便更容易地阅读和理解程序的工作原理。</p><p>可以使用objdump命令反汇编目标文件。例如，以下命令将.o目标文件反汇编为汇编代码：</p><p><code>objdump -d BloomFilter.o > BloomFilter-c.asm</code></p><p><code>objdump -S executable > BloomFilter-cpp-back.asm</code></p><p>其中，-d选项表示反汇编代码段，>运算符将输出重定向到.asm文件。</p><p>此时，.asm文件中包含了C++程序的汇编代码，可以使用文本编辑器或其他工具来查看和编辑它。</p><h2 id=java>Java<a hidden class=anchor aria-hidden=true href=#java>#</a></h2><p>在Java中，源代码需要先经过编译器的处理转换成Java字节码，然后由Java虚拟机（JVM）进行解释执行。因此，在Java中进行汇编和反汇编操作，实际上是针对Java字节码进行的。</p><p>Java字节码是一种类似于汇编代码的中间语言，它可以通过Java虚拟机（JVM）转换成机器码并执行。Java提供了javap命令来反汇编Java字节码文件，以下是详细步骤：</p><p><strong>编译Java源代码</strong></p><p>使用javac命令将Java源代码编译成Java字节码文件，例如：</p><pre tabindex=0><code>javac BloomFilter.java
</code></pre><p><strong>反汇编Java字节码文件</strong></p><p>使用javap命令反汇编Java字节码文件，例如：</p><pre tabindex=0><code>javap -c BloomFilter.class &gt; BloomFilter-java.asm
</code></pre><p>其中，-c选项表示将反汇编结果输出为字节码指令，.class是编译生成的Java字节码文件名，>运算符表示将结果输出到一个文件中，此处输出到.asm文件中。</p><h2 id=python>python<a hidden class=anchor aria-hidden=true href=#python>#</a></h2><h1 id=四图>四、图<a hidden class=anchor aria-hidden=true href=#四图>#</a></h1><h2 id=1图的基本概念>1. 图的基本概念<a hidden class=anchor aria-hidden=true href=#1图的基本概念>#</a></h2><p>图(Graph)—非线性关系，关系任意，多个前驱多个后继</p><p><strong>图的限制</strong></p><ol><li>图中不能有从顶点自身到自身的边(即自身环)，就是说不应有形如(x，x)或＜x，x＞的边。如图(a)所示的带自身环的图不讨论。</li><li>两个顶点v和w之间相关联的边不能多于一条。如图(b)所示的多重图也不讨论。</li></ol><p>​</p><p><strong>图的术语</strong></p><p>1．完全图(complete graph)：n个顶点有n(n-1)/2条边的图
2．权(weight)：带权图也被称为网络network
3．邻接点(adjacent vertex)
4．子图(subgraph)</p><p>5．顶点的度
6．路径
7．路径长度
8．简单路径与回路：简单路径是路径上顶点各不相同的路径
9．连通图与连通分量
10．强连通图与强连通分量
11．生成树（连通图）</p><h2 id=2图的存储结构>2. 图的存储结构<a hidden class=anchor aria-hidden=true href=#2图的存储结构>#</a></h2><h3 id=21邻接矩阵>2.1 邻接矩阵<a hidden class=anchor aria-hidden=true href=#21邻接矩阵>#</a></h3><p>邻接矩阵（Adjacency Matrix）涉及到了两个数据结构。</p><ul><li><p>第一个是一个<strong>顶点数组</strong>，用来存放图当中的顶点信息。</p><p>举例：比如下面的A图中，顶点有ABCD，那这个顶点数组vertexes就依次存放ABCD</p></li><li><p>第二个是一个<strong>存放边的二维数组</strong>，之所以要用二维数组，就是用来描述是从哪一个点到哪一个点的边，是否存在。</p></li></ul><p>​ 举例：AC之间有一边，并且是无向边，也就是说从A到C和从C到A都有一条边。在边数组中的体现就是，arcs[0][2]和arcs[2][0]的数都是1，（1表示边存在， 0表示没有边，0和2分别对应顶点数组中的A和C的下标）</p><p>这样，通过顶点数组和边数组，就能清楚描述一个图了，这就是邻接矩阵存储一个图，简单吧~</p><p>邻接矩阵的Arcs数组中：</p><p>对于带权图（网络）：</p><h3 id=22邻接表>2.2 邻接表<a hidden class=anchor aria-hidden=true href=#22邻接表>#</a></h3><p>邻接表中总体的概念是将每一个点都放到一个数组中，以表示<strong>顶点的信息</strong>，<strong>边的信息</strong>则是通过这些顶点所指来进行表示。</p><p><strong>头节点</strong></p><p>把顶点放到数组中存放，其存储方式是通过构造了“头结点”结构体，这个结构体中包含了：</p><ul><li>顶点的信息</li><li>顶点指向的下一个顶点（也就是边的信息）</li></ul><p><strong>边结点/表结点</strong></p><p>再来看存放边信息的表结点中，有一个边结点就代表这个头结点还有边。</p><ul><li>那么从这个头结点中指出来的边到底是和哪个顶点连成的边呢？这个信息就需要存放在表结点中。也就是adjvex（邻接点），表示头节点和这个邻接点形成了一条边；</li><li>在表结点中还有一个域，是nextarc（下一条边），这是一个指针，用来指向下一个表结点的位置。</li></ul><p>这样，一个头节点和所有从他出发的边就表示好了。</p><p>对每一个结点都这样做，都把他们作为头节点存放在一个数组中，再添加上从他们出发的边信息的链表，这一个图就描述清楚了。，</p><p>对于<strong>带权图(网络)</strong>，须在邻接表的边结点中增加一个存放<strong>边上的权值的域weight</strong>（即info域，它可以表示相关信息）。如下图所示的是一个带权图的邻接表表示。</p><h3 id=23邻接矩阵和邻接表的比较>2.3 邻接矩阵和邻接表的比较<a hidden class=anchor aria-hidden=true href=#23邻接矩阵和邻接表的比较>#</a></h3><p>试想一下，如果一个顶点很多边很少的图用邻接矩阵来存储，是不是他表示边的二维数组中，就会有很多的0，这就会造成内存的浪费。所以对于稀疏图，最好的存储办法是采用邻接表来存储，邻接表是有一条边存一条边，就可以避免这个问题。</p><p>同样的，如果图的边非常的稠密，用邻接表存储也会有很多指针等额外的开销，所以性能还不如邻接矩阵。</p><p>所以才会有这两种给存储方式，同时他们的遍历方式也不太相同，有时候也会针对所关注的图的某一方面进行选择存储方式。</p><p>比如如果我很关注从某一顶点出发，有哪些边？邻接矩阵就从该顶点的行和列进行搜寻1；邻接表就直接从该头结点向后面找就行。</p><ul><li>在邻接表/逆邻接表的边表 相当于 邻接矩阵的一行/一列。</li><li>求顶点的度/出度/入度</li><li>判断(vi，vj)或＜vi，vj＞是否为图的边</li><li>求图的边数</li><li>……</li><li>n个顶点e条边的图G，无向图的邻接表：n个顶点表结点和2e个边表结点；有向图邻接表/逆邻接表：n个顶点表结点和e个边表结点。因此<strong>邻接表或逆邻接表表示的空间复杂度为S(n，e)＝O(n+e)</strong>。</li><li><strong>稀疏图—邻接表；稠密图—邻接矩阵</strong>。</li></ul><h3 id=24无向图的邻接多重表>2.4 无向图的邻接多重表<a hidden class=anchor aria-hidden=true href=#24无向图的邻接多重表>#</a></h3><p>​ <strong>邻接多重表</strong>是<strong>无向图</strong>的另一种<strong>链式存储结构</strong>.每一条边用一个结点表示,每一个顶点也用一个结点表示。</p><h3 id=25有向表的十字链表>2.5 有向表的十字链表<a hidden class=anchor aria-hidden=true href=#25有向表的十字链表>#</a></h3><p>​ <strong>十字链表</strong>是<strong>有向图</strong>的另一种<strong>链式存储结构</strong>。在有向图的十字链表中，图中的每一条弧用一个弧结点表示。对有向图中的每一个顶点也用一个顶点结点表示。</p><h2 id=3图的遍历与连通性>3. 图的遍历与连通性<a hidden class=anchor aria-hidden=true href=#3图的遍历与连通性>#</a></h2><p>DFS和BFS的<strong>时间复杂度</strong>：</p><p>如果存储结构是<strong>邻接表</strong>，则时间复杂度为<strong>O(n+e)</strong></p><p>存储结构是<strong>邻接矩阵</strong>，时间复杂度为<strong>O(n^2)</strong></p><h3 id=31深度优先搜索>3.1 深度优先搜索<a hidden class=anchor aria-hidden=true href=#31深度优先搜索>#</a></h3><p><strong>基本步骤</strong></p><p>（1）访问结点v，并标记v已被访问；
（2）取顶点v的第一个邻接顶点w；
（3）若顶点w不存在，返回；否则继续步骤（4）
（4）若顶点w未被访问，则访问结点w，并标记w已被访问；否则转步骤（5）
（5）使w为顶点v的在原来w之后的下一个邻接顶点，转到步骤（3）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DFS</span><span class=p>(</span><span class=k>const</span> <span class=n>AdjMatrixUndirGraph</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>g</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>Visit</span><span class=p>)</span> <span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=p>)){</span>	
</span></span><span class=line><span class=cl>	<span class=n>ElemType</span> <span class=n>e</span><span class=p>;</span>	
</span></span><span class=line><span class=cl>	<span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>VISITED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>g</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>e</span><span class=p>);</span>	
</span></span><span class=line><span class=cl>	<span class=n>Visit</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>FirstAdjVex</span><span class=p>(</span><span class=n>v</span><span class=p>);</span> <span class=n>w</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>  <span class=n>w</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>NextAdjVex</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>w</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	      <span class=k>if</span> <span class=p>(</span><span class=n>g</span><span class=p>.</span><span class=n>GetTag</span><span class=p>(</span><span class=n>w</span><span class=p>)</span> <span class=o>==</span> <span class=n>UNVISITED</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=n>DFS</span><span class=p>(</span><span class=n>g</span><span class=p>,</span> <span class=n>w</span><span class=p>,</span> <span class=n>Visit</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DFSTraverse</span><span class=p>(</span><span class=k>const</span> <span class=n>AdjMatrixUndirGraph</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>g</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>Visit</span><span class=p>)(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>UNVISITED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>g</span><span class=p>.</span><span class=n>GetTag</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>==</span> <span class=n>UNVISITED</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>DFS</span><span class=p>(</span><span class=n>g</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>Visit</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=32广度优先搜索>3.2 广度优先搜索<a hidden class=anchor aria-hidden=true href=#32广度优先搜索>#</a></h3><p><strong>基本思想</strong></p><p>​ 从图中的某一顶点v出发，在访问顶点v后访问v的各个未曾被访问过的邻接顶点w1,w2,..,wk，再依次访问它们的所有未被访问过的邻接顶点&mldr;..直到所有的和顶点v联通的顶点都被访问过为止。</p><p>​ BFS是一个分层的搜索过程，像树的层次遍历，不像深度搜索那样有回退的过程，所以它不是一个递归的过程。算法中使用了一个队列，用来记录刚才访问过的上一层和本层的结点，以便于向下一层访问。</p><p><strong>基本步骤</strong></p><p>（1）访问结点v，并标记v已被访问，同时顶点v入队列；
（2）当队列空时算法结束，否则继续步骤（3）；
（3）队头顶点出队列为v；
（4）取顶点v的第一个邻接顶点w；
（5）若顶点w不存在，转步骤（3）；否则继续步骤（6）
（6）若顶点w未被访问，则访问顶点w，并标记w已被访问，同时顶点w入队列；否则继续步骤（7）；
（7）使w为顶点v的在原来w之后的下一邻接点，转到步骤（5）。</p><p><strong>特点</strong></p><p>先进先出,非递归,队列辅助</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BFS</span><span class=p>(</span><span class=k>const</span>  <span class=n>AdjMatrixUndirGraph</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>g</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>Visit</span><span class=p>)(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>	
</span></span><span class=line><span class=cl>    <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>u</span><span class=p>,</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ElemType</span> <span class=n>e</span><span class=p>;</span>   
</span></span><span class=line><span class=cl>    <span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>VISITED</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>g</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Visit</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span><span class=p>.</span><span class=n>EnQueue</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>q</span><span class=p>.</span><span class=n>DelQueue</span><span class=p>(</span><span class=n>u</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>w</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>FirstAdjVex</span><span class=p>(</span><span class=n>u</span><span class=p>);</span> <span class=n>w</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>w</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>NextAdjVex</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>w</span><span class=p>))</span>
</span></span><span class=line><span class=cl>           <span class=k>if</span> <span class=p>(</span><span class=n>g</span><span class=p>.</span><span class=n>GetTag</span><span class=p>(</span><span class=n>w</span><span class=p>)</span> <span class=o>==</span> <span class=n>UNVISITED</span><span class=p>){</span> 
</span></span><span class=line><span class=cl>              <span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>VISITED</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>              <span class=n>g</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>e</span><span class=p>);</span>	
</span></span><span class=line><span class=cl>			  <span class=n>Visit</span><span class=p>(</span><span class=n>e</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>              <span class=n>q</span><span class=p>.</span><span class=n>EnQueue</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>	
</span></span><span class=line><span class=cl>     <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BFSTraverse</span><span class=p>(</span><span class=k>const</span> <span class=n>AdjMatrixUndirGraph</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>g</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>Visit</span><span class=p>)(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=p>))</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	     <span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>UNVISITED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>g</span><span class=p>.</span><span class=n>GetTag</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>==</span> <span class=n>UNVISITED</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>			<span class=n>BFS</span><span class=p>(</span><span class=n>g</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>Visit</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=33连通分量>3.3 连通分量<a hidden class=anchor aria-hidden=true href=#33连通分量>#</a></h3><h2 id=4最小生成树>4. 最小生成树<a hidden class=anchor aria-hidden=true href=#4最小生成树>#</a></h2><p><strong>MST, minimum cost spanning tree</strong></p><ul><li>定义(Spanning Tree)
连通图的极小连通子图，<strong>有且仅有</strong>n个顶点n-1条边
连通, 无环</li><li>特点<ul><li>任意两顶点有且仅有一条路径；</li><li>n个顶点的连通图的生成树具有n-1条边；</li><li>生成树不唯一， n 个顶点的完全图有n(n-2)种不同的生成树；</li><li>不同遍历方法/不同顶点出发/不同存储结构，生成树不同；</li><li>含n个顶点n-1条边的图不一定是生成树</li></ul></li><li>如何求得生成树
深度优先搜索树、广度优先搜索树</li></ul><h3 id=41kruskal算法>4.1 Kruskal算法<a hidden class=anchor aria-hidden=true href=#41kruskal算法>#</a></h3><h4 id=1算法思想>（1）<strong>算法思想</strong><a hidden class=anchor aria-hidden=true href=#1算法思想>#</a></h4><p>​ F＝{T0、T1、…、Tn-1}。向F中<strong>加入最小权值&不构成环的边</strong>（v、u），重复n—1次。</p><h4 id=2主要问题><strong>（2）主要问题</strong><a hidden class=anchor aria-hidden=true href=#2主要问题>#</a></h4><p>（1）最小，排序，如何实现排序——最小堆可以实现
（2）两端点在不同连通分量上的边，如何判断边(u,v)已经构成环？——并查集可以实现</p><h4 id=3主要步骤><strong>（3）主要步骤</strong><a hidden class=anchor aria-hidden=true href=#3主要步骤>#</a></h4><p>（1）初始化，在并查集中，连通网络的每一个顶点独立成一个等价类，连通网络的所有的边建立最小堆，最小生成树T中没有任何边，T中边的条数计数器i为0；
（2）如果T中边的条数计数器i等于顶点数减1，则算法结束；否则继续步骤（3）；
（3）选取堆顶元素代表的边（v，u），同时调整堆；
（4）利用并查集的运算检查依附于边（v，u）的两个顶点v和u是否在同一个连通分量(即并查集的同一个子集合)上，如果是则转步骤（2）；否则继续步骤（5）；
（5）将边（v，u）加入到最小生成树T中，同时将这两个顶点所在的连通分量合并成一个连通分量(即并查集中的相应两个子集合并成一个子集)，继续步骤（2）。</p><h4 id=4举例><strong>（4）举例</strong><a hidden class=anchor aria-hidden=true href=#4举例>#</a></h4><p>在初始建堆时，边的输入顺序为：
（ A、B）34
（A、C）46
（A、F）19
（B、E）12
（C、D）17
（C、F）25
（D、E）38
（D、F）25
（E，F） 26</p><h3 id=42prim算法>4.2 Prim算法<a hidden class=anchor aria-hidden=true href=#42prim算法>#</a></h3><h4 id=1算法思想-1><strong>（1）算法思想</strong><a hidden class=anchor aria-hidden=true href=#1算法思想-1>#</a></h4><p>​ G＝(V，E)；</p><p>​ 最小生成树T＝(U，TE）；</p><p>​ 初始U={u0}（u0∈U），TE=Φ ；</p><p>​ 在所有一个端点u己在T(即u∈U)、另一个端点v还未在T(即v∈V—U)的边中找权最小的边(u，v)，边/v并入TE/U；</p><p>​ 重复到所有顶点进U。</p><p>​ MST性质保证最小，特点&ndash;无环？</p><h4 id=2主要问题-1><strong>（2）主要问题</strong><a hidden class=anchor aria-hidden=true href=#2主要问题-1>#</a></h4><p><strong>每次选出权值最小且两端点在不同集合上的边。</strong></p><p>（1）两端点在不同集合上，如何记录/修改集合【并查集、0/1状态】？</p><p>（2）如何判断在哪些边中找最小，如何实现排序？用堆的概念能否简单解决该问题？</p><h4 id=3主要步骤-1><strong>（3）主要步骤</strong><a hidden class=anchor aria-hidden=true href=#3主要步骤-1>#</a></h4><p>（1）初始化辅助数组closearc[]；
（2）重复下列步骤（3）和（4）n-1次；
（3）在closearc[]中选择lowweight ≠ 0 && lowweight最小的顶点v，即选中的权值最小的边为 ( closearc[v].nearvertex,v ) 。
将closearc[v].lowweight改为0，表示顶点v已加入顶点集U中。并将边(closearc[v]. nearvertex、v)加入生成树T的边集合。
（4）对V-U中的每一个顶点j，如果依附于顶点j和刚加入U集合的新顶点v的边的权值Arcs[v] [j]小于原来依附于j和生成树顶点集合中顶点的边的最短距离closearc[j].lowweight，则修改closearc[j]，使其lowweight = Arcs[v] [j]}，nearvertex = v。</p><p>选择最小的非零且权值的边，如果这个顶点的邻接点的权值通过这个点变小了，就更新表中与他相关的顶点的信息。这样做n-1次。</p><p></p><h3 id=43prim与kruskal算法的性能比较>4.3 Prim与Kruskal算法的性能比较<a hidden class=anchor aria-hidden=true href=#43prim与kruskal算法的性能比较>#</a></h3><h4 id=1-时间复杂性><strong>(1) 时间复杂性:</strong><a hidden class=anchor aria-hidden=true href=#1-时间复杂性>#</a></h4><p>​ Prim: O(n*n)</p><p>​ Kruskal: O(e log e)</p><h4 id=2-适用场合><strong>(2) 适用场合:</strong><a hidden class=anchor aria-hidden=true href=#2-适用场合>#</a></h4><p>​ Prim: 稠密图</p><p>​ Kruskal: 稀疏图</p><h2 id=5最短路径>5. 最短路径<a hidden class=anchor aria-hidden=true href=#5最短路径>#</a></h2><p><strong>最短路径类型</strong>
<strong>单源点</strong>最短路径：弧上权值非负（Dijkstra算法），弧上权值为任意值（贝尔曼-福特算法）
<strong>多源点</strong>最短路径：所有顶点之间的最短路径（Floyd算法）</p><p><strong>最短路径和最小生成树的区别</strong></p><p>最短路径是求两点之间的最小值，最小生成树是求整个图的代价最小问题</p><h3 id=51dijkstra算法>5.1 Dijkstra算法<a hidden class=anchor aria-hidden=true href=#51dijkstra算法>#</a></h3><p>时间复杂度：O(n^2)</p><h4 id=1算法定义><strong>（1）算法定义</strong><a hidden class=anchor aria-hidden=true href=#1算法定义>#</a></h4><p>按路径长度递增的次序产生最短路径。</p><h4 id=2算法思想><strong>（2）算法思想</strong><a hidden class=anchor aria-hidden=true href=#2算法思想>#</a></h4><p>1.每次<strong>从未标记的节点中</strong>选择距<strong>离出发点最近</strong>的节点，标记，<strong>收录到最优路径集合</strong>中；
2.计算刚加入节点A的邻近节点B的距离（不包含标记的节点），
若(节点A的距离 +节点A到节点B的边长)&lt;节点B的距离，就更新节点B的距离和前面点。</p><p>直到目的点被标记。</p><p>思考：
（1）如何记录最短路径[值，路径上顶点集]？
（2）如何记录已求得路径的“终点”集？
（3）如何参照“最短”求“次短”？</p><p>引进辅助向量dist[]
dist[i]表示当前所找到的从始点v0到每个终点vi的最短路径长度。</p><p>引入辅助数组path[]
path[i] 表示从源点v0到顶点vi的最短路径上的顶点vi的直接前驱顶点。</p><p>下一条长度次短的路径是哪一条?
假设该次短路径的终点是vk,则这条路径或者是(v,vk),或者是(v,vj,vk) dist[j] = Min{dist[i]|vi∈V-S}</p><h4 id=3算法图解>（3）算法图解<a hidden class=anchor aria-hidden=true href=#3算法图解>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/04/upgit_20230404_1680584494.png alt=image-20230404130134709></p><h4 id=4c代码>（4）C++代码<a hidden class=anchor aria-hidden=true href=#4c代码>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=p>,</span> <span class=k>class</span> <span class=nc>WeightType</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ShortestPathDij</span><span class=p>(</span><span class=k>const</span> <span class=n>AdjListDirNetwork</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=p>,</span> <span class=n>WeightType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>g</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v0</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=n>WeightType</span> <span class=o>*</span><span class=n>dist</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>WeightType</span> <span class=n>minVal</span><span class=p>,</span> <span class=n>infinity</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>GetInfinity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>v</span><span class=p>,</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=c1>//初始化dist和path数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>GetWeight</span><span class=p>(</span><span class=n>v0</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>==</span> <span class=n>infinity</span><span class=p>)</span>   <span class=n>path</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>path</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>v0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>UNVISITED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>v0</span><span class=p>,</span> <span class=n>VISITED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>	 <span class=c1>//找n-1个终点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>minVal</span><span class=o>=</span><span class=n>infinity</span><span class=p>;</span>     
</span></span><span class=line><span class=cl>        <span class=n>u</span><span class=o>=</span><span class=n>v0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span> <span class=c1>//找最短的路径
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>g</span><span class=p>.</span><span class=n>GetTag</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>==</span> <span class=n>UNVISITED</span> <span class=o>&amp;&amp;</span> <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>minVal</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>	  		<span class=n>u</span><span class=o>=</span><span class=n>v</span><span class=p>;</span> 	
</span></span><span class=line><span class=cl>       		<span class=n>minVal</span><span class=o>=</span><span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>    	<span class=n>g</span><span class=p>.</span><span class=n>SetTag</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>VISITED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>//对u的邻接点，修改路径和路径长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>FirstAdjVex</span><span class=p>(</span><span class=n>u</span><span class=p>);</span> <span class=n>v</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>v</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>NextAdjVex</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>g</span><span class=p>.</span><span class=n>GetTag</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>==</span> <span class=n>UNVISITED</span> <span class=o>&amp;&amp;</span> <span class=n>minVal</span> <span class=o>+</span> <span class=n>g</span><span class=p>.</span><span class=n>GetWeight</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    	<span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>minVal</span> <span class=o>+</span> <span class=n>g</span><span class=p>.</span><span class=n>GetWeight</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    	<span class=n>path</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>  	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=52bellnam-ford算法>5.2 Bellnam-Ford算法<a hidden class=anchor aria-hidden=true href=#52bellnam-ford算法>#</a></h3><p>用邻接矩阵作为存储结构，时间复杂度为O(n^3)</p><p>问题的解决：</p><p>​ 贝尔曼（Bellnam）和福特（Ford）提出了从源点逐次经过其它顶点，以缩短到达终点的最短路径长度的方法。该方法有一个限制条件：要求图中不能有路径长度为负值的回路。</p><p>​ 当图中没有路径长度为负值的回路时，有n个顶点的图中任意两个顶点之间如果存在最短路径，此路径最多有n-1条弧。</p><p>构造一个最短路径长度的数组序列：dist1[]、dist2[]、…、distn-1[]。
dist1[u]表示从源点v0直接到终点u的最短路径的长度，即dist1[u]＝Arcs[v0] [u]；
dist2[u]表示从源点v0出发最多经过两条弧（一个中间顶点）到达终点u的最短路径的长度，
…，
distk[u]是从源点v0出发最多经过不构成带负长度回路的k条弧（k-1个中间顶点）到达终点u的最短路径的长度。
算法的结果就是计算出distn-1[u]。
思考：
（1）dist维数？
（2）能否用二维数组表示dist？
（3）dist值如何变化？</p><p>可以用递推方式计算distn-1[]。设已经求出distk-1[i]，i＝0，1，…，n-1，此即从源点v0出发最多经过不构成带负长度回路的k-1条到达终点i的最短路径的长度。
从图的邻接矩阵中可以找到从任一顶点i直接到达另一顶点u的距离Arcs[i] [u]，利用递推公式：
dist1[u]＝Arcs [v0] [u]；
distk[u]=min{ distk-1[u] ，min{ distk-1[i]+ Arcs[i] [u]}}</p><h4 id=算法图解>算法图解<a hidden class=anchor aria-hidden=true href=#算法图解>#</a></h4><h4 id=c代码><strong>C++代码</strong><a hidden class=anchor aria-hidden=true href=#c代码>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=p>,</span> <span class=k>class</span> <span class=nc>WeightType</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ShortestPathBellmanFord</span><span class=p>(</span><span class=k>const</span> <span class=n>AdjListDirNetwork</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=p>,</span><span class=n>WeightType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>g</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v0</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=n>WeightType</span> <span class=o>*</span><span class=n>dist</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>WeightType</span> <span class=o>*</span><span class=n>distTemp</span><span class=p>,</span> <span class=n>minVal</span><span class=p>,</span> <span class=n>infinity</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>GetInfinity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>v</span><span class=p>,</span> <span class=n>u</span><span class=p>,</span> <span class=n>vexNum</span><span class=o>=</span><span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>distTemp</span><span class=o>=</span><span class=k>new</span> <span class=n>WeightType</span><span class=p>[</span><span class=n>vexNum</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>vexNum</span><span class=p>;</span> <span class=n>v</span><span class=o>++</span><span class=p>){</span>	<span class=c1>// 初始化path和dist
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=p>(</span><span class=n>v0</span> <span class=o>!=</span> <span class=n>v</span><span class=p>)</span> <span class=o>?</span> <span class=n>g</span><span class=p>.</span><span class=n>GetWeight</span><span class=p>(</span><span class=n>v0</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>       <span class=k>if</span> <span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>==</span> <span class=n>infinity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>path</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>       <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>path</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>v0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span> <span class=kt>int</span>  <span class=n>k</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>vexNum</span> <span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>	 <span class=c1>// 根据递推公式求dist[k]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>vexNum</span><span class=p>;</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=n>distTemp</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>];</span>			 <span class=c1>// 放dist[k]
</span></span></span><span class=line><span class=cl><span class=c1></span>     	<span class=k>for</span> <span class=p>(</span><span class=n>u</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>u</span> <span class=o>&lt;</span> <span class=n>vexNum</span> <span class=p>;</span> <span class=n>u</span><span class=o>++</span><span class=p>)</span> 	 <span class=c1>// u列
</span></span></span><span class=line><span class=cl><span class=c1></span>      	    <span class=k>if</span> <span class=p>(</span><span class=n>u</span> <span class=o>!=</span> <span class=n>v0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       	        <span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>vexNum</span><span class=p>;</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span> 	 <span class=c1>// v行
</span></span></span><span class=line><span class=cl><span class=c1></span>        		<span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>!=</span> <span class=n>v0</span> <span class=o>&amp;&amp;</span> <span class=n>distTemp</span><span class=p>[</span><span class=n>u</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>                                         <span class=o>&gt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>+</span> <span class=n>g</span><span class=p>.</span><span class=n>GetWeight</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>u</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>             	     <span class=n>distTemp</span><span class=p>[</span><span class=n>u</span><span class=p>]</span><span class=o>=</span> <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>+</span><span class=n>g</span><span class=p>.</span><span class=n>GetWeight</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>u</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            	     <span class=n>path</span><span class=p>[</span><span class=n>u</span><span class=p>]</span><span class=o>=</span><span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>     	<span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>vexNum</span><span class=p>;</span> <span class=n>v</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    		<span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>distTemp</span><span class=p>[</span><span class=n>v</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=53floyd算法>5.3 Floyd算法<a hidden class=anchor aria-hidden=true href=#53floyd算法>#</a></h3><p>时间复杂度：O(n^3)</p><p>​ 所有顶点对之间的最短路径是指：对于给定的有向网G=(V,E)，要对G中任意一对顶点有序对V、W(V≠W)，找出V到W的最短距离和W到V的最短距离。</p><p>b站视频传送：https://www.bilibili.com/video/BV1LE411R7CS/?spm_id_from=333.337.search-card.all.click</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/05/upgit_20230503_1683108630.png alt=image-20230503181028469></p><h4 id=基本思想><strong>基本思想</strong><a hidden class=anchor aria-hidden=true href=#基本思想>#</a></h4><pre tabindex=0><code>设n×n方阵序列A(k)（k=0、1、……、n-1）。
	  A (k)[i][i] = 0; // 对角线的矩阵元素都等于0
	  A(k)[i][j]：//从顶点i到顶点j经过的中间顶点序号不超过k的
			 	 // 最短有向路径长度
	  初始： A(-1) [i][j] = Arcs [i][j];
	  Steps:  逐步尝试在原路径中依次加入其它顶点作为中间顶点。如果增加中间顶点后，得到的路径长度比原来的路径长度减少了，则以此新路径代替原路径，并修改相应的矩阵元素，代入新的更短的路径长度。
</code></pre><h4 id=求最短路径步骤><strong>求最短路径步骤</strong><a hidden class=anchor aria-hidden=true href=#求最短路径步骤>#</a></h4><pre tabindex=0><code>初始时设置一个n阶方阵a，令其对角线元素为0，若存在弧&lt;Vi,Vj&gt;，则对应元素a[i][j]为权值, 即A (0)[i][j] = arcs[i][j] ；否则a[i][j]为∞。
逐步试着在原直接路径中增加中间顶点，若加入中间点后路径变短，则修改之；否则，维持原值。具体做法为：
	(1)让所有边上加入中间顶点1，取a[i][j]与a[i][1]+a[1][j]中较小的值作a[i][j]的值，完成后得到A(1)
	(2)让所有边上加入中间顶点2，取a[i][j]与a[i][2]+a[2][j]中较小的值，完成后得到A(2) 
	(3)…，如此进行下去，当第n步完成后，得到A(n)，A(n)即为我们所求结果，A(n)[i][j]表示顶点i到顶点j的最短距离。
所有顶点试探完毕，算法结束。 
</code></pre><h4 id=c代码-1><strong>C++代码</strong><a hidden class=anchor aria-hidden=true href=#c代码-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=p>,</span> <span class=k>class</span> <span class=nc>WeightType</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ShortestPathFloyd</span><span class=p>(</span><span class=k>const</span> <span class=n>AdjListDirNetwork</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=p>,</span> <span class=n>WeightType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>g</span><span class=p>,</span> <span class=kt>int</span> <span class=o>**</span><span class=n>path</span><span class=p>,</span> <span class=n>WeightType</span> <span class=o>**</span><span class=n>dist</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>u</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>u</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>u</span><span class=o>++</span><span class=p>)</span>    <span class=c1>//初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>v</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>dist</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=p>(</span><span class=n>u</span> <span class=o>!=</span> <span class=n>v</span><span class=p>)</span> <span class=o>?</span> <span class=n>g</span><span class=p>.</span><span class=n>GetWeight</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>u</span> <span class=o>!=</span> <span class=n>v</span> <span class=o>&amp;&amp;</span> <span class=n>dist</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetInfinity</span><span class=p>())</span> <span class=n>path</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>   <span class=n>path</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span><span class=o>=-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>     <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>	 <span class=c1>//求A(k)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>	<span class=c1>//加入k为中间顶点
</span></span></span><span class=line><span class=cl><span class=c1></span>	     <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>.</span><span class=n>GetVexNum</span><span class=p>();</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		  <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>];</span> 
</span></span><span class=line><span class=cl>          <span class=n>path</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>path</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=6活动网络-active-network>6. 活动网络, Active Network<a hidden class=anchor aria-hidden=true href=#6活动网络-active-network>#</a></h2><h3 id=61用顶点表示的活动网络-aovactivity-on-vertex>6.1 用顶点表示的活动网络 AOV，Activity on Vertex<a hidden class=anchor aria-hidden=true href=#61用顶点表示的活动网络-aovactivity-on-vertex>#</a></h3><p>在这种有向图中，顶点表示活动，弧表示活动的次序。</p><p>AOV网络中<strong>不能出现有向回路</strong>。(意味着某项活动的开始要以自己的完成作为先决条件)</p><p><strong>拓扑排序</strong></p><p>邻接表的拓扑排序时间复杂度为O(n+e)</p><p>把AOV网络中的各个顶点，按照他们的优先次序排列成一个线性序列的过程。</p><ul><li><strong>检测AOV网中有无有向环的方法</strong>：构造其顶点的拓扑有序序列，若网中的所有顶点都在他的拓扑排序序列中，则无有向环。</li></ul><p>拓扑排序的方法：</p><ol><li>在有向图中选择一个没有前驱的结点输出</li><li>从图中删除该顶点和所有以他为尾的弧</li><li>重复上述两步，直至所有的顶点均已输出；或者当图中不存在无前驱的顶点为止。</li></ol><p>(略)</p><h3 id=62-边表示的活动网络aoe-activity-on-edges>6.2 边表示的活动网络，AOE, Activity on Edges<a hidden class=anchor aria-hidden=true href=#62-边表示的活动网络aoe-activity-on-edges>#</a></h3><p>有向边表示一个工程中的各项活动，边上的权值表示活动持续的时间(duration)。</p><p>顶点表示事件(event)，事件的发生说明在它之前的活动已完成，而在它之后的活动可以开始.</p><p>(略)</p><h1 id=五查找>五、查找<a hidden class=anchor aria-hidden=true href=#五查找>#</a></h1><p>静态查找就是只负责查找就行，动态查找不光要负责找，还要比如说查找的这个元素不存在需要补上。</p><p><strong>平均查找长度（ASL）</strong></p><p><img loading=lazy src=https://img-blog.csdnimg.cn/2019100115303868.png alt=在这里插入图片描述></p><ol><li>pi 是查找到某个元素的概率（probability）</li><li>ci 是查找到这个元素时已经比较的次数，如，查找在 10 个数中查找第 5 个数，其比较的次数是多少（包括和第 5 个数比较的次数）</li></ol><p><strong>装载因子</strong></p><p>​ 设数据表的长度为m，表中元素个数为n，则数据表的装载因子是n/m(&lt;1)</p><h2 id=51静态查找>5.1 静态查找<a hidden class=anchor aria-hidden=true href=#51静态查找>#</a></h2><h3 id=511顺序查找>5.1.1 顺序查找<a hidden class=anchor aria-hidden=true href=#511顺序查找>#</a></h3><p><strong>Sequential search</strong></p><p><strong>顺序查找特点</strong></p><p>优点：算法简单、适应面广，对表的结构或关键字是否有序无任何要求。
缺点：查找效率低，特别是当n较大时，查找效率较低，不宜采用。</p><p>查找成功的平均查找长度 ASL=(n+1)/2</p><p>查找失败的平均查找长度 ASL=n+1</p><h3 id=512二分查找折半查找>5.1.2 二分查找/折半查找<a hidden class=anchor aria-hidden=true href=#512二分查找折半查找>#</a></h3><p><strong>Binary search</strong></p><h4 id=算法要求>算法要求<a hidden class=anchor aria-hidden=true href=#算法要求>#</a></h4><p>​ （1）数据在线性表中按查找的关键字域<strong>有序排列</strong>。
​ （2）数据表是顺序存储结构。</p><h4 id=算法动图演示><strong>算法动图演示</strong><a hidden class=anchor aria-hidden=true href=#算法动图演示>#</a></h4><p><img loading=lazy src=https://img-blog.csdnimg.cn/20210313090428873.gif#pic_center alt=二分查找></p><h4 id=算法实现>算法实现<a hidden class=anchor aria-hidden=true href=#算法实现>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 折半查找的递归实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>BinarySearch</span><span class=p>(</span><span class=kt>int</span> <span class=n>elems</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>,</span> <span class=kt>int</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>low</span> <span class=o>&gt;</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>elems</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>elems</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>BinarySearch</span><span class=p>(</span><span class=n>elems</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>elems</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>BinarySearch</span><span class=p>(</span><span class=n>elems</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 折半查找的迭代实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>BinarySearch</span><span class=p>(</span><span class=kt>int</span> <span class=n>elems</span><span class=p>[],</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=kt>int</span> <span class=n>key</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>low</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>high</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>low</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>elems</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>elems</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>low</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>elems</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>high</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于<strong>有序表</strong>，还能够使用<strong>斐波那契查找</strong>和<strong>插值查找</strong></p><h4 id=拓展斐波那契查找和插值查找>拓展：斐波那契查找和插值查找<a hidden class=anchor aria-hidden=true href=#拓展斐波那契查找和插值查找>#</a></h4><h5 id=斐波那契查找>斐波那契查找<a hidden class=anchor aria-hidden=true href=#斐波那契查找>#</a></h5><p>斐波那契查找原理仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即<strong>mid=low+F(k-1)-1</strong>，（F代表斐波那契数列），如下图所示。</p><p><img loading=lazy src="https://img-blog.csdnimg.cn/20201013193626363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3V6aV9oZW5n,size_16,color_FFFFFF,t_70" alt=img></p><h5 id=插值查找>插值查找<a hidden class=anchor aria-hidden=true href=#插值查找>#</a></h5><p>插值查找的算法思想和折半查找类似，区别在于求中间位置的公式。其求中间点的公式为:</p><p><strong>Mid = low + ((key - data[low]) / (data[high] - data[low])) * (high - low)</strong></p><p>他的查找性能在关键字分布较均匀的情况下优于折半查找</p><h4 id=平均查找长度>平均查找长度<a hidden class=anchor aria-hidden=true href=#平均查找长度>#</a></h4><p><strong>成功：log2(n+1)-1,O(log2n)</strong></p><p>折半查找的二叉查找树：</p><p><img loading=lazy src=https://img-blog.csdnimg.cn/20191013224311431.gif alt=img></p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/05/upgit_20230530_1685418168.jpg alt=mmexport1685418138542></p><h2 id=52动态查找>5.2 动态查找<a hidden class=anchor aria-hidden=true href=#52动态查找>#</a></h2><h3 id=521二叉排序树>5.2.1 二叉排序树<a hidden class=anchor aria-hidden=true href=#521二叉排序树>#</a></h3><p><strong>BST, Binary Sort/Search Tree</strong></p><h4 id=1定义>1 定义<a hidden class=anchor aria-hidden=true href=#1定义>#</a></h4><p>二叉排序/搜索树或者是一棵空树，或者是具有下列性质的二叉树：</p><ol><li>左子树(如果存在)上所有结点的关键字都小于根结点的关键字。</li><li>右子树(如果存在)上所有结点的关键字都大于根结点的关键字。</li><li>左子树和右子树也是二叉排序树。</li></ol><h4 id=2二叉排序树上的查找>2 二叉排序树上的查找<a hidden class=anchor aria-hidden=true href=#2二叉排序树上的查找>#</a></h4><p><strong>算法性能分析</strong></p><p>当二叉排序树是<strong>完全二叉树</strong>时，其<strong>平均查找性能最佳</strong>为<strong>log2n</strong>，与有序表的折半查找相同。</p><p>当二叉排序树退化为一棵单支树时，二叉排序树的平均查找性能最差为：<strong>（n+1）/2</strong>，与<strong>顺序表的平均查找长度相同</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>BinarySortTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>Find</span><span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>f</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=c1>// 操作结果: 求指向关键字为key的数据元素的指针,用f返回其双亲
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>BinTreeNode</span><span class=o>&lt;</span> <span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>GetRoot</span><span class=p>();</span>	<span class=c1>// 指向当前结点
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>f</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>								<span class=c1>// 指向p的双亲
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>!=</span> <span class=n>key</span><span class=p>)</span>	<span class=p>{</span>	<span class=c1>// 查找关键字为key的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span>	<span class=p>{</span>				<span class=c1>// key更小,在左子树上进行查找
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>f</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>{</span>								<span class=c1>// key更大,在右子树上进行查找
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>f</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=3二叉排序树上的插入>3 二叉排序树上的插入<a hidden class=anchor aria-hidden=true href=#3二叉排序树上的插入>#</a></h4><p>1.方法</p><ul><li><p>先搜索BST中有无该结点，只有无才插入</p></li><li><p>插入是作为叶子插入，插入后仍满足BST</p></li><li><p>插入位置应是搜索操作停止 的地方(在进行查找之后，f指针指向的就是需要插入的位置)</p></li></ul><p>2.算法实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>BinarySortTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>Insert</span><span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>Find</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>f</span><span class=p>)</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;*</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>	  	
</span></span><span class=line><span class=cl>			<span class=n>root</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>e</span> <span class=o>&lt;</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span>	
</span></span><span class=line><span class=cl>			<span class=n>f</span><span class=o>-&gt;</span><span class=n>leftChild</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>		
</span></span><span class=line><span class=cl>			<span class=n>f</span><span class=o>-&gt;</span><span class=n>rightChild</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=4二叉排序树上的删除>4 二叉排序树上的删除<a hidden class=anchor aria-hidden=true href=#4二叉排序树上的删除>#</a></h4><p><strong>原则</strong></p><ul><li><p>删除结点所断开的链要重新接起来[保持树性质]</p></li><li><p>删除链接后仍是BST[保持排序/搜索性质]</p></li><li><p><strong>重新链接后树的高度不增加</strong>[保证效率]</p></li></ul><p><strong>方法</strong></p><ul><li><p>被删结点为叶子，只需将双亲结点的相应指针置为空</p></li><li><p>被删结点无右子树，拿左孩子结点顶替它的位置</p></li><li><p>被删结点无左子树，拿右孩子结点顶替它的位置</p></li><li><p>被删结点左右子树都有，有两种处理方法：</p><ul><li>在他的左子树中寻找中序遍历的最后一个（关键字最大，一定没有右孩子），将他的值赋给目标删除的结点，再删去这个叶子；</li><li>在他的右子树中寻找中序遍历的第一个结点（关键字最小，一定没有左孩子），将他的值赋给目标删除节点，再删去这个叶子。</li></ul></li></ul><p><strong>算法实现</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinarySortTree</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>Delete</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 操作结果: 删除p指向的结点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>tmpPtr</span><span class=p>,</span> <span class=o>*</span><span class=n>tmpF</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>rightChild</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>	<span class=p>{</span>	<span class=c1>// p为叶结点
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>p</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>	<span class=p>{</span>	<span class=c1>// p只有左子树为空
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>tmpPtr</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>delete</span> <span class=n>tmpPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rightChild</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>	<span class=p>{</span>	<span class=c1>// p只有右子树非空
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>tmpPtr</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>delete</span> <span class=n>tmpPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>	<span class=p>{</span>	<span class=c1>// p左右子非空
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>tmpF</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>tmpPtr</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span> <span class=p>(</span><span class=n>tmpPtr</span><span class=o>-&gt;</span><span class=n>rightChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>	<span class=p>{</span>	<span class=c1>// 查找p在中序序列中直接前驱tmpPtr及其双亲tmpF,直到tmpPtr右子树为空
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>tmpF</span> <span class=o>=</span> <span class=n>tmpPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>tmpPtr</span> <span class=o>=</span> <span class=n>tmpPtr</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>tmpPtr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>					<span class=c1>// 将tmpPtr指向结点的数据元素值赋值给被删除结点的数据元素值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// 删除tmpPtr指向的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>tmpF</span><span class=o>-&gt;</span><span class=n>rightChild</span> <span class=o>==</span> <span class=n>tmpPtr</span><span class=p>)</span>	<span class=c1>// 删除tmpF的右孩子
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>Delete</span><span class=p>(</span><span class=n>tmpF</span><span class=o>-&gt;</span><span class=n>rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>							<span class=c1>// 删除tmpF的左孩子
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>Delete</span><span class=p>(</span><span class=n>tmpF</span><span class=o>-&gt;</span><span class=n>leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=522平衡二叉树>5.2.2 平衡二叉树<a hidden class=anchor aria-hidden=true href=#522平衡二叉树>#</a></h3><p>AVL树</p><h4 id=1定义-1>1 <strong>定义</strong><a hidden class=anchor aria-hidden=true href=#1定义-1>#</a></h4><p>又称AVL树, 或是空树、或是具有下列性质的二叉树：
它的左子树和右子树都是平衡二叉树，<strong>且左子树和右子树的深度之差的绝对值不超过1</strong>。</p><p><strong>平衡因子（balance factor,BF）：</strong></p><p><strong>结点右子树高度减去左子树高度所得高度差</strong>
AVL树中结点的平衡因子值只能是-1，0，1
AVL树的ASL可保持在O(log2n)</p><h4 id=2平衡旋转><strong>2 平衡旋转</strong><a hidden class=anchor aria-hidden=true href=#2平衡旋转>#</a></h4><p><strong>LL：顺时针</strong></p><p><strong>RR：逆时针</strong></p><p><strong>LR：逆时针，顺时针</strong></p><p><strong>RL：顺时针，逆时针</strong></p><h5 id=21ll平衡旋转右单旋转>2.1 LL平衡旋转—右单旋转<a hidden class=anchor aria-hidden=true href=#21ll平衡旋转右单旋转>#</a></h5><p>如果在A的左孩子B的左子树插入了新的结点，使A的平衡因子从-1变到了-2，则需要进行LL旋转。</p><h5 id=22rr平衡旋转左单旋转>2.2 RR平衡旋转—左单旋转<a hidden class=anchor aria-hidden=true href=#22rr平衡旋转左单旋转>#</a></h5><p>如果在A的右孩子B的右子树插入了新的结点，使A的平衡因子从1变到了2，则需要进行RR旋转。</p><h5 id=23lr平衡旋转先左后右双旋转>2.3 LR平衡旋转—先左后右双旋转<a hidden class=anchor aria-hidden=true href=#23lr平衡旋转先左后右双旋转>#</a></h5><p>如果在A的左孩子B的右子树插入了新的结点，使A的平衡因子从-1变到了-2，则需要进行LR旋转。</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/05/upgit_20230530_1685423595.jpg alt=0101d5598faef26ef7875983a123e4d></p><h5 id=24rl平衡旋转先右后左双旋转>2.4 RL平衡旋转—先右后左双旋转<a hidden class=anchor aria-hidden=true href=#24rl平衡旋转先右后左双旋转>#</a></h5><p>如果在A的右孩子B的左子树插入了新的结点，使A的平衡因子从1变到了2，则需要进行RL旋转。</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/05/upgit_20230530_1685423602.jpg alt=04ab8a5ea538cb2e064537cc4a6e034></p><h4 id=3平衡二叉树的插入><strong>3 平衡二叉树的插入</strong><a hidden class=anchor aria-hidden=true href=#3平衡二叉树的插入>#</a></h4><ol><li>平衡二叉树插入结点的算法思想
（1）按二叉排序树的性质插入结点。
（2）如果插入结点之后出现不平衡的结点，则继续步骤（3）；否则插入完成。
（3）找到失去平衡的最小子树。
（4）判断平衡旋转的类型作相应平衡化处理。</li><li>关键问题
（1）发现“不平衡的结点”；
（3）确定“<strong>失去平衡的最小子树</strong>”；
（4）判断“平衡旋转的类型”。</li></ol><p>例题 依次插入{11,39,23,68,85,8,3,46,27,50}，过程如图：</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/05/upgit_20230531_1685542857.jpg alt=96cea284529a8f933cc427d2b3851e4></p><h4 id=4平衡二叉树的删除><strong>4 平衡二叉树的删除</strong><a hidden class=anchor aria-hidden=true href=#4平衡二叉树的删除>#</a></h4><p>4.1 平衡二叉树删除结点的算法思想</p><ul><li>​ 如果被删结点x是叶子；</li><li>​ 如果被删结点x只有一个孩子；</li><li>​ 如果被删结点x有左、右孩子</li></ul><p>4.2 如何知道是否破坏了平衡？</p><p>用布尔变量shorter来记录子树的高度是否被缩短
从结点x的双亲到根结点的路径上的每一个结点的shorter为true时，根据以下三种不同的情况操作，<strong>直到shorter为false。</strong></p><p>（1）情况一：
结点p的平衡因子为0，如果它的左子树或右子树被缩短（shorter的值为true），则它的平衡因子改为1或-1，由于此时以结点p为根的子树高度没有缩短，所以置shorter的值为false。如图a</p><p>（2）情况二：
结点p的平衡因子不为0，且其较高的子树被缩短，则P的平衡因子改为0。由于此时以结点p为根的子树高度被缩短，所以shorter的值仍为true。如图b</p><p>（3）情况三：</p><p>​ 结点p的平衡因子不为0，且较矮的子树又被缩短，则在结点p发生不平衡。此时，将进行平衡化旋转来恢复平衡。</p><p>​ ①如果q的平衡因子为0，则只要执行一个单旋转就可恢复结点p的平衡，由于旋转后被处理子树的高度没有缩短，所以置shorter的 值为false；如图c</p><p>​ ②如果q的平衡因子与p的平衡因子相同，则只要执行一个单旋转就可恢复结点p的平衡。由于此时被处理子树的高度被缩短，所以 shorter的值仍为true。最后，结点p和q的平衡因子均改为0。如图d</p><p>​ ③如果p与q的平衡因子的符号相反，则需要执行一个双旋转来恢复平衡，先围绕q转、再围绕p转。由于此时被处理子树的高度被缩 短，所以shorter的值仍为true，新的根结点的平衡因子置为0，其它结点的平衡因子作相应处理。如图e</p><p><strong>平衡二叉树删除结点 小结</strong></p><ul><li>p= 0； 无影响； shorter=false</li><li>p=±1； 删较高子树结点； p=0，shorter=true</li><li>p=±1； 删较矮子树结点； p不平衡：</li></ul><p>​ ① q=0； 单旋转； shorter=false</p><p>​ ② p，q同号； 单旋转； shorter=true</p><p>​ ③ p，q异号； 双旋转； shorter=true</p><h3 id=523b-树>5.2.3 B-树<a hidden class=anchor aria-hidden=true href=#523b-树>#</a></h3><h4 id=1动态的m路查找树>1 动态的m路查找树<a hidden class=anchor aria-hidden=true href=#1动态的m路查找树>#</a></h4><p>结点的格式为（n,p0,k1,p1,k2,p2,&mldr;,kn,pn）</p><p>如结点A的格式为：（2,b,20,c,40,a）</p><p><img loading=lazy src="https://img-blog.csdnimg.cn/31e356e053ac4a25b1b95c91b0fdeddc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57Sg6ZSm5rWB5bm044Gk,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=3路查找树></p><p>如果要查找关键字为35的数据元素，就要先从根开始，沿着20~40找到结点c，读入结点c再沿着25~30找到结点e，读入结点e在其中找到35.</p><h4 id=2b-树>2 B-树<a hidden class=anchor aria-hidden=true href=#2b-树>#</a></h4><h5 id=定义>定义<a hidden class=anchor aria-hidden=true href=#定义>#</a></h5><p>一颗m阶的B-树是一颗平衡的m路查找树，具有以下特性：</p><ul><li>根节点至少有两个孩子；</li><li>除根结点以外的所有结点（不包括失败结点）至少都有⌈m/2⌉个孩子；</li><li>所有的失败结点都在同一层上。</li></ul><p>B-树中的每个非失败结点的关键字个数都在（⌈m/2⌉-1）~（m-1），超出这个范围就需要分裂（插入操作），低于这个范围需要合并（删除操作）</p><h5 id=b-树的插入>B-树的插入<a hidden class=anchor aria-hidden=true href=#b-树的插入>#</a></h5><p>结点分裂的方法：<strong>取这个关键字数组的中间关键字作为新的结点，然后其他关键字作为新结点的左右孩子。</strong></p><p>查找过程还是和二叉排序树一样的，插的位置也差不多。</p><p><strong>实例:</strong> 跟据关键字{20、30、50、52、60、69、70}，创建一棵3阶B树
由于m=3，所以除了根结点以外，非叶子结点至少有⌈3/2⌉-1个关键字，至多有3-1=2个关键字，所以</p><h5 id=b-树的删除>B-树的删除<a hidden class=anchor aria-hidden=true href=#b-树的删除>#</a></h5><p>概念: B树中的删除操作与插入操作类似，但要复杂一些，要使得删除后的结点中关键字个数≥⌈m/2⌉-1，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点两种情况。</p><p>①： 如果删除的关键字在终端结点上（最底层的叶子结点）:</p><ul><li>结点内关键字数量大于⌈m/2⌉-1，这时删除这个关键字不会破坏B树的定义要求，所以直接删除</li></ul><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210608151835743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NjU1MQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><ul><li>结点内关键字等于⌈m/2⌉-1，并且左右兄弟结点中存在关键字大于⌈m/2⌉-1，则去兄弟结点中借关键字</li></ul><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210608152123414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NjU1MQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><ul><li>结点内关键字等于⌈m/2⌉-1，并且左右兄弟结点中存在关键字不大于⌈m/2⌉-1，则需要进行结点合并</li></ul><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210608152427787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NjU1MQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p>②: 如果删除的关键字不在终端结点上（最底层的非叶子结点）:需要先转换成终端结点上，再按照在终端结点上的情况来分别考虑应对方法。</p><p>第一种情况:存在关键字大于⌈m/2⌉-1结点的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换成待删除的关键字</p><ul><li>何为相邻关键字:对于不在终端结点上的关键字，它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。</li><li>找出这个待删除关键字的相邻关键字，比如说下图中10的相邻关键字就是9和11，其实就是这个大小序列中该关键字的直接前驱或者直接后驱关键字。</li><li>将这个待删除关键字和某个相邻关键字互换，然后删除这个关键字</li></ul><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210607172608535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NjU1MQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p>第二种情况:左右子树的关键字数量均等于⌈m/2⌉-1，则将这两个左右子树结点合并，然后删除待删除关键字，14.</p><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210607173454414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NjU1MQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><h4 id=3b树>3 B+树<a hidden class=anchor aria-hidden=true href=#3b树>#</a></h4><p>概念:B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构</p><p>m阶的B+树与m阶的B树的主要差异在于:</p><ol><li>在B+树中，具有n个关键字的结点只含有n棵子树，即<strong>每个关键字对应一颗子树</strong>，在B树中，具有n个关键字的结点含有(n+1)棵子树。</li><li>在B+树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉-1≤n≤m-1（根结点1≤n≤m-1）。</li><li>在B+树中，<strong>叶结点包含信息，所有非叶结点仅起到索引作用</strong>，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含该关键字对应记录的存储地址。</li><li>在B+树中，<strong>叶结点包含了全部关键字</strong>，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶节点包含的关键字和其他结点包含的关键字是不重复的。</li></ol><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210608133506133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NjU1MQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><h3 id=53散列表>5.3 散列表<a hidden class=anchor aria-hidden=true href=#53散列表>#</a></h3><h4 id=1散列表的基本概念>1 散列表的基本概念<a hidden class=anchor aria-hidden=true href=#1散列表的基本概念>#</a></h4><h4 id=2散列函数>2 散列函数<a hidden class=anchor aria-hidden=true href=#2散列函数>#</a></h4><ul><li><p>直接定址法</p></li><li><p>数字分析法</p></li><li><p>除留余数法</p></li><li><p>乘余取整法</p></li></ul><h4 id=3处理冲突的方法>3 处理冲突的方法<a hidden class=anchor aria-hidden=true href=#3处理冲突的方法>#</a></h4><h5 id=31闭散列开放地址法>3.1 闭散列——开放地址法<a hidden class=anchor aria-hidden=true href=#31闭散列开放地址法>#</a></h5><p>存在的问题：在闭散列的情形下不能随便物理地删除表中的数据，因为会影响表中其他元素的查找。如果散列表经常变动，就是用开散列的方法来处理哈希冲突。</p><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210123121720355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1MTk5OQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><ul><li><strong>线性探测法</strong></li></ul><p>​ 每当发生冲突，就探测下一个桶。当循环m-1次之后就会回到开始探测时的位置，说明待查元素不在表中，而且表已满，不能再进行插入。</p><p>​ 线性探测法容易产生“堆积”的问题，改进：二次探测法。</p><ul><li><strong>二次探测法</strong></li></ul><p>​ 在发生冲突的时候，寻找下一个空桶的公式为：Hi=（H0+di+m）%m，式中di=1^2,-1^2,2^2,-2^2,&mldr;(i-1,2,&mldr;,<strong>(m-1)/2)</strong>；H0=hash(key)，他是通过某一个hash函数对数据元素的关键字key进行计算得到的桶号，是一个非负整数，m是表的大小。</p><p>​ 举例：</p><p>​ 当出现哈希冲突的时候，使用二次探测，H=hash(H0+1)，H=hash(H0-1)，H=hash(H0+4)，&mldr;，一直到找到，或者<strong>探测到空</strong>，或者是 i = (m-1)/2</p><p>​ 当表的长度为质数，且表的装载因子不超过0.5时，新的数据元素一定能够插入到散列表中。</p><ul><li><strong>双散列法</strong></li></ul><p>​ 该方法需要两个散列函数进行实现。第一个散列函数按照数据元素的关键字key计算出数据元素存放的桶号；当发生冲突的时候，使用第二个散列函数计算下一个空桶的位移量，他的取值和key的值有关，且与表的大小互质。</p><h5 id=32开散列链地址法>3.2 开散列——链地址法<a hidden class=anchor aria-hidden=true href=#32开散列链地址法>#</a></h5><p><img loading=lazy src="https://img-blog.csdnimg.cn/20210123123012691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1MTk5OQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><h1 id=六排序>六、排序<a hidden class=anchor aria-hidden=true href=#六排序>#</a></h1><p>排序思想、排序过程、排序算法、排序性能、每种算法的优缺点</p><p><img loading=lazy src=https://raw.githubusercontent.com/sirius2alpha/Typora-pics/master/2023/05/upgit_20230529_1685348972.png alt=image-20230529162930305></p><h2 id=各个排序算法的性能比较><strong>各个排序算法的性能比较</strong><a hidden class=anchor aria-hidden=true href=#各个排序算法的性能比较>#</a></h2><p>稳定的排序算法：冒泡、插入、归并、基数</p><p>空间复杂度：</p><p>​ 归并排序是O(n)</p><p>​ 快速排序是O(logn)</p><p>​ 基数排序是O(radix)</p><p>时间复杂度为O(nlogn)：希尔、归并、快速、堆排序</p><p>时间复杂度为O(n^2)：冒泡、选择、插入</p><h2 id=交换排序>交换排序<a hidden class=anchor aria-hidden=true href=#交换排序>#</a></h2><h3 id=1冒泡排序>1 冒泡排序<a hidden class=anchor aria-hidden=true href=#1冒泡排序>#</a></h3><h4 id=排序性能和优缺点>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点>#</a></h4><p>时间复杂度：最坏情况：O(N^2)
      最好情况：O(N)
空间复杂度：O(1)</p><p>稳定性：稳定</p><h4 id=排序思想>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想>#</a></h4><p>左边大于右边就交换，一趟排下来最大的在右边</p><h4 id=排序过程>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程>#</a></h4><p><img loading=lazy src=https://img-blog.csdnimg.cn/20210509190446264.gif#pic_center alt=冒泡排序过程></p><h4 id=排序算法>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//冒泡排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>BubbleSort</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>arr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>end</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>			<span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=kt>int</span> <span class=n>tem</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>				<span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>				<span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>tem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>flag</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=o>--</span><span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=2快速排序>2 快速排序<a hidden class=anchor aria-hidden=true href=#2快速排序>#</a></h3><h4 id=排序性能和优缺点-1>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-1>#</a></h4><p>时间复杂度：平均情况：O(nlogn)</p><p>​ 最坏情况：O(n^2)
      最好情况：O(nlogn)
空间复杂度：O(logn)</p><p>稳定性：不稳定</p><h4 id=排序思想-1>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-1>#</a></h4><p>特点：排完一趟之后，那个元素就已经处于最后的位置了。</p><p>递归的过程；</p><p>任取数据表中的某个数据作为基准值，将整个数据表划分为比基准值大的和比他小的；</p><p>重复对左右子表执行上述过程，直到所有子表的长度为1.</p><h4 id=排序过程-1>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-1>#</a></h4><h4 id=排序算法-1>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 快速排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>QuickSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>left</span><span class=p>,</span> <span class=kt>int</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>left</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>right</span><span class=p>,</span> <span class=n>x</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>left</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span> <span class=o>&amp;&amp;</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span> <span class=o>&amp;&amp;</span> <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=o>--</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>QuickSort</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>QuickSort</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=插入排序>插入排序<a hidden class=anchor aria-hidden=true href=#插入排序>#</a></h2><h3 id=3直接插入排序>3 直接插入排序<a hidden class=anchor aria-hidden=true href=#3直接插入排序>#</a></h3><h4 id=排序性能和优缺点-2>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-2>#</a></h4><p>时间复杂度：</p><p>​ 平均：O(n^2)</p><p>​ 最好：O(n)</p><p>​ 最坏：O(n^2)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><h4 id=排序思想-2>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-2>#</a></h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id=排序过程-2>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-2>#</a></h4><h4 id=排序算法-2>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 插入排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>InsertSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>elems</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>elems</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>elems</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>temp</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>elems</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>elems</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>elems</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=改进折半插入排序>改进： 折半插入排序<a hidden class=anchor aria-hidden=true href=#改进折半插入排序>#</a></h4><h5 id=排序思想-3>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-3>#</a></h5><p>在插入elem[i]的时候，先利用折半查找寻找elem[i]的插入位置，然后把插入位置后面的元素依次后移一个元素空间，最后把elem[i]插入到对应位置。</p><h3 id=4希尔排序>4 希尔排序<a hidden class=anchor aria-hidden=true href=#4希尔排序>#</a></h3><h4 id=排序性能和优缺点-3>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-3>#</a></h4><p>时间复杂度：</p><p>​ 平均：O(nlogn)</p><p>​ 最好：O(nlog^2n)</p><p>​ 最坏：O(nlog^2n)</p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><h4 id=排序思想-4>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-4>#</a></h4><p>希尔排序又叫缩小增量排序。</p><ul><li>首先取一个整数d&lt;n作为间隔，将全部元素分成d个组，在每一个组中进行直接插入排序；</li><li>缩小d的值，重新分组，重新做直接插入排序；</li><li>直到d=1，将所有元素放在一个组中进行直接插入排序。</li></ul><h4 id=排序过程-3>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-3>#</a></h4><p><img loading=lazy src=https://img-blog.csdnimg.cn/20191028221248738.gif alt=在这里插入图片描述></p><h4 id=排序算法-3>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-3>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 希尔排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>ShellSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>elems</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>gap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>gap</span> <span class=o>=</span> <span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=n>gap</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=n>gap</span> <span class=o>/=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 在每个组中做直接插入排序
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>gap</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>elems</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=n>gap</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>elems</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>temp</span><span class=p>;</span> <span class=n>j</span> <span class=o>-=</span> <span class=n>gap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>elems</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>gap</span><span class=p>]</span> <span class=o>=</span> <span class=n>elems</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>elems</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>gap</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=选择排序>选择排序<a hidden class=anchor aria-hidden=true href=#选择排序>#</a></h2><h3 id=5简单选择排序>5 简单选择排序<a hidden class=anchor aria-hidden=true href=#5简单选择排序>#</a></h3><h4 id=排序性能和优缺点-4>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-4>#</a></h4><p>时间复杂度：</p><p>​ 平均：O(n^2)</p><p>​ 最好：O(n^2)</p><p>​ 最坏：O(n^2)</p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><h4 id=排序思想-5>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-5>#</a></h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1…n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id=排序过程-4>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-4>#</a></h4><p><img loading=lazy src=https://img-blog.csdnimg.cn/20191028220714229.gif alt=在这里插入图片描述></p><h4 id=排序算法-4>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-4>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 简单选择排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>SelectSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>elems</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>min</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>     <span class=c1>// 第i躺排序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>min</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>                    <span class=c1>// min记录最小元素下标
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>elems</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>elems</span><span class=p>[</span><span class=n>min</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>min</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>min</span> <span class=o>!=</span> <span class=n>i</span><span class=p>)</span>               <span class=c1>// 如果min不是当前元素，则交换之
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>elems</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>elems</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>elems</span><span class=p>[</span><span class=n>min</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>elems</span><span class=p>[</span><span class=n>min</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=6锦标赛排序>6 锦标赛排序<a hidden class=anchor aria-hidden=true href=#6锦标赛排序>#</a></h3><h4 id=排序性能和优缺点-5>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-5>#</a></h4><h4 id=排序思想-6>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-6>#</a></h4><h4 id=排序过程-5>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-5>#</a></h4><h4 id=排序算法-5>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-5>#</a></h4><h3 id=7堆排序>7 堆排序<a hidden class=anchor aria-hidden=true href=#7堆排序>#</a></h3><h4 id=排序性能和优缺点-6>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-6>#</a></h4><p>时间复杂度：</p><p>​ 平均：O(nlogn)</p><p>​ 最好：O(nlogn)</p><p>​ 最坏：O(nlogn)</p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><h4 id=排序思想-7>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-7>#</a></h4><ol><li>对数据表中的数据元素，利用堆的调整算法形成初始堆；</li><li>输出堆顶元素；</li><li>对剩余的元素重新调整形成堆；</li><li>重复执行2、3步，直到所有的元素都被输出。</li></ol><h4 id=排序过程-6>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-6>#</a></h4><p><img loading=lazy src=https://img-blog.csdnimg.cn/20191028221838877.gif alt=在这里插入图片描述></p><h4 id=排序算法-6>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-6>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 堆的最大堆调整算法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>FilterDown</span><span class=p>(</span><span class=kt>int</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>low</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> 			<span class=c1>// i为要调整结点，j为i的左孩子
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>         			<span class=c1>// 当前结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>                                          <span class=c1>// 沿较大的孩子结点向下筛选
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>high</span> <span class=o>&amp;&amp;</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span> <span class=c1>// 如果右孩子较大，把j指向右孩子
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>temp</span> <span class=o>&gt;=</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> 				<span class=c1>// 如果当前结点比孩子结点大，则筛选结束
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span> 									<span class=c1>// 否则，将孩子结点上移，i、j下降
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span> <span class=c1>// 回放temp中暂存的元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 堆排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>HeapSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>n</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=c1>// 建立堆
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>FilterDown</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=c1>// 交换堆顶和最后一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>elem</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>FilterDown</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span> <span class=c1>// 调整堆
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=归并排序>归并排序<a hidden class=anchor aria-hidden=true href=#归并排序>#</a></h2><p>归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id=8两路归并排序>8 两路归并排序<a hidden class=anchor aria-hidden=true href=#8两路归并排序>#</a></h3><h4 id=排序性能和优缺点-7>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-7>#</a></h4><p>时间复杂度：</p><p>​ 平均：O(nlogn)</p><p>​ 最好：O(nlogn)</p><p>​ 最坏：O(nlogn)</p><p>空间复杂度：O(n)</p><p>稳定性：<strong>稳定</strong></p><h4 id=排序思想-8>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-8>#</a></h4><p>假设初始数据表有n个数据元素，首先把它看成长度为1的归并项，先做两两归并；</p><p>得到n/2（向上取整）个归并项，再做两两归并；</p><p>直到最后得到一个长度为n的有序序列。</p><h4 id=排序过程-7>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-7>#</a></h4><p><strong>归并操作的理解</strong></p><p><img loading=lazy src=https://img-blog.csdnimg.cn/20191028221506143.gif alt=在这里插入图片描述></p><p><strong>迭代归并</strong></p><p><strong>递归归并</strong></p><h4 id=排序算法-7>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-7>#</a></h4><p>迭代方式 和 递归方式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 归并排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Merge</span><span class=p>(</span><span class=kt>int</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>temp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>high</span> <span class=o>-</span> <span class=n>low</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=c1>// 辅助空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>low</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>     <span class=c1>// i、j是两段有序序列的下标，k是temp的下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>mid</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=c1>// 两段有序序列归并
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>mid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>];</span> <span class=c1>// 复制第一段有序序列剩余部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>j</span><span class=o>++</span><span class=p>];</span> <span class=c1>// 复制第二段有序序列剩余部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>elem</span><span class=p>[</span><span class=n>low</span> <span class=o>+</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=c1>// 复制回去
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>delete</span><span class=p>[]</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 迭代实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>MergeSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>len</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>len</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Merge</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=n>len</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>len</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>len</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>Merge</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=n>len</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>len</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 递归实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>MergeSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>low</span> <span class=o>&lt;</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// 分解
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>MergeSort</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>  <span class=c1>// 求解
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>MergeSort</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Merge</span><span class=p>(</span><span class=n>elem</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span> <span class=c1>// 合并
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=基数排序>基数排序<a hidden class=anchor aria-hidden=true href=#基数排序>#</a></h2><h3 id=9链式基数排序>9 链式基数排序<a hidden class=anchor aria-hidden=true href=#9链式基数排序>#</a></h3><h4 id=排序性能和优缺点-8>排序性能和优缺点<a hidden class=anchor aria-hidden=true href=#排序性能和优缺点-8>#</a></h4><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id=排序思想-9>排序思想<a hidden class=anchor aria-hidden=true href=#排序思想-9>#</a></h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li></ul><h4 id=排序过程-8>排序过程<a hidden class=anchor aria-hidden=true href=#排序过程-8>#</a></h4><p><img loading=lazy src=https://img-blog.csdnimg.cn/20191028222453966.gif alt=基数排序></p><h4 id=排序算法-8>排序算法<a hidden class=anchor aria-hidden=true href=#排序算法-8>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;math.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=nc>Node</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 链式基数排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>RadixSort</span><span class=p>(</span><span class=n>Node</span> <span class=n>elem</span><span class=p>[],</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>d</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>radix</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rear</span><span class=p>[</span><span class=n>radix</span><span class=p>],</span> <span class=n>front</span><span class=p>[</span><span class=n>radix</span><span class=p>],</span> <span class=n>p</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>power</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>d</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>radix</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>front</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>power</span> <span class=o>=</span> <span class=kt>int</span><span class=p>(</span><span class=n>pow</span><span class=p>(</span><span class=kt>double</span><span class=p>(</span><span class=n>radix</span><span class=p>),</span> <span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>=</span> <span class=p>(</span><span class=n>elem</span><span class=p>[</span><span class=n>p</span><span class=p>].</span><span class=n>key</span> <span class=o>/</span> <span class=n>power</span><span class=p>)</span> <span class=o>%</span> <span class=n>radix</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>front</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>front</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>elem</span><span class=p>[</span><span class=n>rear</span><span class=p>[</span><span class=n>k</span><span class=p>]].</span><span class=n>next</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>rear</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span> <span class=o>=</span> <span class=n>elem</span><span class=p>[</span><span class=n>p</span><span class=p>].</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>front</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>elem</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>next</span> <span class=o>=</span> <span class=n>front</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>rear</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>k</span> <span class=o>=</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>radix</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>front</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>elem</span><span class=p>[</span><span class=n>p</span><span class=p>].</span><span class=n>next</span> <span class=o>=</span> <span class=n>front</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span> <span class=o>=</span> <span class=n>rear</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>elem</span><span class=p>[</span><span class=n>p</span><span class=p>].</span><span class=n>next</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=//localhost:1313/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li><li><a href=//localhost:1313/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a></li></ul><nav class=paginav><a class=prev href=//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/><span class=title>« Prev</span><br><span>Kubernetes学习和实践</span>
</a><a class=next href=//localhost:1313/posts/notes/languages/cpp-notes/><span class=title>Next »</span><br><span>CPP学习笔记</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2024 <a href=//localhost:1313/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>