<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sirius&#39; Blog</title>
    <link>//localhost:1313/</link>
    <description>Recent content on Sirius&#39; Blog</description>
    <image>
      <title>Sirius&#39; Blog</title>
      <url>//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>//localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.127.0</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Jun 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Auth微服务开发记录</title>
      <link>//localhost:1313/posts/notes/dev/auth%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 18 Jun 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/dev/auth%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</guid>
      <description>引入刷新令牌机制</description>
    </item>
    <item>
      <title>proto接口和RPC使用记录</title>
      <link>//localhost:1313/posts/notes/dev/proto%E6%8E%A5%E5%8F%A3%E5%92%8Crpc%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 18 Jun 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/dev/proto%E6%8E%A5%E5%8F%A3%E5%92%8Crpc%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>引入刷新令牌机制</description>
    </item>
    <item>
      <title>MongoDB快速上手</title>
      <link>//localhost:1313/posts/notes/database/mongodb%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/database/mongodb%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</guid>
      <description>MongoDB安装 MongoDB官方的安装指南
Navicat客户端使用 可以在navicat上连上本地的mongodb使用，直观简单
Easy use (Terminal) 在终端中启动mongodb终端：
mongosh 以下是一些 MongoDB 的简单常用命令，可以帮助你快速上手并管理 MongoDB 数据库：
启动 MongoDB shell mongo 基本数据库操作 列出所有数据库 show dbs 切换到指定数据库（如果数据库不存在则创建新数据库） use mydatabase 显示当前数据库 db 删除当前数据库 db.dropDatabase() 集合操作 创建集合 db.createCollection(&amp;#39;mycollection&amp;#39;) 列出所有集合 show collections 删除集合 db.mycollection.drop() 文档操作 插入文档 db.mycollection.insertOne({name: &amp;#34;John&amp;#34;, age: 30}) db.mycollection.insertMany([{name: &amp;#34;Alice&amp;#34;, age: 25}, {name: &amp;#34;Bob&amp;#34;, age: 27}]) 查找文档 db.mycollection.find() db.mycollection.find({name: &amp;#34;John&amp;#34;}) 查找并格式化输出 db.mycollection.find().pretty() 更新文档 db.mycollection.updateOne({name: &amp;#34;John&amp;#34;}, {$set: {age: 31}}) db.mycollection.updateMany({name: &amp;#34;Alice&amp;#34;}, {$set: {age: 26}}) 替换文档 db.mycollection.replaceOne({name: &amp;#34;John&amp;#34;}, {name: &amp;#34;John&amp;#34;, age: 32, city: &amp;#34;New York&amp;#34;}) 删除文档 db.</description>
    </item>
    <item>
      <title>【go的源码阅读】channel的实现：chan.go</title>
      <link>//localhost:1313/posts/notes/go-srccode/channel/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/go-srccode/channel/</guid>
      <description>channel的简单使用 chan.go中包含的类 </description>
    </item>
    <item>
      <title>知识复习：正则表达式</title>
      <link>//localhost:1313/posts/notes/basic/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/basic/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>复习正则表达式的用法</description>
    </item>
    <item>
      <title>全国大学生市场调研大赛-数据分析</title>
      <link>//localhost:1313/posts/notes/data-analysis/wumengtrip/</link>
      <pubDate>Thu, 21 Mar 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/data-analysis/wumengtrip/</guid>
      <description>记录在正大杯中使用到的一些数据分析思路方法</description>
    </item>
    <item>
      <title>使用LaTex制作中文简历</title>
      <link>//localhost:1313/posts/notes/tools/latex_resume/</link>
      <pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/tools/latex_resume/</guid>
      <description>这篇文章记录了简单的LaTex语法，以及我修改模板的过程</description>
    </item>
    <item>
      <title>使用Selenium库爬取网易云音乐和携程旅行评论</title>
      <link>//localhost:1313/posts/notes/data-analysis/spider/</link>
      <pubDate>Wed, 14 Feb 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/data-analysis/spider/</guid>
      <description>记录使用Selenium爬取网易云和携程旅行评论的过程</description>
    </item>
    <item>
      <title>点击排行榜scoreboard</title>
      <link>//localhost:1313/posts/notes/dev/dev-%E7%82%B9%E5%87%BB%E6%8E%92%E8%A1%8C%E6%A6%9C/</link>
      <pubDate>Sun, 21 Jan 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/dev/dev-%E7%82%B9%E5%87%BB%E6%8E%92%E8%A1%8C%E6%A6%9C/</guid>
      <description>本文记录使用vue&#43;gin&#43;redis搭建了一个简单的点击排行榜，虽然有点无聊，但是两个幼稚鬼玩好好笑hhh</description>
    </item>
    <item>
      <title>在linux上配置clash，通过Dashboard控制</title>
      <link>//localhost:1313/posts/notes/network/clash-for-linux%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/network/clash-for-linux%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>记录配置clash的过程</description>
    </item>
    <item>
      <title>在docker中安装redis</title>
      <link>//localhost:1313/posts/notes/database/%E5%9C%A8docker%E4%B8%AD%E9%83%A8%E7%BD%B2redis/</link>
      <pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/database/%E5%9C%A8docker%E4%B8%AD%E9%83%A8%E7%BD%B2redis/</guid>
      <description>记录部署在docker中部署redis的过程，并使用k8s进行容器编排管理</description>
    </item>
    <item>
      <title>Ubuntu服务器命令小记</title>
      <link>//localhost:1313/posts/notes/ubuntu/%E4%B8%80%E4%BA%9B%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/ubuntu/%E4%B8%80%E4%BA%9B%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%91%BD%E4%BB%A4/</guid>
      <description>记录ubuntu用作服务器时候的一些常用命令</description>
    </item>
    <item>
      <title>内网穿透——frp和花生壳实现从外部网络访问家中主机</title>
      <link>//localhost:1313/posts/notes/network/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/network/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</guid>
      <description>记录分别使用花生壳和frp实现内网穿透</description>
    </item>
    <item>
      <title>ubuntu输入法RIME中州韵配置ibus-rime</title>
      <link>//localhost:1313/posts/notes/ubuntu/%E8%BE%93%E5%85%A5%E6%B3%95rime%E4%B8%AD%E5%B7%9E%E9%9F%B5%E9%85%8D%E7%BD%AEibus-rime/</link>
      <pubDate>Tue, 19 Dec 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/ubuntu/%E8%BE%93%E5%85%A5%E6%B3%95rime%E4%B8%AD%E5%B7%9E%E9%9F%B5%E9%85%8D%E7%BD%AEibus-rime/</guid>
      <description>记录安装配置RIME的过程</description>
    </item>
    <item>
      <title>把blog部署到华为云nginx</title>
      <link>//localhost:1313/posts/notes/dev/%E5%8D%9A%E5%AE%A2nginx%E9%83%A8%E7%BD%B2%E5%88%B0%E5%8D%8E%E4%B8%BA%E4%BA%91/</link>
      <pubDate>Sat, 16 Dec 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/dev/%E5%8D%9A%E5%AE%A2nginx%E9%83%A8%E7%BD%B2%E5%88%B0%E5%8D%8E%E4%B8%BA%E4%BA%91/</guid>
      <description>这篇文章记录了把本地的博客部署到华为云ubuntu的nginx</description>
    </item>
    <item>
      <title>Docker和K8S部署</title>
      <link>//localhost:1313/posts/notes/cloud-native/docker%E5%92%8Ck8s%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/cloud-native/docker%E5%92%8Ck8s%E9%83%A8%E7%BD%B2/</guid>
      <description>这篇文章部署K8S的过程</description>
    </item>
    <item>
      <title>hadoop部署</title>
      <link>//localhost:1313/posts/notes/cloud-native/hadoophive%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/cloud-native/hadoophive%E9%83%A8%E7%BD%B2/</guid>
      <description>这篇文章记录了在三台云服务器上部署hadoop的过程</description>
    </item>
    <item>
      <title>在云服务器上部署mysql</title>
      <link>//localhost:1313/posts/notes/database/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2mysql/</link>
      <pubDate>Thu, 30 Nov 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/database/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2mysql/</guid>
      <description>这篇文章记录了在两台主机上部署mysql</description>
    </item>
    <item>
      <title>第一次全栈开发记录</title>
      <link>//localhost:1313/posts/notes/dev/dev-%E9%80%89%E8%AF%BE%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/dev/dev-%E9%80%89%E8%AF%BE%E7%B3%BB%E7%BB%9F/</guid>
      <description>记录第一次全栈开发，主要记录了前端部分所遇到的问题</description>
    </item>
    <item>
      <title>操作系统学习笔记</title>
      <link>//localhost:1313/posts/notes/professional-classes/operating_system/</link>
      <pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/professional-classes/operating_system/</guid>
      <description>操作系统 第一章 计算机系统概述 1.1 操作系统 1.1.1 操作系统的概念和功能 概念 操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。
功能和目标 ①操作系统是系统资源的管理者 ②向上层提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。
GUI：图形化用户接口（Graphical User Interface） 用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。 例子：在Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。
联机命令接口=交互式命令接口：用户说一句，系统跟着做一句
脱机命令接口=批处理命令接口：用户说一堆，系统跟着做一堆
程序接口：可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。
如：写C语言“Hello world”程序时，在printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”
③是最接近硬件的一层软件 需要实现对硬件机器的拓展 没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统， 可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器 通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机
1.1.2 操作系统的特征 基本特征 并发、共享、虚拟、异步
并发 两个或者多个事件在同一时间间隔内发生
使得系统具有处理和调度多个程序同时执行的能力
操作系统的并发是通过分时实现的
注意：并发是指在一个时间段并行是指在同一个时刻并行是指系统具有同时执行或操作（硬件支持：多流水线或者多处理机）
重要考点
单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行
多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行
共享 互斥共享方式
例如打印机、磁带，同一时刻只能供一个进程对资源进行访问
这种资源称作：临界资源或者独占资源
同时访问方式
一段时间内允许多个进程对资源进行访问
典型代表：磁盘设备重入码编写的文件
虚拟 一个物理上的实体变为若干逻辑上的对应物，这种技术也被称为虚拟技术
虚拟处理器：采用多道程序并发的方式，让每个终端用户感觉到有多个处理器 时分复用技术
虚拟存储器：将物理存储变为虚拟存储器，逻辑上扩充存储器用 空分复用技术
也可以将一台IO设备虚拟为多台逻辑上的IO设备，并允许每个用户占用一台逻辑上的IO设备
异步 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，
多道程序走走停停，进程以不可预知的速度向前进
并发和共享的关系 并发性指计算机系统中同时存在着多个运行着的程序。 共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。
互为存在条件
并发和虚拟的关系 如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性
并发和异步的关系 只有系统拥有并发性，才有可能导致异步性。</description>
    </item>
    <item>
      <title>GNS3&#43;RIP/OSRF</title>
      <link>//localhost:1313/posts/notes/network/gns3&#43;cisco-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E9%AA%8C/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/network/gns3&#43;cisco-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E9%AA%8C/</guid>
      <description>这篇文章记录了使用GNS3软件进行动态路由实验。</description>
    </item>
    <item>
      <title>GNS3&#43;static router</title>
      <link>//localhost:1313/posts/notes/network/gns3%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E9%AA%8C/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/network/gns3%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E9%AA%8C/</guid>
      <description>这篇文章记录了使用GNS3软件进行静态路由实验</description>
    </item>
    <item>
      <title>常用的网络命令</title>
      <link>//localhost:1313/posts/notes/network/network-commands/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/network/network-commands/</guid>
      <description>ipconfig, ifconfig, ip ipconfig是windows中的命令，linux上是ifconfig，但ip命令比ifconfig更强大，旨在取代ifconfig命令。
ping ping命令是DOS命令，一般用于检测网络是否通畅以及网络连接速度，结果只越大，说明速度越慢。它使用网络层的ICMP协议。
ping [参数选项] [主机名或IP地址] linux 参数 含义 -c 设置完成要求回应的次数 -i 指定收发信息的间隔时间 -s 设置数据包的大小 -w 在设定的秒后退出 windows 参数 含义 -t 连续对IP地址执行ping命令，直到用户以&amp;lt;control+c&amp;gt;键强制中断 -l 指定ping命令的数据长度 -n 执行特定次数的ping命令 netstat netstat 用来查看当前操作系统的网络连接状态、路由表、接口统计等信息，来自于 net-tools 工具包，ss 是 netstat 的升级版。
参数 含义 -a 显示主机中所有活动的网络连接信息 (包括监听、非监听状态的服务端口) -n 以数字的形式显示相关的主机地址、端口等信息 -p 显示与网络连接相关联的进程号、进程名称信息 (该选项需要 root 权限) -l 显示处于监听 (Listen) 状态的网络连接及端口信息 -t 查看 TCP (Transmission Control Protocol，传输控制协议) 相关的信息 -u 显示 UDP (User Datagram Protocol，用户数据报协议) 协议相关的信息 -r 显示路由表信息 -i 显示网卡列表 -g 显示组播组的关系 -s 显示网络统计信息 常用命令选项：</description>
    </item>
    <item>
      <title>SQL学习笔记</title>
      <link>//localhost:1313/posts/notes/database/sql/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/database/sql/</guid>
      <description>导出数据库为sql文件，在命令行中执行：
mysqldump -u root -p course-system &amp;gt; course-system.sql DDL(Data Definition Language)数据定义语言 操作库 -- 创建库 create database db1; -- 创建库是否存在，不存在则创建 create database if not exists db1; -- 查看所有数据库 show databases; -- 查看某个数据库的定义信息 show create database db1; -- 修改数据库字符信息 alter database db1 character set utf8; -- 删除数据库 drop database db1; -- 使用某一数据库 use db1; 操作表 -- 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); -- 查看表结构 desc 表名; -- 查看创建表的SQL语句 show create table 表名; -- 修改表名 alter table 表名 rename to 新的表名; -- 添加一列 alter table 表名 add 列名 数据类型; -- 删除列 alter table 表名 drop 列名; -- 删除表 drop table 表名; drop table if exists 表名 ; DML(Data Manipulation Language)数据操作语言 增加 insert into -- 写全所有列名 insert into 表名(列名1,列名2,.</description>
    </item>
    <item>
      <title>计算机网络期末复习</title>
      <link>//localhost:1313/posts/notes/network/network-review/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/network/network-review/</guid>
      <description>https://www.yuque.com/docs/share/a0aff20d-44da-46c6-a65a-67e69dd0c6f3?# 《基于cch的计网复习》划了上次考点
题型：判断 选择 填空 计算题
复习课 拍照 中英文 英文缩写 英文全称 中文 TDM Time Division Multiplexing 时分复用 CDMA Code Division Multiple Access 码分多址 CSMA/CD Carrier Sense Multiple Access with Collision Detection 载波监听 多点接入 / 碰撞检测 MAC Medium Access Control 媒体接入控制 RTT Round Trip Time 往返时间 ARP Address Resolution Protocol 地址解析协议 IP Internet Protocol 网际协议 ICMP Internet Control Message Protocol 网际控制报文协议 TCP Transmission Control Protocol 传输控制协议 UDP User Datagram Protocol 用户数据报协议 RIP Routing Information Protocol 路由信息协议 BGP Border Gateway Protocol 边界网关协议 OSPF Open Shortest Path First 开放最短路径优先 VLAN Virtual Local Area Network 虚拟局域网 DNS Domain Name System 域名系统 知识点 语雀知识点链接：https://www.</description>
    </item>
    <item>
      <title>mysql用户被锁定</title>
      <link>//localhost:1313/posts/notes/problems/mysql-user-was-blocked/</link>
      <pubDate>Tue, 10 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/problems/mysql-user-was-blocked/</guid>
      <description>突然发现root账户莫名其妙登不上去</description>
    </item>
    <item>
      <title>Ubuntu使用记录</title>
      <link>//localhost:1313/posts/notes/ubuntu/ubuntu-tips/</link>
      <pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/ubuntu/ubuntu-tips/</guid>
      <description>记录ubuntu使用的常用问题</description>
    </item>
    <item>
      <title>Git正确使用姿势</title>
      <link>//localhost:1313/posts/notes/dev/%E6%8C%87%E5%8D%97%E5%9B%A2%E9%98%9Fgit%E5%8D%8F%E4%BD%9C/</link>
      <pubDate>Sun, 27 Aug 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/dev/%E6%8C%87%E5%8D%97%E5%9B%A2%E9%98%9Fgit%E5%8D%8F%E4%BD%9C/</guid>
      <description>记录使用git的常用命令，以及对git的工作模式进行简单讲解</description>
    </item>
    <item>
      <title>使用GORM操作数据库</title>
      <link>//localhost:1313/posts/notes/database/%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8-gorm%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/database/%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8-gorm%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>记录第一次使用ORM框架，以及GORM的第一次</description>
    </item>
    <item>
      <title>Kafka消息队列</title>
      <link>//localhost:1313/posts/notes/bytedance-notes/kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/bytedance-notes/kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid>
      <description>消息队列的特性 卡夫卡(Kafka)作为消息队列的一种，拥有异步、削峰、解耦三种特性，并依靠这些特性，他经常在搜索、直播、订单和支付服务。
**异步：**不同于同步通信的需要等待接收方响应，异步通信的发送方在发送消息到消息队列后，不等待接收方响应，而是继续进行其他操作。接收方仅需要从消息队列中拉取消息即可。 异步操作减少了流程长度，提高消息的吞吐量和效率。 **削峰：**对于突发的消息高峰，消息队列起到了存储请求的作用，使后台能以稳定的速率处理消息，从而减少了服务器的高峰负担，提高系统的稳定性。 解耦：解耦合即降低各个组件之间的依赖。使用消息队列，发送者和接收者各种把自己的消息发送给消息队列，从而实现解耦，方便各自开发部署，避免一方接口发生错误而影响多方，实现错误隔离。 卡夫卡的基本概念 **逻辑队列(Topic)：**可以建立不同的逻辑队列，存储于物理集群中。 **物理集群(Cluster)：**可建立多个逻辑队列。 **生产者(Producer)：**发送消息到逻辑队列。 **消费者(Consumer)&amp;amp;消费者组(Consumer Group)：**消费逻辑队列内的消息，各个消费者组互不干扰。 **Offset：**记录消息在有序序列Partition中的相对位置，每个Topic可分为多个Partition。Offset是消息的唯一ID，并在序列中严格递增。搜索Offset采用二分查找找到小于目标Offset的最大索引位置（时间戳索引类似）。 **Replica：**相当于副本，保证集群中节点上的 Partition 数据不因故障丢失。每个Partition有一个Replica-Leader，用于写入，同时拥有多个Follower用于记录Leader。如果Follower数据与Leader差距过大则踢出ISR。Replica又以log日志文件存储。 卡夫卡的消费模式 卡夫卡消息队列有两种最常见的消费模式。
**一对一：**生产者将消息发送到消息队列后，由消费者从队列中拉取并消费，然后信息会被删除。
一对多：即发布-订阅模式。生产者将消息发送到逻辑队列(Topic)（逻辑队列存储在Cluster物理集群中），可以被多个消费者订阅，从而实现每个消费者独立从该主题中拉取消息，值得注意的是该模式下消息并不会在消费后立刻删除，而是会在删除前保留一段时间。
然而在实际业务中，这两种消费模式并不能覆盖所有常业务场景，因此也会衍生出如竞争消费和优先级消费等高级模式。
卡夫卡消息分配 **手动分配：**通过手动分配完成哪个consumer消费哪个Partition。缺点是当Consumer节点故障后，Partition数据流受影响；当出现新的Consumer，需要重新分配Partition。 **Rebalance：**通过设立Coordinator，自动识别故障的consumer节点或新增的consumer，实现自动分配。Consumer端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。 提高卡夫卡吞吐量和稳定性的方法 **Producer：**批量发送（降低io次数）、数据压缩（降低带宽流量）。 **Broker：**顺序写（提高吸入速度），消息索引，零拷贝。 **Consumer：**Rebalance分配。 卡夫卡的缺点 **重启操作：**重启broker后，Leader切换。与此同时数据仍在写入，导致重启的broker和当前的Leader数据产生差异，需要重新追赶后才能回切（由于其他broker也有可能需要重启），导致需要大量时间。 **替换、扩容、缩容操作：**替换与重启操作类似，不过由于是重新写入，所以需要的时间更多。扩容和缩容都需要进行复制操作，因此也需要大量时间。 **负载不均衡问题：**为降低某个Partition的IO写入而进行迁移，但同时也会引入新的IO负载，陷入恶性循环，需要复杂的解决方案。 缺点总结：
卡夫卡运维成本高。 负载不均衡问题严重。 没有缓存，依赖页缓存Page Cache。 Controller、Coordinator和Broker在同一进程中，IO性能下降。 </description>
    </item>
    <item>
      <title>关于对象存储</title>
      <link>//localhost:1313/posts/notes/bytedance-notes/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</link>
      <pubDate>Wed, 23 Aug 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/bytedance-notes/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</guid>
      <description>在做短视频项目的时候，我总是有个疑问：用户上传的视频我要存储在哪里呢？作为开发小白，目前只知道要存放数据就到DB里面去，那我想“那我的视频文件也要存储到MySQL里面去嘛？”emm，这的确是一个大难题，不过在互联网技术发达的今天，感谢各大论坛的支持，让我了解到了视频、图像这类非结构化数据最好是对象存储。
在此，你一定有一些疑惑：
为什么视频不用mysql这类数据库进行存储呢？ 对象存储是什么，使用它存储非结构化数据有什么好处呢？ 为什么不用MySQL存储非结构化数据？ 首先哈，mysql人家本来就是用来存储结构化数据的，视频文件是一种非结构化数据。
结构化数据/非结构化数据/半结构化数据 结构化数据： 结构化数据是以清晰、预定义格式存储的数据。它通常以表格、数据库或电子表格的形式存在，其中每一列都有明确的数据类型和定义，每一行代表一个记录。结构化数据非常适合使用关系型数据库管理系统（RDBMS）来存储和管理，因为数据的组织方式已经被预先定义好。例如，存储在数据库中的订单信息、员工工资表以及销售数据都属于结构化数据的示例。
非结构化数据： 非结构化数据则没有固定的格式，它可能包含不同类型的信息，如文本、图像、音频、视频等。这种数据类型通常不适合传统的关系型数据库，因为它们缺乏统一的结构。非结构化数据的处理相对更为复杂，需要使用特定的技术和工具，如自然语言处理（NLP）技术用于处理文本数据，计算机视觉技术用于处理图像数据等。社交媒体帖子、电子邮件内容、图像文件以及语音记录都属于非结构化数据的例子。
半结构化数据： 半结构化数据可能具有一定的格式，但不像完全结构化数据那样严格。常见的半结构化数据格式包括XML（可扩展标记语言）和JSON（JavaScript对象表示法）。这些数据通常具有一些层次结构，但字段可能不像传统数据库表中的列那样明确定义。
MySQL是一种关系型数据库管理系统，通常用于存储和管理结构化数据，如文本、数字、日期等。虽然MySQL可以存储二进制数据，但它并不是设计用来直接存储大量大文件（如视频文件）的最佳工具。
以下是为什么通常不使用MySQL存储视频文件的一些原因：
性能问题：MySQL的查询引擎是设计用来处理字符串、数值和日期等类型的数据的，对于大文件的存储和检索并不是最有效的。当你存储大量大文件时，可能会导致数据库性能下降，尤其是当你需要从数据库中检索这些文件时。 存储效率：数据库通常使用磁盘空间来存储数据，而文件系统（如NFS、HDFS等）则更高效地存储大文件。使用数据库来存储大文件可能会导致不必要的磁盘空间浪费。 文件操作：视频文件通常需要进行一些文件级别的操作，如复制、移动、删除等。这些操作通常比数据级别的操作更消耗资源。如果这些操作在数据库中进行，可能会导致性能问题。 扩展性：当你的视频库变得非常大时，你可能需要扩展你的存储系统。数据库的扩展性通常比文件系统要复杂得多。 因此，对于存储和管理视频文件，通常建议使用专门的文件存储系统，如NFS、HDFS、S3等。这些系统更高效地处理大文件，并且通常提供更好的扩展性和更好的性能。如果你需要从你的视频文件中检索信息，你可以将这些信息存储在关系型数据库中，并使用数据库的功能来查询和管理这些信息。
关于对象存储 对象存储是一种用于存储和管理大规模非结构化数据的存储架构。与传统的文件系统或块存储不同，对象存储将数据存储为&amp;quot;对象&amp;quot;，每个对象都包含数据本身以及与之相关的元数据（如文件名、创建日期、数据类型等）。这些对象被分布式地存储在多个服务器上，并通过唯一的标识符进行访问。
对象存储的主要特点包括：
扩展性： 对象存储设计用于应对海量数据的存储需求，可以轻松地扩展以适应不断增长的数据量，而无需大规模的基础架构变更。 分布式架构： 对象存储系统将数据分布在多个服务器上，提高了数据的可靠性和冗余性。即使某个服务器出现故障，数据仍然可以从其他服务器中恢复。 元数据： 每个对象都有丰富的元数据，这些元数据描述了对象的各种属性，包括文件名、大小、创建日期、数据类型等。这些元数据使得数据管理更加灵活和智能。 适应非结构化数据： 对象存储适用于存储各种类型的非结构化数据，如图像、音频、视频、日志文件、备份等。它不强制要求数据遵循特定的结构，因此非常适用于大多数现代应用生成的多样化数据。 数据访问和检索： 对象存储通常提供强大的数据访问和检索功能。您可以使用对象标识符进行数据检索，而不需要像传统文件系统那样的层次化文件路径。 云集成： 许多云平台提供对象存储服务，使得在云环境中存储和管理数据变得更加简单和经济。 三种存储形态 块存储（Block Storage） 块存储将数据分割成固定大小的块，通常以扇区（一般为512字节或更大）为单位。这些块可以被单独管理，读取和写入。块存储通常在底层使用了虚拟化技术，将块映射到物理存储设备上。块存储适用于需要随机读写的应用，如操作系统的磁盘，数据库，虚拟机镜像等。
主要特点：
低延迟的读写操作。 支持随机读写访问。 通常用于需要高性能、低延迟和数据管理控制的应用。 文件存储（File Storage） 文件存储模式以文件为单位进行存储和管理。文件存储模式通常使用网络协议（如NFS或SMB）提供共享文件系统，使多台计算机能够共享相同的文件。这种模式适用于需要多台计算机访问相同文件的应用，如共享文件夹、办公文档、媒体文件等。
主要特点：
以文件为单位进行管理和访问。 适用于多台计算机之间的文件共享和协作。 不适合大规模、高并发的访问。 对象存储（Object Storage） 对象存储是一种将数据以对象形式进行存储的方法。每个对象都包含数据本身、元数据（如文件名、创建日期等）以及一个唯一的标识符。对象存储通常在分布式环境中工作，可以自动扩展以适应大规模的数据。它适用于大规模的非结构化数据，如图像、音频、视频文件，以及需要长期保留和高可用性的数据。
主要特点：
以对象为单位存储，每个对象都有唯一的标识符。 可以存储海量非结构化数据。 高可扩展性和可用性。 适合数据归档、备份和云存储等场景。 区别 块存储以固定大小的块为单位进行读写，适用于随机读写的应用；
文件存储以文件为单位共享，适用于多台计算机之间的文件共享和协作；
对象存储以对象为单位存储，适用于海量非结构化数据的存储。
块存储和文件存储通常在操作系统级别进行管理，而对象存储在应用程序级别进行管理。
对象存储通常具有更高的可扩展性和冗余性，适合大规模和长期数据存储。
块存储和文件存储在访问控制和数据管理方面更加灵活，而对象存储强调数据的元数据和可扩展性。
常见的云平台的对象对象服务 腾讯云：对象存储 COS 阿里云：对象存储 OSS 火山引擎：对象存储TOS Azure：Azure Blob 存储 国内的各大云厂商的对象存储服务文档对他们的产品都介绍的挺详细的，我看了火山引擎TOS和Azure的存储服务，Azure的冗余服务在TOS中叫做多AZ冗余服务，大同小异，没有实际自己用过。国内云厂商对于学生的支持感觉还是不够，想要用还是得要自己掏钱，希望未来各大厂商还是能支持以下学生发展，积累一些企业口碑。</description>
    </item>
    <item>
      <title>Redis常用指令</title>
      <link>//localhost:1313/posts/notes/bytedance-notes/redis/</link>
      <pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/bytedance-notes/redis/</guid>
      <description>快速了解Redis Redis是什么？为什么要使用Redis？他有什么好处和优势？他的弊端又有哪些呢？他的基本模型和技术有哪些？
Redis是什么？ Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息代理。它被设计用于快速访问、存储和分析数据，以及支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis支持持久化，可以将数据保存在磁盘上，以便在重启后恢复数据。
为什么要使用Redis？ Redis有许多优点，使其成为广泛使用的数据存储和缓存解决方案：
优势 快速访问： Redis数据存储在内存中，因此具有非常快速的读写性能，适合用作缓存层，加速数据访问。 丰富的数据结构： Redis不仅支持简单的键值存储，还支持多种数据结构，如列表、集合、有序集合等，这使得它适用于更多不同类型的应用场景。 持久化： Redis支持数据的持久化，可以将数据保存在磁盘上，以便在服务器重启后恢复数据。 分布式架构： Redis支持分布式集群，可以将数据分散在多个节点上，提高数据的可用性和性能。 发布/订阅： Redis具有消息代理功能，可以用于发布和订阅消息，支持实时数据推送和通知。 事务支持： Redis支持事务，允许一系列操作以原子方式执行，保证数据的一致性。 弊端 内存消耗： Redis的数据存储在内存中，因此对于大规模数据集可能会占用大量内存。尽管有持久化选项，但内存仍然是其主要的存储介质。 单线程： Redis在单个进程中使用单线程处理所有的命令请求。这在某些高并发情况下可能成为性能瓶颈。 基本模型和技术 键值存储： Redis的基本模型是键值存储，您可以使用键来检索存储在Redis中的数据。 数据结构： Redis支持字符串、哈希表、列表、集合、有序集合等多种数据结构，使其非常灵活。 持久化： Redis支持两种持久化方式，分别是快照（snapshotting）和日志（append-only file）。 发布/订阅： Redis支持发布/订阅模式，允许客户端订阅特定的频道并接收实时消息。 分布式： Redis可以通过分片或复制来构建分布式架构，提高可用性和扩展性。 Redis vs. MySQL 性能比较 读写性能： Redis在内存中存储数据，因此具有非常快速的读写性能，尤其适合高并发读取和写入场景。与此相比，MySQL可能受到磁盘IO和索引的影响，其读写性能相对较低。 数据结构： Redis支持多种数据结构，使其适合用于更复杂的数据模型，如实时计数、排行榜、分布式锁等。MySQL虽然也支持多种数据类型，但通常用于结构化数据的存储。 缓存： Redis非常适合用作缓存层，可以减轻数据库的负载，提高数据访问速度。MySQL也可以用作缓存，但Redis的读取速度更快。 事务和持久化： Redis支持事务，但它的事务模型不如MySQL严格。MySQL提供强大的事务支持和多种持久化选项。 适用领域和场景 Redis适合场景 实时数据：例如实时计数、统计信息和分析。 缓存：用作高速缓存，提高数据访问速度。 实时消息：发布/订阅模式用于实时消息传递。 会话存储：存储用户会话数据，适用于分布式系统。 分布式锁：实现分布式锁以协调多个系统的并发操作。 MySQL适合场景 结构化数据：适用于关系型、事务性的结构化数据。 复杂查询：支持复杂的查询和连接操作。 大规模数据存储：适合大规模数据存储和管理。 强大事务：需要强大的事务支持和ACID特性。 Redis和MySQL有各自独特的优势和用途，它们并不是直接替代关系。Redis可以在某些情况下用来增强项目性能，或者作为辅助数据库来存储特定类型的数据，例如缓存、会话、排行榜等。然而，对于需要复杂查询、关联性和事务的应用，Redis并不是MySQL的替代品。对于大部分应用，两者可以共同使用，以发挥各自的优势，构建更高效的系统。
Redis基本命令 现在很多大公司的后端服务都是基础存储服务+Redis缓存的形式，使用Redis进行缓存很大程度上提高了服务的效率，当然也存在缓存穿透、缓存雪崩的问题，但是在此之前还是要从Redis的基础命令开始学习掌握，所以在这里整理了Redis常用的命令。
字符串 在Redis中，字符串可以存储以下3中类型的值：字节串（byte string），整数，浮点数。
自增自减命令 INCR key-name：将键存储的值加上1</description>
    </item>
    <item>
      <title>pycharm中找不到包的问题</title>
      <link>//localhost:1313/posts/notes/problems/pycharm-not-found-packages/</link>
      <pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/problems/pycharm-not-found-packages/</guid>
      <description>VScode快捷键 快捷键 功能 Shift + Alt + F 格式化文档 Format document Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Ctrl+Shift+K 删除行 Delete line Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + Shift + P，F1 显示命令面板 Show Command Palette pycharm中找不到包的问题 对于pycharm中虚拟环境，下面的目录没有在pycharm中终端安装上的包</description>
    </item>
    <item>
      <title>网络安全——认证与加密</title>
      <link>//localhost:1313/posts/notes/security/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</link>
      <pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/security/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</guid>
      <description>记录网络安全方向的一些实践：加密与认证、软件破解、常见攻击和预防（XSS, CSRF）等</description>
    </item>
    <item>
      <title>ping github.com</title>
      <link>//localhost:1313/posts/notes/problems/ping-github.com/</link>
      <pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/problems/ping-github.com/</guid>
      <description>问题初现 在Windows上，挂了Clash，平时网页版的GitHub还是能正常跑的，因为平时开发主要是在Ubuntu上，所以git工具在Windows上用的不多。这次突发奇想，想把Windows和Ubuntu上的笔记整合到一个GitHub仓库上，并实现更新文件后自动拉取推送的功能，所以我现在Ubuntu上推送了一部分笔记到仓库中，再计划将Windows上的笔记也弄上去。
然后在配置Windows上的笔记文件夹Git环境，发现git老是报错ssh22端口连接超时。
我检查了：
GitHub仓库上的SSH公钥配置，正常 Git的HTTP和HTTPS代理，正常 // 查看git有没有代理 git config --global -l // 配置git代理 git config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890 // 取消git网络代理 git config --global --unset http.proxy git config --global --unset https.proxy 也想不通为啥，然后我就在博客园中看到了一篇文章：https://www.cnblogs.com/oldboyooxx/p/10387150.html
主要就是说：1、检查IP配置问题；2、检查防火墙状态
然后我就去ping github.com，发现ping不通，开代理不开代理都不行，怪！
我想起来可以通过改主机hosts的方式访问，https://www.cnblogs.com/xuexianqi/p/13219719.html，改了之后github.com就能ping通了。
再然后就发现SSH22端口超时的问题也解决了，然后就开始合并笔记了~
脚本自动同步 对于笔记自动保存之后每次都要git手动提交未免也太麻烦了，然后我想试试通过一个git脚本来自动完成就好了。
git pull origin master git add . git commit -m &amp;#34;update&amp;#34; git push origin master 脚本的内容很简单啊，就是基础的这几步命令。
现在的问题就是怎么让他在保存文件的时候自动执行呢？而且希望如果同步的时候出错，能够把错误信息打印出来，可以是日志的方式。
人工办法：在写笔记之前进行一次脚本运行，写笔记，写完笔记之后，再运行一次脚本。
稍微聪明一点的办法：在打开和关闭文件夹/Typora的时候运行脚本。</description>
    </item>
    <item>
      <title>Go log库，encoding/json</title>
      <link>//localhost:1313/posts/notes/languages/go-stdlib-notes/</link>
      <pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/languages/go-stdlib-notes/</guid>
      <description>log Go语言内置的log包实现了简单的日志服务。本文介绍了标准库log的基本使用。
Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如logrus、zap等。
使用Logger log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。
例如，我们可以像下面的代码一样直接通过log包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：
package main import ( &amp;amp;quot;log&amp;amp;quot; ) func main() { log.Println(&amp;amp;quot;这是一条很普通的日志。&amp;amp;quot;) v := &amp;amp;quot;很普通的&amp;amp;quot; log.Printf(&amp;amp;quot;这是一条%s日志。\n&amp;amp;quot;, v) log.Fatalln(&amp;amp;quot;这是一条会触发fatal的日志。&amp;amp;quot;) log.Panicln(&amp;amp;quot;这是一条会触发panic的日志。&amp;amp;quot;) } 编译并执行上面的代码会得到如下输出：
2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条会触发fatal的日志。 logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。
配置logger 标准logger的配置 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法。
log标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置。
func Flags() int func SetFlags(flag int) flag选项 log标准库提供了如下的flag选项，它们是一系列定义好的常量。
const ( // 控制输出日志信息的细节，不能控制输出的顺序和格式。 // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 &amp;lt;&amp;lt; iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒级别的时间：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d.</description>
    </item>
    <item>
      <title>Go学习笔记</title>
      <link>//localhost:1313/posts/notes/languages/go-notes/</link>
      <pubDate>Tue, 20 Jun 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/languages/go-notes/</guid>
      <description>配置 Go 工作区 继续之前，请务必仔细阅读此部分。
Go 在组织项目文件方面与其他编程语言不同。 首先，Go 是在工作区的概念下工作的。 工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。
若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。
Go 工作区文件夹 每个 Go 工作区都包含三个基本文件夹：
bin：包含应用程序中的可执行文件。 src：包括位于工作站中的所有应用程序源代码。 pkg：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。 例如，工作站文件夹结构树可能与下面的示例类似：
bin/ hello coolapp pkg/ github.com/gorilla/ mux.a src/ github.com/golang/example/ .git/ hello/ hello.go
Go实战经验 在命令行中输入&amp;rsquo;code . &amp;lsquo;会唤起VS code编辑当前目录
源码规范 可执行文件都要包含在package main中 import的包必须都要使用，否则报错不进行编译；vs code中保存文件就会自动调整文件格式，并且删除未使用的import 整个package main中只能有一个func main() 变量的声明和初始化 Go是强类型语言，声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。
变量声明的方式有很多，格式和其他语言不太一样
最普通的方式：var 变量名称 变量类型 Go也可以像Python那样自动推断变量的类型，有些时候可以不用加类型名称 最常用的方式（只适用于在函数内，声明并初始化一个新的变量）：使用冒号等号 age := 32 注意，在函数体外还是只能用var的方式声明和初始化变量 // 变量声明 // 变量声明了必须要使用，否则编译不通过 var first string var second, third string var age int = 1 var ( fisrtly int = 1 secondly string = 2 thirdly = &amp;#34;123&amp;#34; ) var firstName, secondName, agenumber = &amp;#34;123&amp;#34;, &amp;#34;456&amp;#34;, 32 // 最常见的声明方式 冒号等于号 := 用于声明并初始化变量，不能用于常量的声明 firstName_, secondName_, age_ := &amp;#34;123&amp;#34;, &amp;#34;456&amp;#34;, 32 // 常量声明f const HTTPstatusOK = 200 const ( StatusOK = 0 StatusConnectionReset = 1 StatusOtherError = 2 ) 数据类型 基本类型：数字、字符串、布尔值 聚合类型：数组、结构体 引用类型：指针、切片、映射、函数、通道 接口类型：接口 基本类型 在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。</description>
    </item>
    <item>
      <title>CSRF攻击</title>
      <link>//localhost:1313/posts/notes/security/csrf-attack/</link>
      <pubDate>Sun, 21 May 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/security/csrf-attack/</guid>
      <description>简介 ​CSRF攻击利用了受害者已经通过身份验证并且在一个网站上建立的有效会话，来执行未经授权的操作。当受害者在一个网站上登录并获得一个会话（例如通过使用用户名和密码进行身份验证），该网站会为其分配一个令牌或会话ID，以便在后续的请求中验证用户的身份。
​CSRF攻击者会通过诱使受害者访问一个恶意网站或点击恶意链接，来利用受害者的已验证会话。由于受害者在浏览器中仍然保持着有效会话，攻击者可以构造特制的请求，以利用该会话来执行恶意操作，而这些操作是受害者并不知情或未经授权的。
​例如，假设受害者在银行网站上登录并建立了一个有效的会话。攻击者可以通过电子邮件或社交媒体发送一个包含恶意链接的消息给受害者。如果受害者点击了该链接，他们的浏览器将自动向银行网站发送一个请求，而这个请求中包含了受害者的有效会话信息。银行网站在验证会话时会认为这个请求是合法的，因为会话是有效的，所以它执行了该请求所代表的操作，如转账、修改账户信息等，而受害者是毫不知情的。
​CSRF攻击的目标是利用受害者的已验证会话来执行攻击者所期望的未经授权操作，从而导致受害者的损失或者对系统的安全产生威胁。
补充知识 cookie 一般情况下，cookie是以键值对进行表示的(key-value)，例如name=jack，这个就表示cookie的名字是name，cookie携带的值是jack。
cookie有2种存储方式，一种是会话性，一种是持久性。
会话性：如果cookie为会话性，那么cookie仅会保存在客户端的内存中，当我们关闭客服端时cookie也就失效了 持久性：如果cookie为持久性，那么cookie会保存在用户的硬盘中，直至生存期结束或者用户主动将其销毁。
组成 （1）cookie名称 （2）cookie值 （3）Expires：过期时间。当过了过期时间后，浏览器会将该cookie删除。如果不设置Expires，则关闭浏览器后该cookie失效。 （4）Path：用来设置在路径下面的页面才可以访问该cookie，一般设为/，以表示同一站点的所有页面都可以访问该cookie。 （5）Domain：用来指定哪些子域才可以访问cookie，格式一般为“.XXX.com” （6）Secure:如果设置了secure没有值，则代表只有使用HTTPS协议才可以访问 （7）HttpOnly：如果在cookie中设置了HttpOnly属性，那么通过JavaScript脚本等将无法读取到cookie信息。
URL URL（统一资源定位符）的一般格式如下：
scheme://host:port/path?query_parameters#fragment_identifier 具体解释如下：
Scheme（协议）：指定用于访问资源的协议，例如HTTP、HTTPS、FTP等。它是URL的开头部分，通常以双斜杠（//）结尾。 Host（主机）：指定目标资源所在的主机名或IP地址。主机名可以是域名（例如example.com）或IP地址（例如192.168.0.1）。 Port（端口）：指定用于访问目标资源的端口号（可选）。默认的端口号根据协议而不同，如HTTP默认端口是80，HTTPS默认端口是443。如果URL中没有指定端口，将使用默认端口。 Path（路径）：指定资源在服务器上的路径（可选）。路径部分是指服务器上资源的具体位置，可以是文件路径或目录路径。 Query Parameters（查询参数）：包含在URL中的键值对参数（可选）。查询参数通常用于向服务器传递额外的信息，多个参数之间使用&amp;quot;&amp;amp;&amp;ldquo;符号分隔。 Fragment Identifier（片段标识符）：用于标识文档中的特定片段（可选）。片段标识符通常由一个锚点或特定位置的标识符组成，用于在文档中导航到指定位置。 实验过程 使用Flask框架进行构建web应用。
文件架构 ├── web-csrf/ │ ├── webA.py │ ├── webB.py │ ├── templates/ │ │ ├── home.html │ │ ├── login.html │ └── static/ │ └── style.css 源码 webA:
# webA.py import hashlib import re import mysql.connector from flask import Flask, request, render_template, make_response app = Flask(__name__) db = mysql.</description>
    </item>
    <item>
      <title>栈溢出攻击</title>
      <link>//localhost:1313/posts/notes/security/stack_overflow-attack/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/security/stack_overflow-attack/</guid>
      <description>实验程序源代码：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;windows.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define PASSWORD &amp;#34;1234567&amp;#34; int verify_password(char *password) { int authenticated; char buffer[44]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); // over flowed here! return authenticated; } int main() { int valid_flag = 0; char password[1024];l FILE *fp; LoadLibrary(&amp;#34;user32.dll&amp;#34;); // prepare for messagebox if (!(fp = fopen(&amp;#34;password.txt&amp;#34;, &amp;#34;rw+&amp;#34;))) { exit(0); } fscanf(fp, &amp;#34;%s&amp;#34;, password); valid_flag = verify_password(password); if (valid_flag) { printf(&amp;#34;incorrect password!\n&amp;#34;); } else { printf(&amp;#34;Congratulation!</description>
    </item>
    <item>
      <title>Ubuntu22.04 配置clash-for-linux</title>
      <link>//localhost:1313/posts/notes/ubuntu/clash-for-linux/</link>
      <pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/ubuntu/clash-for-linux/</guid>
      <description>记录从cfw换到clash-for-linux</description>
    </item>
    <item>
      <title>加密与认证</title>
      <link>//localhost:1313/posts/notes/security/encryption-authentication/</link>
      <pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/security/encryption-authentication/</guid>
      <description>任务 采用Java/Python语言编写一个较为完整的加密与认证程序，要求具有：
具有较完整的图形化界面； 使用MD5、SHA系列算法，实现消息摘要，确保消息的完整性； 使用DES、AES等算法实现对称加密，确保消息的机密性； 使用RSA算法，实现公钥加密，且用私钥解密，比较不对称加密和对称加密的性能； 实现基于数字证书的数字签名和验证（含证书的生成和创建）； 消息摘要 消息摘要的作用 在网络安全目标中，要求信息在生成、存储或传输过程中保证不被偶然或蓄意地删除、修改、伪造、乱序、重放、插入等破坏和丢失，因此需要一个较为安全的标准和算法，以保证数据的完整性。
常见的消息摘要算法有： Ron Rivest设计的MD（Standard For Message Digest，消息摘要标准）算法 NIST设计的SHA（Secure Hash Algorithm，安全散列算法）
单向散列函数 特点 不定长的输入和定长的输出；
对于及其微小的变化，如1bit的变化，器哈希函数所产生的值也差异巨大；
对于不同的原像都有不同的映像，从散列值不可能推导出消息M ，也很难通过伪造消息M’来生成相同的散列值。
Hash函数的值称为作为自变量的消息的“散列值”或“消息摘要”、“数字指纹”
哈希函数的分类 根据安全水平 弱无碰撞 强无碰撞 ​	注：强无碰撞自然含弱无碰撞！
根据是否使用密钥 带秘密密钥的Hash函数：消息的散列值由只有通信双方知道的秘密密钥K来控制，此时散列值称作MAC(Message Authentication Code) 不带秘密密钥的Hash函数：消息的散列值的产生无需使用密钥，此时散列值称作MDC(Message Detection Code) 哈希函数的应用 由Hash函数产生消息的散列值 以消息的散列值来判别消息的完整性 用加密消息的散列值来产生数字签名 用口令的散列值来安全存储口令（认证系统中的口令列表中仅存储口令的Hash函数值，以避免口令被窃取。认证时用输入口令的Hash函数值与其比较） 安全哈希函数的实现 输入数据分成L个长度固定为r的分组：M=(M1,M2,…,ML) 末组附加消息的长度值并通过填充凑足r位 压缩函数 f使用n位的链接变量Hi ,其初值H0=IV可任意指定 压缩函数 f的最后n位输出HL取作散列值 哈希函数：生日攻击 当哈希函数的输入位数太短的时候，就容易产生哈希碰撞，即出现两个原像对应用一个映像的问题。
生日问题 一个教室中至少有几个学生才能使有两个学生生日相同的概率不小于1/2； 等价于“球匣问题” 设J个球随机扔进N个匣子，存在一个匣子中至少有两个球的概率为p，则可以推导出: J2≈-2Nln(1-p)或 p≈ 1-e-J2/2/N 答案 将365个生日看作N=365个匣子，将学生看作球，p=0.5，则由上式可算出J≈23，即23个学生中有两个学生生日相同的概率不小于1/2；
生日攻击实例：
​	假设张三承诺支付李四100万，约定由李四负责起草合同，并通过8位的散列码H(M)实施信息认证。聪明而无德的李四先起草一个100万的版本，并通过变化其中3个无关紧要之处以得到23=8个不同的消息明文并计算它们的H(M)，形成集合A；然后再起草一个200万的版本，用同样方法又得到23=8 个不同的消息明文及其H(M)，形成集合B。 ​	由生日问题知：24个8位比特串中发生碰撞的概率不小于1/2，故在A和B共24 =16个H(M)中有可能存在相同的一对，并极有可能一个在A中而另一个在B中。假设与它们对应的明文为MA （100万版） 和MB （200万版） 。于是李四用MA让张三签署并公证，而在传送时偷偷地用MB替代MA 。由于H(MA)= H(MB)，故张三确信签署的文件未被篡改。当李四要求张三支付200万时，法院根据MB判李四胜诉，而张三因此损失100万。</description>
    </item>
    <item>
      <title>Kubernetes学习和实践</title>
      <link>//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 30 Oct 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/cloud-native/kubernetes%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description>这篇文章记录了阅读Kubernetes inAction的学习记录，以及使用k8s进行一些实战的过程</description>
    </item>
    <item>
      <title>数据结构学习笔记</title>
      <link>//localhost:1313/posts/notes/professional-classes/data_structure/</link>
      <pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/professional-classes/data_structure/</guid>
      <description>一、绪论 数据（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。
数据的最小单位的是数据项；
数据的基本单位是数据元素，一个数据元素可由若干个数据项组成。
数据结构分为两大类：线性结构和非线性结构
两类结构通常分为四类基本结构：
1）集合：结构中的数据元素之间同属于一个集合，此外没有其他关系；
2）线性结构：结构中的数据元素之间存在一种线性关系，一对一的关系；
3）树形结构：一对多的关系；
4）图形结构或网状结构：多对多的关系。
根据视点的不同又可分为：逻辑结构和物理结构：
逻辑结构：面向问题，描述数据元素之间的逻辑关系；
物理结构：又称存储结构，面向计算机，是数据结构在计算机中的表示（映像）
算法的特性：输入性、输出性、确定性、有穷性、有效性（可行性）
算法的标准：正确性（满足所要求界的问题的需求，最重要最基本）、可用性（便于用户使用，良好的界面、完备的用户文档）、可读性（易于理解）、效率（存储单元的开销和运行时间的耗费）、健壮性（对于非法数据的处理）
算法复杂度：（渐进）时间复杂度和空间复杂度
二、线性结构 1、线性表 1.1	顺序表示：顺序表 用顺序结构存储的线性表为顺序表（sequential list）。
顺序表一般用数组进行存储
类模板定义：T* elems，int length，int maxLength
1.2	链表表示 1)	单链表 分为带头结点和不带头结点的单链表；
带头结点的单链表相对不带头结点的单链表在涉及会更改头节点的任务时，操作会更加统一。
类模板定义：
（结点）T data，Node* next
（单链表）Node* head，int length
2)	双向循环链表 类模板定义：
（结点）T data，Node* prior，Node* next
（双向循环链表）Node* head，int length
*带头结点的双向循环列表只有一个元素结点的条件：head-&amp;gt;next!=head &amp;amp;&amp;amp; head-&amp;gt;next-&amp;gt;next==head
3)	静态链表 利用数组来模拟存储空间实现链表。
类模板定义：
（结点）T data，Node* next
（静态链表）Node* head，Node* avail
设数组a放置了一个静态链表，当链表未使用的时候，其中所有的结点都是形成了一个链表，用avail进行管理，代表未使用的结点。
当进行插入操作的时候，就从avail中取出一个头节点，进行赋值，再放入head链表之中。
在完成每一步操作之后，记得要将next域中更改
插入元素操作：
i=avail; avail=a[avail].next; a[i].next=a[head],next; a[head]。next=i; 当需要释放由j所指向的结点时，只需要把结点j放到avail表的最前端，并让avail指向它即可。</description>
    </item>
    <item>
      <title>CPP学习笔记</title>
      <link>//localhost:1313/posts/notes/languages/cpp-notes/</link>
      <pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/languages/cpp-notes/</guid>
      <description>C++学习笔记 hello
现在主流的编译型语言包括C、C++、Go、Rust等，它们的编译过程中需要将代码转换成机器语言，因此可以获得更高的执行效率和更好的性能。
而主流的解释型语言包括Python、Ruby、JavaScript等，这些语言需要解释器将代码转换成机器语言并运行，因此相对于编译型语言，它们的执行效率和性能可能会稍低，但是它们通常具有更高的开发效率和更强的灵活性，因为它们可以在运行时动态修改代码。
另外，还有一些语言是即时编译型语言（JIT），例如Java、C#和LuaJIT等，这些语言的编译器会在运行时将代码编译成机器语言，因此它们的执行效率和性能通常比解释型语言要高一些，但比编译型语言略低一些。
函数的声明和定义中，
不能重复定义一个参数的值；
带有默认值的形式参数必须放在参数列表的最右侧;
一、cin 函数的用法 使用cin从标准输入读取数据时，通常用到的方法有cin&amp;raquo;，cin.get，cin.getline。
1.1 cin&amp;raquo;的用法 （1）cin&amp;raquo;等价于cin.operator&amp;raquo;()，即调用成员函数operator&amp;raquo;()进行读取数据。 （2）当cin&amp;raquo;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&amp;raquo;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&amp;raquo;不做处理。 （3）不想略过空白字符，那就使用 noskipws 流控制。比如cin&amp;raquo;noskipws&amp;raquo;input;
1.2 cin.get的用法 1.2.1 cin.get读取一个字符 读取一个字符，可以使用cin.get或者cin.get(var)，示例代码如下：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl; system(&amp;#34;pause&amp;#34;); return 0; } 输入：e[回车]，输出： 注意： （1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时打印两次。
（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。
1.2.2 cin.get读取一行 读取一行可以使用istream&amp;amp; get ( char* s, streamsize n )或者istream&amp;amp; get ( char* s, size_t n, streamsize delim )。二者的区别是前者默认以换行符结束，后者可指定结束符。n表示目标空间的大小。示例代码如下：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { char a; char array[20]={NULL}; cin.</description>
    </item>
    <item>
      <title></title>
      <link>//localhost:1313/posts/notes/professional-classes/compilation_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/professional-classes/compilation_principle/</guid>
      <description>第七章 语法制导的语义计算 </description>
    </item>
    <item>
      <title>学长的计算机网络笔记</title>
      <link>//localhost:1313/posts/notes/network/network-notes-by-prefect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/notes/network/network-notes-by-prefect/</guid>
      <description>概述 互联网：专有名词
互连网：通用网络
互联网的组成 边缘部分 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。
端系统之间的两种通信方式 客户-服务器方式（C/S）
客户是服务的请求方，服务器是服务的提供方
客户软件的特点 被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址 不需要特殊的硬件和很复杂的操作系统 服务器软件的特点 一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址 一般需要强大的硬件和高级的操作系统支持 对等方式（P2P）
不区分客户和服务器。
核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）
在网络核心部分起特殊作用的是路由器 (router)。 at Shanghai University
路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。
分组交换是网络核心部分最重要的功能
电路交换 $$N$$ 部电话机两两直接相连，需 $$N(N – 1)/2$$ 对电线。这种直接连接方法所需要的电线对的数量与电话机数量的平方（ $$N^2$$ ）成正比。
当电话机的数量增多时，就要使用交换机来完成全网的分组任务，这就是电路交换
特点 电路交换必定是面向连接的 电路交换分为三个阶段： 建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用； 通话：主叫和被叫双方一直占用通信资源； 释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源） 总结 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%
分组交换 分组交换采用存储转发技术
步骤 在发送端，先把较长的报文划分成较短的、固定长度的数据段 每一个数据段前面添加上首部构成分组 (packet) 分组交换网以“分组”（也称为“包”，首部也可称为“包头”）作为数据传输单元，依次把各分组发送到接收端（假定接收端在左边） 接收端收到分组后剥去首部还原成报文 最后，在接收端把收到的数据恢复成为原来的报文。 首部的重要性 每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。 分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。 每个分组在互联网中独立地选择传输路径。（通过路由器） 用这样的存储转发方式，最后分组就能到达最终目的地。 路由器的作用 在路由器中的输入和输出端口之间没有直接连线。 路由器处理分组的过程是： 把收到的分组先放入缓存（暂时存储）； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去。 优点 高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用 灵活：为每一个分组独立地选择最合适的转发路由 迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。 可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性 缺点 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销 总结 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</description>
    </item>
  </channel>
</rss>
