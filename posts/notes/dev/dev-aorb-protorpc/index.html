<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Protobuf与gRPC初次使用 | Sirius' Blog</title>
<meta name=keywords content="软件开发,auth"><meta name=description content="protoc代码生成了哪些东西？RPC和RESTful有什么不同？"><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/dev/dev-aorb-protorpc/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/dev/dev-aorb-protorpc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Protobuf与gRPC初次使用"><meta property="og:description" content="protoc代码生成了哪些东西？RPC和RESTful有什么不同？"><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/dev/dev-aorb-protorpc/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-18T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Protobuf与gRPC初次使用"><meta name=twitter:description content="protoc代码生成了哪些东西？RPC和RESTful有什么不同？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"Protobuf与gRPC初次使用","item":"https://sirius1y.top/posts/notes/dev/dev-aorb-protorpc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protobuf与gRPC初次使用","name":"Protobuf与gRPC初次使用","description":"protoc代码生成了哪些东西？RPC和RESTful有什么不同？","keywords":["软件开发","auth"],"articleBody":"在项目aorb中能够使用了微服务架构，然后引入了RPC，现在目前开发中，晚点再来完善这篇文章。现在先记录一些主要的概念。\nIDL 接口定义语言 IDL（Interface Definition Language，接口定义语言）是一种用于定义软件组件之间接口的语言。IDL允许开发人员定义程序模块之间的接口，使得不同语言、平台和系统能够通过统一的接口进行通信。IDL的主要作用是定义数据类型和RPC（Remote Procedure Call，远程过程调用）的接口。\nProto接口定义的意义 Proto接口定义是指使用Protocol Buffers（protobuf）来定义数据结构和服务接口。protobuf是由Google开发的一种高效的二进制序列化格式，常用于配置文件、数据存储格式和通信协议。\n跨语言支持：proto文件可以生成多种语言的代码，包括C++、Java、Python等，确保不同语言的系统可以互相通信。 高效传输：protobuf序列化后的数据体积小，解析速度快，适合网络传输。 版本兼容：proto文件可以通过增加新字段来实现向后兼容，不影响旧的客户端和服务器。 RPC（Remote Procedure Call，远程过程调用） RPC是一种通过网络从远程计算机程序上执行子程序的协议，仿佛是在本地执行一样。RPC隐藏了底层的网络通信细节，使得开发者可以像调用本地方法一样调用远程方法。\nIDL和RPC的关系 IDL用于定义RPC接口，指定远程调用所需的参数和返回值类型。通过IDL定义的接口，可以自动生成客户端和服务器的桩代码（stub），这些代码负责处理序列化和反序列化、网络通信等底层细节，使得开发者可以专注于业务逻辑。\nRESTful和gRPC的关系 RESTful和gRPC是两种不同的网络通信风格和框架，它们各自服务于不同的应用场景和需求。下面是它们之间的关系和区别：\nRESTful (Representational State Transfer):\nRESTful是一种基于HTTP协议的设计风格，它利用HTTP的方法（如GET、POST、PUT、DELETE等）来操作资源。 RESTful服务通常使用JSON或XML作为数据交换格式。 RESTful API设计简单，易于理解和使用，适合于跨平台和跨语言的场景。 由于基于HTTP，RESTful服务天然支持浏览器和各种HTTP客户端，易于缓存和负载均衡。 gRPC (Google Remote Procedure Call):\ngRPC是由Google开发的高性能、开源的通用RPC框架。 gRPC使用Protocol Buffers（protobuf）作为接口定义语言（IDL）和数据序列化格式。 gRPC支持多种语言，并提供了跨语言的接口调用能力。 gRPC支持双向流式传输，适合于需要高性能和低延迟的场景，如微服务架构。 gRPC默认使用HTTP/2作为传输协议，支持多路复用和服务端推送等特性。 关系:\nRESTful和gRPC都是用于构建分布式系统和微服务的通信协议，但它们的设计理念和使用场景有所不同。 RESTful更多地依赖于HTTP协议的特性，而gRPC则是一个独立的RPC框架，虽然它也使用了HTTP/2协议，但其核心在于protobuf的序列化和高效的RPC调用。 在实际应用中，选择RESTful还是gRPC取决于具体的需求，如性能要求、开发语言、团队熟悉度、生态系统支持等。 总结: RESTful和gRPC是两种互补的技术，它们各自在不同的领域和场景中发挥作用。开发者可以根据项目的具体需求和约束来选择最合适的通信方式。\n.pb.go和_grpc.pb.go文件 在Go语言中使用Protocol Buffers (protobuf) 时，通常会生成两个主要的Go文件，分别是 auth_grpc.pb.go 和 auth.pb.go。这两个文件的作用如下：\nauth.pb.go:\n这个文件是由protobuf编译器根据.proto文件中的消息定义生成的。它包含了所有在.proto文件中定义的消息（messages）、枚举（enums）和任何其他非RPC相关的数据结构的Go语言实现。 auth.pb.go 文件主要负责序列化和反序列化数据，以及提供对消息结构的访问。例如，如果你在.proto文件中定义了一个名为 Token 的消息，auth.pb.go 将包含一个名为 Token 的Go结构体以及用于操作这个结构体的函数，如 Marshal、Unmarshal、New 等。 auth_grpc.pb.go:\n这个文件是由protobuf编译器根据.proto文件中的服务定义（service definitions）生成的，特别是当.proto文件中包含了gRPC服务定义时。 auth_grpc.pb.go 文件包含了gRPC服务的客户端和服务器端的Go语言实现。它定义了用于远程过程调用（RPC）的接口和方法，包括服务端接口（server interfaces）、客户端存根（client stubs）以及用于处理RPC请求和响应的代码。 例如，如果你在.proto文件中定义了一个名为 AuthService 的gRPC服务，auth_grpc.pb.go 将包含用于实现这个服务的Go接口和方法，如 AuthServiceServer、AuthServiceClient 以及具体的方法实现，如 Login、Logout 等。 总结来说，auth.pb.go 负责处理数据结构和序列化/反序列化，而 auth_grpc.pb.go 负责处理RPC通信和服务的实现。这两个文件共同工作，使得在Go语言中使用protobuf和gRPC变得更加高效和方便。\nauth_grpc.pb.go文件结构 在这个 auth_grpc.pb.go 文件中，各个部分的作用如下：\n包声明和导入:\npackage auth 声明了这个文件属于 auth 包。 import 语句导入了必要的包，如 context、grpc、codes 和 status。 常量定义:\n定义了服务方法的全局唯一方法名，如 AuthService_Login_FullMethodName。 客户端接口定义:\nAuthServiceClient 接口定义了客户端可以调用的所有服务方法，如 Login、Verify 等。 authServiceClient 结构体实现了 AuthServiceClient 接口，提供了实际的客户端调用逻辑。 服务端接口定义:\nAuthServiceServer 接口定义了服务端需要实现的所有服务方法。 UnimplementedAuthServiceServer 结构体提供了未实现方法的默认实现，通常用于确保服务端实现了所有必要的方法。 服务注册:\nRegisterAuthServiceServer 函数用于在 gRPC 服务器上注册 AuthService 服务。 服务方法处理函数:\n如 _AuthService_Login_Handler，这些函数定义了如何处理每个服务方法的请求和响应。 服务描述:\nAuthService_ServiceDesc 描述了 AuthService 服务的元数据，包括服务名、处理函数类型、方法列表等。 你的逻辑应该写在服务端接口的实现中。具体来说，你需要创建一个结构体，该结构体实现了 AuthServiceServer 接口，并在该结构体中为每个服务方法提供具体的业务逻辑实现。例如：\ntype authServiceServer struct { UnimplementedAuthServiceServer // 这里可以添加你的业务逻辑需要的字段 } func (s *authServiceServer) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) { // 实现登录逻辑 // ... } func (s *authServiceServer) Verify(ctx context.Context, req *VerifyRequest) (*VerifyResponse, error) { // 实现验证逻辑 // ... } // 实现其他服务方法... func main() { // 创建 gRPC 服务器 server := grpc.NewServer() // 注册你的服务实现 RegisterAuthServiceServer(server, \u0026authServiceServer{}) // 启动服务器 // ... } 在这个例子中，authServiceServer 结构体实现了 AuthServiceServer 接口，并提供了 Login、Verify 等方法的具体实现。在 main 函数中，你创建了一个 gRPC 服务器，并将你的服务实现注册到服务器上。这样，当客户端调用这些服务方法时，服务器就会执行你提供的逻辑。\n","wordCount":"205","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-06-18T00:00:00Z","dateModified":"2024-06-18T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/dev/dev-aorb-protorpc/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Protobuf与gRPC初次使用</h1><div class=post-description>protoc代码生成了哪些东西？RPC和RESTful有什么不同？</div><div class=post-meta><span title='2024-06-18 00:00:00 +0000 UTC'>June 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;205 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#idl-%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89%e8%af%ad%e8%a8%80 aria-label="IDL 接口定义语言">IDL 接口定义语言</a></li><li><a href=#proto%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89%e7%9a%84%e6%84%8f%e4%b9%89 aria-label=Proto接口定义的意义>Proto接口定义的意义</a></li><li><a href=#rpcremote-procedure-call%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8 aria-label="RPC（Remote Procedure Call，远程过程调用）">RPC（Remote Procedure Call，远程过程调用）</a><ul><li><a href=#idl%e5%92%8crpc%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=IDL和RPC的关系>IDL和RPC的关系</a></li></ul></li><li><a href=#restful%e5%92%8cgrpc%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=RESTful和gRPC的关系>RESTful和gRPC的关系</a></li><li><a href=#pbgo%e5%92%8c_grpcpbgo%e6%96%87%e4%bb%b6 aria-label=.pb.go和_grpc.pb.go文件>.pb.go和_grpc.pb.go文件</a></li><li><a href=#auth_grpcpbgo%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84 aria-label=auth_grpc.pb.go文件结构>auth_grpc.pb.go文件结构</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在项目aorb中能够使用了微服务架构，然后引入了RPC，现在目前开发中，晚点再来完善这篇文章。现在先记录一些主要的概念。</p><h2 id=idl-接口定义语言>IDL 接口定义语言<a hidden class=anchor aria-hidden=true href=#idl-接口定义语言>#</a></h2><p>IDL（Interface Definition Language，接口定义语言）是一种用于定义软件组件之间接口的语言。IDL允许开发人员定义程序模块之间的接口，使得不同语言、平台和系统能够通过统一的接口进行通信。IDL的主要作用是定义数据类型和RPC（Remote Procedure Call，远程过程调用）的接口。</p><h2 id=proto接口定义的意义>Proto接口定义的意义<a hidden class=anchor aria-hidden=true href=#proto接口定义的意义>#</a></h2><p>Proto接口定义是指使用Protocol Buffers（protobuf）来定义数据结构和服务接口。protobuf是由Google开发的一种高效的二进制序列化格式，常用于配置文件、数据存储格式和通信协议。</p><ol><li><strong>跨语言支持</strong>：proto文件可以生成多种语言的代码，包括C++、Java、Python等，确保不同语言的系统可以互相通信。</li><li><strong>高效传输</strong>：protobuf序列化后的数据体积小，解析速度快，适合网络传输。</li><li><strong>版本兼容</strong>：proto文件可以通过增加新字段来实现向后兼容，不影响旧的客户端和服务器。</li></ol><h2 id=rpcremote-procedure-call远程过程调用>RPC（Remote Procedure Call，远程过程调用）<a hidden class=anchor aria-hidden=true href=#rpcremote-procedure-call远程过程调用>#</a></h2><p>RPC是一种通过网络从远程计算机程序上执行子程序的协议，仿佛是在本地执行一样。RPC隐藏了底层的网络通信细节，使得开发者可以像调用本地方法一样调用远程方法。</p><h3 id=idl和rpc的关系>IDL和RPC的关系<a hidden class=anchor aria-hidden=true href=#idl和rpc的关系>#</a></h3><p>IDL用于定义RPC接口，指定远程调用所需的参数和返回值类型。通过IDL定义的接口，可以自动生成客户端和服务器的桩代码（stub），这些代码负责处理序列化和反序列化、网络通信等底层细节，使得开发者可以专注于业务逻辑。</p><h2 id=restful和grpc的关系>RESTful和gRPC的关系<a hidden class=anchor aria-hidden=true href=#restful和grpc的关系>#</a></h2><p>RESTful和gRPC是两种不同的网络通信风格和框架，它们各自服务于不同的应用场景和需求。下面是它们之间的关系和区别：</p><ol><li><p><strong>RESTful (Representational State Transfer)</strong>:</p><ul><li>RESTful是一种基于HTTP协议的设计风格，它利用HTTP的方法（如GET、POST、PUT、DELETE等）来操作资源。</li><li>RESTful服务通常使用JSON或XML作为数据交换格式。</li><li>RESTful API设计简单，易于理解和使用，适合于跨平台和跨语言的场景。</li><li>由于基于HTTP，RESTful服务天然支持浏览器和各种HTTP客户端，易于缓存和负载均衡。</li></ul></li><li><p><strong>gRPC (Google Remote Procedure Call)</strong>:</p><ul><li>gRPC是由Google开发的高性能、开源的通用RPC框架。</li><li>gRPC使用Protocol Buffers（protobuf）作为接口定义语言（IDL）和数据序列化格式。</li><li>gRPC支持多种语言，并提供了跨语言的接口调用能力。</li><li>gRPC支持双向流式传输，适合于需要高性能和低延迟的场景，如微服务架构。</li><li>gRPC默认使用HTTP/2作为传输协议，支持多路复用和服务端推送等特性。</li></ul></li></ol><p><strong>关系</strong>:</p><ul><li>RESTful和gRPC都是用于构建分布式系统和微服务的通信协议，但它们的设计理念和使用场景有所不同。</li><li>RESTful更多地依赖于HTTP协议的特性，而gRPC则是一个独立的RPC框架，虽然它也使用了HTTP/2协议，但其核心在于protobuf的序列化和高效的RPC调用。</li><li>在实际应用中，选择RESTful还是gRPC取决于具体的需求，如性能要求、开发语言、团队熟悉度、生态系统支持等。</li></ul><p><strong>总结</strong>:
RESTful和gRPC是两种互补的技术，它们各自在不同的领域和场景中发挥作用。开发者可以根据项目的具体需求和约束来选择最合适的通信方式。</p><h2 id=pbgo和_grpcpbgo文件>.pb.go和_grpc.pb.go文件<a hidden class=anchor aria-hidden=true href=#pbgo和_grpcpbgo文件>#</a></h2><p>在Go语言中使用Protocol Buffers (protobuf) 时，通常会生成两个主要的Go文件，分别是 <code>auth_grpc.pb.go</code> 和 <code>auth.pb.go</code>。这两个文件的作用如下：</p><ol><li><p><strong>auth.pb.go</strong>:</p><ul><li>这个文件是由protobuf编译器根据<code>.proto</code>文件中的消息定义生成的。它包含了所有在<code>.proto</code>文件中定义的消息（messages）、枚举（enums）和任何其他非RPC相关的数据结构的Go语言实现。</li><li><code>auth.pb.go</code> 文件主要负责序列化和反序列化数据，以及提供对消息结构的访问。例如，如果你在<code>.proto</code>文件中定义了一个名为 <code>Token</code> 的消息，<code>auth.pb.go</code> 将包含一个名为 <code>Token</code> 的Go结构体以及用于操作这个结构体的函数，如 <code>Marshal</code>、<code>Unmarshal</code>、<code>New</code> 等。</li></ul></li><li><p><strong>auth_grpc.pb.go</strong>:</p><ul><li>这个文件是由protobuf编译器根据<code>.proto</code>文件中的服务定义（service definitions）生成的，特别是当<code>.proto</code>文件中包含了gRPC服务定义时。</li><li><code>auth_grpc.pb.go</code> 文件包含了gRPC服务的客户端和服务器端的Go语言实现。它定义了用于远程过程调用（RPC）的接口和方法，包括服务端接口（server interfaces）、客户端存根（client stubs）以及用于处理RPC请求和响应的代码。</li><li>例如，如果你在<code>.proto</code>文件中定义了一个名为 <code>AuthService</code> 的gRPC服务，<code>auth_grpc.pb.go</code> 将包含用于实现这个服务的Go接口和方法，如 <code>AuthServiceServer</code>、<code>AuthServiceClient</code> 以及具体的方法实现，如 <code>Login</code>、<code>Logout</code> 等。</li></ul></li></ol><p>总结来说，<code>auth.pb.go</code> 负责处理数据结构和序列化/反序列化，而 <code>auth_grpc.pb.go</code> 负责处理RPC通信和服务的实现。这两个文件共同工作，使得在Go语言中使用protobuf和gRPC变得更加高效和方便。</p><h2 id=auth_grpcpbgo文件结构>auth_grpc.pb.go文件结构<a hidden class=anchor aria-hidden=true href=#auth_grpcpbgo文件结构>#</a></h2><p>在这个 <code>auth_grpc.pb.go</code> 文件中，各个部分的作用如下：</p><ol><li><p><strong>包声明和导入</strong>:</p><ul><li><code>package auth</code> 声明了这个文件属于 <code>auth</code> 包。</li><li><code>import</code> 语句导入了必要的包，如 <code>context</code>、<code>grpc</code>、<code>codes</code> 和 <code>status</code>。</li></ul></li><li><p><strong>常量定义</strong>:</p><ul><li>定义了服务方法的全局唯一方法名，如 <code>AuthService_Login_FullMethodName</code>。</li></ul></li><li><p><strong>客户端接口定义</strong>:</p><ul><li><code>AuthServiceClient</code> 接口定义了客户端可以调用的所有服务方法，如 <code>Login</code>、<code>Verify</code> 等。</li><li><code>authServiceClient</code> 结构体实现了 <code>AuthServiceClient</code> 接口，提供了实际的客户端调用逻辑。</li></ul></li><li><p><strong>服务端接口定义</strong>:</p><ul><li><code>AuthServiceServer</code> 接口定义了服务端需要实现的所有服务方法。</li><li><code>UnimplementedAuthServiceServer</code> 结构体提供了未实现方法的默认实现，通常用于确保服务端实现了所有必要的方法。</li></ul></li><li><p><strong>服务注册</strong>:</p><ul><li><code>RegisterAuthServiceServer</code> 函数用于在 gRPC 服务器上注册 <code>AuthService</code> 服务。</li></ul></li><li><p><strong>服务方法处理函数</strong>:</p><ul><li>如 <code>_AuthService_Login_Handler</code>，这些函数定义了如何处理每个服务方法的请求和响应。</li></ul></li><li><p><strong>服务描述</strong>:</p><ul><li><code>AuthService_ServiceDesc</code> 描述了 <code>AuthService</code> 服务的元数据，包括服务名、处理函数类型、方法列表等。</li></ul></li></ol><p>你的逻辑应该写在服务端接口的实现中。具体来说，你需要创建一个结构体，该结构体实现了 <code>AuthServiceServer</code> 接口，并在该结构体中为每个服务方法提供具体的业务逻辑实现。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>authServiceServer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>UnimplementedAuthServiceServer</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 这里可以添加你的业务逻辑需要的字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>authServiceServer</span><span class=p>)</span> <span class=nf>Login</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>LoginRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>LoginResponse</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 实现登录逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>authServiceServer</span><span class=p>)</span> <span class=nf>Verify</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>VerifyRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>VerifyResponse</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 实现验证逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 实现其他服务方法...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 创建 gRPC 服务器
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>server</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 注册你的服务实现
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>RegisterAuthServiceServer</span><span class=p>(</span><span class=nx>server</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>authServiceServer</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 启动服务器
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>在这个例子中，<code>authServiceServer</code> 结构体实现了 <code>AuthServiceServer</code> 接口，并提供了 <code>Login</code>、<code>Verify</code> 等方法的具体实现。在 <code>main</code> 函数中，你创建了一个 gRPC 服务器，并将你的服务实现注册到服务器上。这样，当客户端调用这些服务方法时，服务器就会执行你提供的逻辑。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></li><li><a href=https://sirius1y.top/tags/protobuf/>Protobuf</a></li><li><a href=https://sirius1y.top/tags/rpc/>Rpc</a></li><li><a href=https://sirius1y.top/tags/dev/>Dev</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/dev/dev-aorb-auth/><span class=title>« Prev</span><br><span>Auth微服务开发记录</span>
</a><a class=next href=https://sirius1y.top/posts/notes/jobhunter/go8/><span class=title>Next »</span><br><span>golang八股文</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>