<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Flutter开发 | Sirius' Blog</title>
<meta name=keywords content="软件开发,flutterzu"><meta name=description content="记录使用Flutter开发Aorb应用前端的过程"><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/dev/dev-aorb-flutter/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/dev/dev-aorb-flutter/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Flutter开发"><meta property="og:description" content="记录使用Flutter开发Aorb应用前端的过程"><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/dev/dev-aorb-flutter/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-24T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Flutter开发"><meta name=twitter:description content="记录使用Flutter开发Aorb应用前端的过程"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"Flutter开发","item":"https://sirius1y.top/posts/notes/dev/dev-aorb-flutter/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flutter开发","name":"Flutter开发","description":"记录使用Flutter开发Aorb应用前端的过程","keywords":["软件开发","flutterzu"],"articleBody":"关键字 late late关键字允许变量将在稍后初始化，但必须在使用之前初始化。\n这与 final 关键字不同，final 关键字用于声明必须在声明时或构造函数运行之前初始化的变量。\nlate 关键字的主要优点是可以提高性能，尤其是在构造函数中包含复杂初始化逻辑的类的情况下。通过使用 late 关键字，您可以推迟初始化，直到实际需要使用该变量时再进行初始化。这可以避免在构造函数中执行不必要的初始化工作，从而提高性能。\n以下是一些有关如何使用 late 关键字的示例：\nclass MyWidget extends StatefulWidget { @override _MyWidgetState createState() =\u003e _MyWidgetState(); } class _MyWidgetState extends State\u003cMyWidget\u003e { late String _data; @override void initState() { super.initState(); // 此处推迟了 _data 变量的初始化 _loadData(); } void _loadData() async { // 模拟异步数据加载 await Future.delayed(Duration(seconds: 2)); setState(() { _data = 'Data loaded'; }); } @override Widget build(BuildContext context) { if (_data == null) { return CircularProgressIndicator(); } return Text(_data); } } 在这个示例中，_data 变量使用 late 关键字声明。这意味着该变量不必在声明时或构造函数运行之前初始化。相反，它可以在稍后初始化，例如在 initState 方法中。这可以提高性能，因为只有在实际需要使用该变量时才会进行初始化。\n请注意，late 关键字只能用于非空类型。这意味着 late 变量不能为 null。如果您需要声明可能为 null 的变量，则可以使用 ? 可空性操作符：late String? _data;\nfinal 在 Dart 中，final 关键字用于定义一个只能被赋值一次的变量。它表示该变量的值在被第一次赋值后不可再更改。这对于创建常量或不希望被重新赋值的变量非常有用。\n使用 final 的场景 局部变量：你可以在函数内部使用 final 来定义局部变量。 类成员变量：你可以在类中使用 final 来定义成员变量。 局部变量：\nvoid main() { final name = 'Alice'; // name = 'Bob'; // 错误：name 已经被赋值，不能再次赋值 print(name); } 类成员变量：\nclass Person { final String name; final int age; Person(this.name, this.age); } void main() { final person = Person('Alice', 30); // person.name = 'Bob'; // 错误：name 是 final 变量，不能修改 print('${person.name}, ${person.age}'); } final 与 const 的区别 final：变量的值只能被赋值一次，但它的值在运行时确定。例如，final 可以用于构造函数参数。 const：变量的值在编译时确定，并且是编译时常量。const 用于定义编译时常量，而 final 只能确保在运行时赋值一次。 变量和函数前的_ 在 Dart 中，变量或函数名前的下划线（_）通常用于表示该成员是私有的。\n但是，重要的是要注意，Dart 中没有真正的私有成员。下划线只是约定，通常由程序员遵循来表明成员不应该从外部类或模块访问。\nasync和await async 关键字用于声明一个函数是异步的。异步函数返回一个 Future 对象，表示该函数将在未来某个时间点完成。\nawait 关键字用于等待一个异步操作完成，并获取其结果。await 只能在 async 函数内部使用。\nimport 'dart:async'; Future\u003cString\u003e fetchUserData() async { // 模拟网络请求 await Future.delayed(Duration(seconds: 2)); return 'User data'; } void main() async { print('Starting...'); String userData = await fetchUserData(); print('Fetched data: $userData'); print('Finished.'); } try,catch,finally try { // 可能抛出异常的代码 } catch (e) { // 处理异常 } finally { // 无论是否发生异常都会执行的代码 } 异步编程 使用Future实现 Future 是 Dart 的一种核心概念，用于处理异步操作。当你有一个 Future，你不能立即得到它的结果，因为它可能还没有完成。你需要等待 Future 完成，或者注册一个回调函数，在 Future 完成时调用。\n和Future有关的方法 Future.value 返回一个future对象\nFuture\u003cString\u003e fetchData() { return Future.value('Data from server'); } Future.then 等待future完成之后进行操作\nFuture.catchError 方法用于捕获和处理 Future 中的错误\nFuture\u003cString\u003e fetchData() { return Future.delayed(Duration(seconds: 2), () { return 'Data from server'; }); } void main() { fetchData().then((data) { print('Data received: $data'); }).catchError((error) { print('Error: $error'); }); } Future.whenComplete whenComplete 方法用于在 Future 完成（无论成功还是失败）后执行回调函数。\nFuture\u003cString\u003e fetchData() { return Future.delayed(Duration(seconds: 2), () { return 'Data from server'; }); } void main() { fetchData().then((data) { print('Data received: $data'); }).catchError((error) { print('Error: $error'); }).whenComplete(() { print('Future completed'); }); } Future.wait Future.wait 方法用于等待多个 Future 全部完成，并返回它们的结果。\nFuture\u003cString\u003e fetchData1() { return Future.delayed(Duration(seconds: 2), () { return 'Data 1 from server'; }); } Future\u003cString\u003e fetchData2() { return Future.delayed(Duration(seconds: 3), () { return 'Data 2 from server'; }); } void main() { Future.wait([fetchData1(), fetchData2()]).then((List\u003cString\u003e results) { print('Data received: ${results[0]}, ${results[1]}'); }).catchError((error) { print('Error: $error'); }); } Future.forEach Future.forEach 方法用于对集合中的每个元素执行异步操作。\nFuture\u003cvoid\u003e processItems(List\u003cint\u003e items) { return Future.forEach(items, (int item) async { await Future.delayed(Duration(seconds: 1)); print('Processed item: $item'); }); } void main() { processItems([1, 2, 3]).then((_) { print('All items processed'); }).catchError((error) { print('Error: $error'); }); } Future实现异步编程的原理 Future 是 Dart 语言中用于处理异步操作的核心机制。它的实现原理基于事件循环（Event Loop）和消息队列（Message Queue）。以下是 Future 实现异步的基本原理：\n事件循环（Event Loop） Dart 是单线程语言，但它通过事件循环机制实现了异步编程。事件循环是一个无限循环，负责处理事件和消息。\n事件循环的启动：当 Dart 程序启动时，事件循环开始运行。 消息队列：事件循环从消息队列中取出消息并处理。消息队列中包含各种事件，如用户输入、网络请求、定时器等。 Future 的工作原理 创建 Future：当你创建一个 Future 时，实际上是将一个任务（回调函数）添加到消息队列中。\nFuture\u003cString\u003e fetchData() { return Future.delayed(Duration(seconds: 2), () { return 'Data from server'; }); } 在这个例子中，Future.delayed 创建了一个 Future，并在2秒后将回调函数添加到消息队列中。\n事件循环处理：事件循环在处理完当前任务后，会从消息队列中取出下一个任务并执行。\n回调函数执行：当事件循环处理到 Future 的回调函数时，回调函数会被执行。如果回调函数返回一个值，这个值会被包装成一个 Future 对象。\n完成 Future：回调函数执行完毕后，Future 被标记为完成，并触发 then 方法中的回调函数。\nfetchData().then((data) { print('Data received: $data'); }); 在这个例子中，then 方法注册的回调函数会在 Future 完成后被调用。\n异步操作的非阻塞特性 由于事件循环和消息队列的存在，Dart 的异步操作不会阻塞主线程。当一个异步操作（如网络请求）开始时，事件循环可以继续处理其他任务，而不是等待异步操作完成。这使得 Dart 程序能够保持响应性。\n总结 Future 实现异步的原理基于事件循环和消息队列。通过将任务添加到消息队列中，事件循环可以在处理完当前任务后，继续处理其他任务，从而实现非阻塞的异步操作。这种机制使得 Dart 程序能够高效地处理异步任务，保持响应性。\n下面这一段来源于博客：作者：GitLqr 链接：https://juejin.cn/post/6949898044628271140 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n事件循环机制 对于用户点击, 滑动, 硬盘 IO 访问等事件, 你不知道何时发生或以什么顺序发生, 所以得有一个永不停歇且不能阻塞的循环来等待处理这些 “突发” 事件. 于是, 基于 事件循环机制 的 单线程模型 就出现了:\nDart 事件循环机制由 一个消息循环(Event Looper) 和 两个消息队列(Event Queue) 构成, 这两个消息队列分别是: 事件队列(Event queue) 和 微任务队列(MicroTask queue).\nEvent Looper Dart 在执行完 main 函数后, Event Looper 就开始工作, Event Looper 优先全部执行完 Microtask Queue 中的 event, 直到 Microtask Queue 为空时, 才会执行 Event Looper 中的 event, Event Looper 为空时才可以退出循环.\n注意: Event Looper 为空时, 是 可以 而不是 一定 要退出, 视场景而定.\nEvent Queue Event Queue` 的 event 来源于 `外部事件` 和 `Future 外部事件: 例如输入/输出, 手势, 绘制, 计时器, Stream 等 Future: 用于自定义 Event Queue 事件 对于外部事件, 一旦没有任何 microtask 要执行, Event loop才会考虑 event queue中的第一项，并且将会执行它.\n通过 Future 实例向 Event Queue 添加事件:\nFuture(() { // 事件任务 }); Microtask Queue Microtask Queue 的优先级高于 Event Queue. 使用场景: 想要在稍后完成一些任务(microtask) 但又希望在执行下一个事件(event)之前执行. Microtask 一般用于非常短的内部异步动作, 并且任务量非常少, 如果微任务非常多, 就会造成 Event Queue 排不上队, 会阻塞 Event Queue 的执行(如: 用户点击没有反应). 所以, 大多数情况下优先考虑使用 Event Queue, 整个 Flutter 源代码仅引用 scheduleMicroTask() 方法 7 次.\n通过 scheduleMicroTask() 函数向 Microtask Queue 添加任务:\nscheduleMicrotask(() { // 微任务 }); 使用Stream实现 Stream 是 Dart 中用于处理一系列异步数据的对象。它可以用于处理连续的数据流，如用户输入、文件读取、网络数据等。\n创建 Stream 你可以使用 StreamController 来创建和管理一个 Stream。\nimport 'dart:async'; void main() { // 创建一个 StreamController final controller = StreamController\u003cint\u003e(); // 获取 Stream final stream = controller.stream; // 监听 Stream stream.listen((data) { print('Received data: $data'); }); // 向 Stream 添加数据 controller.add(1); controller.add(2); controller.add(3); // 关闭 StreamController controller.close(); } 使用 Stream 生成器 你也可以使用 async* 和 yield 关键字来创建一个 Stream。\nimport 'dart:async'; Stream\u003cint\u003e countStream(int to) async* { for (int i = 1; i \u003c= to; i++) { await Future.delayed(Duration(seconds: 1)); // 模拟延迟 yield i; } } void main() { countStream(5).listen((data) { print('Received data: $data'); }); } Stream 的实现原理 Stream 的实现原理基于事件循环（Event Loop）和消息队列（Message Queue）。当你创建一个 Stream 并添加数据时，这些数据会被放入一个内部队列中。当有监听器（listener）监听这个 Stream 时，事件循环会从队列中取出数据并传递给监听器。\n使用Isolate实现 Isolate 是 Dart 的并发模型，用于在单独的线程中执行耗时任务，避免阻塞主线程。每个 Isolate 都有自己的内存和事件循环。\n创建和使用 Isolate 你可以使用 Isolate.spawn 方法来创建一个新的 Isolate，并使用 SendPort 和 ReceivePort 来进行通信。\nimport 'dart:isolate'; void isolateFunction(SendPort sendPort) { int result = 0; for (int i = 0; i \u003c 1000000000; i++) { result += i; } sendPort.send(result); } void main() async { // 创建一个 ReceivePort 来接收消息 ReceivePort receivePort = ReceivePort(); // 创建一个新的 Isolate Isolate.spawn(isolateFunction, receivePort.sendPort); // 监听 ReceivePort receivePort.listen((message) { print('Result from isolate: $message'); }); } Isolate 的实现原理 Isolate 的实现原理基于 Dart 的并发模型。每个 Isolate 都有自己的内存空间和事件循环，它们之间通过消息传递进行通信。当你创建一个新的 Isolate 时，Dart 会在一个新的线程中运行这个 Isolate，并在主线程和子线程之间建立一个消息通道（SendPort 和 ReceivePort）。通过这个消息通道，你可以安全地在不同的 Isolate 之间传递数据。\n总结 Future：适用于处理单个异步操作，基于事件循环和消息队列。 Stream：适用于处理连续的异步数据流，基于事件循环和消息队列。 Isolate：适用于处理耗时任务，基于 Dart 的并发模型和消息传递。 渲染机制 https://juejin.cn/post/6973818961724964901\n三棵树：widget, element, RenderObjects树\nWidget：Widget是Flutter的核心部分，是用户界面的不可变描述。做Flutter开发接触最多的就是Widget，可以说Widget撑起了Flutter的半边天； Element：Element是实例化的 Widget 对象，通过 Widget 的 createElement() 方法，是在特定位置使用 Widget配置数据生成； RenderObject：用于应用界面的布局和绘制，保存了元素的大小，布局等信息； https://www.geekailab.com/2021/01/10/Flutter-three-tree/\n组件 StatefulWidget和StatelessWidget 在 Flutter 中，StatefulWidget 和 StatelessWidget 是两种基本的小部件类型，用于构建用户界面。它们的主要区别在于它们如何管理状态。\n无状态小部件StatefulWidget 无状态小部件没有内部状态。这意味着它们的输出完全由它们的输入和构建时提供的属性决定。无状态小部件在整个生命周期中保持不变，不会因用户交互或其他外部因素而重新渲染。\n创建无状态小部件类的最简单方法是继承 StatelessWidget 类并重写 build 方法。build 方法必须返回一个 Widget，该小部件将呈现到屏幕上。\nclass MyStatelessWidget extends StatelessWidget { @override Widget build(BuildContext context) { return Text('Hello, World!'); } } 有状态小部件StatelessWidget 有状态小部件包含内部状态，可能会随着时间的推移而改变。此状态用于控制小部件的输出。有状态小部件会在其状态发生变化时重新渲染。\n要创建状态有状态小部件类，您需要继承 StatefulWidget 类并创建一个 State 类。State 类包含小部件的状态并提供以下方法：\ninitState：此方法将在小部件首次创建时调用。您可以使用它来初始化小部件的状态。 didChangeDependencies：此方法将在小部件的依赖项更改时调用。您可以使用它来响应其他小部件的状态变化。 build：此方法与无状态小部件的 build 方法相同。它用于构建小部件将呈现到屏幕上的内容。 setState：此方法用于更新小部件的状态。这将导致小部件重新渲染。 class MyStatefulWidget extends StatefulWidget { @override _MyStatefulWidgetState createState() =\u003e _MyStatefulWidgetState(); } class _MyStatefulWidgetState extends State\u003cMyStatefulWidget\u003e { int _counter = 0; @override void initState() { super.initState(); } @override Widget build(BuildContext context) { return Text('Counter: $_counter'); } void incrementCounter() { setState(() { _counter++; }); } } 创建继承它们的类的方法有什么不同？ 创建继承 StatelessWidget 和 StatefulWidget 的类的方法的主要区别在于：\n无状态小部件 只需要重写 build 方法。 有状态小部件 需要创建一个 State 类并重写 initState、didChangeDependencies、build 和 setState 方法。 此外，有状态小部件通常需要使用 setState 方法来更新其状态。这会导致小部件重新渲染，并反映状态的变化。\n何时使用无状态小部件？ 小部件没有内部状态。 小部件的输出完全由其输入和属性决定。 小部件不需要响应用户交互或其他外部因素。 示例\n以下是一个无状态小部件的示例，它显示一个文本小部件，其中包含“Hello, World!”：\nclass MyStatelessWidget extends StatelessWidget { @override Widget build(BuildContext context) { return Text('Hello, World!'); } } 以下是一个有状态小部件的示例，它显示一个计数器小部件，用户可以点击它来增加计数：\nclass MyStatefulWidget extends StatefulWidget { @override _MyStatefulWidgetState createState() =\u003e _MyStatefulWidgetState(); } class _MyStatefulWidgetState extends State\u003cMyStatefulWidget\u003e { int _counter = 0; @override Widget build(BuildContext context) { return Text('Counter: $_counter'); } void incrementCounter() { setState(() { _counter++; }); } } AppBar设计 关于appbar的参数：https://juejin.cn/post/7143181602124726308\n想要做成小红书这种，左边目录，中间“关注/推荐”，右边搜索，就直接在appbar的title参数里面加入“关注/推荐”\n@override Widget build(BuildContext context) { return AppBar( elevation: 0, backgroundColor: Colors.white, leading: IconButton( icon: const Icon(Icons.menu, color: Colors.blue), onPressed: () { // Scaffold.of(context).openDrawer(); }, ), title: Row( children: [ const SizedBox(width: 25), Expanded( child: TabBar( controller: _tabController, tabs: widget.tabs.map((tab) =\u003e Tab(text: tab)).toList(), labelColor: Colors.blue, unselectedLabelColor: Colors.grey, indicatorSize: TabBarIndicatorSize.label, indicatorWeight: 3, ), ), const SizedBox(width: 25), ], ), actions: widget.showSearch ? [ IconButton( icon: const Icon(Icons.search, color: Colors.blue), onPressed: () { // 跳转到搜索页面 }, ) ] : [], ); } Expanded：占据剩余空间 这里有一篇文章有两个对比用不用expanded：https://stackoverflow.com/questions/68539642/how-expanded-widget-works-in-flutter\n个人感受就是组件expaned的高度是根据父组件的高度自适应分配，弹性布局的意思。\nLayoutBuilder：获取一个组件的宽度 要获取最外层容器的宽度，你需要确保容器在布局过程中已经完成测量。在 Flutter 中，你可以使用 LayoutBuilder 小部件来获取布局约束，其中包含了容器的最大宽度。\n下面是一个示例，展示了如何使用 LayoutBuilder 来获取 Container 的宽度：\nContainer( child: LayoutBuilder( builder: (BuildContext context, BoxConstraints constraints) { // 获取Container的最大宽度 double containerWidth = constraints.maxWidth; // 使用containerWidth进行后续操作 // ... return ElevatedButton( // ... 其他按钮属性 child: Stack( children: [ if (_selectedOption != -1) Positioned( left: 0, top: 0, child: Container( height: 20, width: containerWidth * votePercentage[i], // 使用containerWidth来设置宽度 decoration: BoxDecoration( color: _selectedOption == i ? colorPercents[i + 1] : colorPercents[0], borderRadius: BorderRadius.circular(10), ), ), ), Align( alignment: Alignment.center, child: Text(text[i]), ), ], ), ); }, ), ); 在这个例子中，LayoutBuilder 会为其子级提供一个回调函数，该函数会在布局过程完成后被调用。BoxConstraints 参数包含了子级在布局过程中的约束信息，其中 maxWidth 属性就是容器的最大宽度。\n请注意，LayoutBuilder 本身并不直接参与布局，它只是提供了一个回调函数来获取布局约束。如果你需要在布局过程中动态设置容器的宽度，你可能需要使用 LayoutBuilder 来获取约束，然后根据这些约束来设置容器的宽度。\n确保 LayoutBuilder 小部件是 Container 的直接子级，这样它才能正确地获取到 Container 的布局约束。如果 Container 是其他小部件的子级，你可能需要调整你的小部件树结构以确保 LayoutBuilder 可以正确地获取到 Container 的宽度。\n在外层调用openDrawer() 在Flutter中，Scaffold.of(context).openDrawer() 方法是如何工作的呢？当你调用 Scaffold.of(context).openDrawer() 时，Flutter实际上是在当前的 BuildContext 中查找最近的 Scaffold 组件，并调用它的 openDrawer() 方法。\nBuildContext 是一个非常重要的概念，它代表了在widget树中的位置和层次结构。当你调用 Scaffold.of(context) 时，Flutter会从当前的widget开始向上遍历widget树，直到找到最近的 Scaffold 组件。\n在你的代码中，当你点击 AppBar 中的菜单按钮时，onPressed 回调函数是在 DynamicTopBar 内部定义的。但是，Scaffold.of(context).openDrawer() 方法是在 AppBar 内部调用的，它是在 DynamicTopBar 内部定义的 AppBar 小部件中调用的。\nScaffold.of(context) 方法会沿着widget树向上查找最近的 Scaffold 组件，并返回它。在这个例子中，由于 AppBar 是 Scaffold 的子部件，Scaffold.of(context) 会找到 Scaffold 并调用它的 openDrawer() 方法。\n所以，Scaffold.of(context).openDrawer() 是如何工作的，是因为它在widget树中向上查找最近的 Scaffold 组件，并调用它的 openDrawer() 方法。\nTabController：顶部栏内容滑动更新 通过tabController实现，可以传递这个参数进一个子组件实现控制。\nimport 'package:flutter/material.dart'; class DynamicTopBar extends StatelessWidget implements PreferredSizeWidget { final List\u003cString\u003e tabs; final bool showSearch; final TabController tabController; // 接受外部提供的TabController const DynamicTopBar({ Key? key, required this.tabs, this.showSearch = true, required this.tabController, }) : super(key: key); @override Size get preferredSize =\u003e const Size.fromHeight(kToolbarHeight); @override Widget build(BuildContext context) { return AppBar( elevation: 0, backgroundColor: Colors.white, leading: IconButton( icon: Icon(Icons.menu, color: Colors.blue[700]), onPressed: () { Scaffold.of(context).openDrawer(); }, ), title: Row( children: [ const SizedBox(width: 25), Expanded( child: TabBar( controller: tabController, // 使用传入的TabController tabs: tabs.map((tab) =\u003e Tab(text: tab)).toList(), labelColor: Colors.blue[700], labelStyle: const TextStyle( fontSize: 20, fontFamily: 'SimHei', fontWeight: FontWeight.bold, ), unselectedLabelColor: Colors.grey[400], indicatorSize: TabBarIndicatorSize.label, indicatorWeight: 3, indicatorColor: Colors.blue[700], ), ), const SizedBox(width: 25), ], ), actions: showSearch ? [ IconButton( icon: Icon(Icons.search, color: Colors.blue[700]), onPressed: () { // 跳转到搜索页面 }, ) ] : [], ); } } 页面逻辑 前端如何判断用户是否登录 在Flutter中，常见的存储和管理JWT的方法包括使用shared_preferences插件来在本地存储和检索JWT，并在需要时进行验证。以下是详细的步骤和示例代码：\n1. 添加依赖 首先，需要在pubspec.yaml文件中添加shared_preferences依赖：\ndependencies: flutter: sdk: flutter shared_preferences: ^2.0.9 2. 存储JWT 当用户登录成功后，可以将后端返回的JWT存储在本地存储中：\nimport 'package:shared_preferences/shared_preferences.dart'; Future\u003cvoid\u003e saveToken(String token) async { final prefs = await SharedPreferences.getInstance(); await prefs.setString('authToken', token); } 3. 检查用户是否登录 在“我的”界面中，可以通过检查本地存储中的JWT来判断用户是否已经登录：\nimport 'package:flutter/material.dart'; import 'package:shared_preferences/shared_preferences.dart'; class MyPage extends StatefulWidget { @override _MyPageState createState() =\u003e _MyPageState(); } class _MyPageState extends State\u003cMyPage\u003e { bool isLoggedIn = false; @override void initState() { super.initState(); checkLoginStatus(); } Future\u003cvoid\u003e checkLoginStatus() async { final prefs = await SharedPreferences.getInstance(); final token = prefs.getString('authToken'); if (token != null) { // 这里可以进一步验证token的有效性 setState(() { isLoggedIn = true; }); } else { setState(() { isLoggedIn = false; }); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('我的页面'), ), body: Center( child: isLoggedIn ? LoggedInWidget() : LoggedOutWidget(), ), ); } } class LoggedInWidget extends StatelessWidget { @override Widget build(BuildContext context) { return Text('欢迎回来，用户已登录'); } } class LoggedOutWidget extends StatelessWidget { @override Widget build(BuildContext context) { return Text('请登录'); } } 4. 清除JWT（用户登出） 当用户登出时，可以清除本地存储中的JWT：\nFuture\u003cvoid\u003e logout() async { final prefs = await SharedPreferences.getInstance(); await prefs.remove('authToken'); } 通过以上步骤，您可以在Flutter应用中存储JWT并在需要时检查用户的登录状态。这样，无论是安卓还是iOS，您都可以确保用户的登录状态得到正确的管理和验证。\n","wordCount":"1578","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-05-24T00:00:00Z","dateModified":"2024-05-24T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/dev/dev-aorb-flutter/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Flutter开发</h1><div class=post-description>记录使用Flutter开发Aorb应用前端的过程</div><div class=post-meta><span title='2024-05-24 00:00:00 +0000 UTC'>May 24, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1578 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%85%b3%e9%94%ae%e5%ad%97 aria-label=关键字>关键字</a><ul><li><a href=#late aria-label=late>late</a></li><li><a href=#final aria-label=final>final</a><ul><li><a href=#%e4%bd%bf%e7%94%a8-final-%e7%9a%84%e5%9c%ba%e6%99%af aria-label="使用 final 的场景">使用 <code>final</code> 的场景</a></li><li><a href=#final-%e4%b8%8e-const-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="final 与 const 的区别"><code>final</code> 与 <code>const</code> 的区别</a></li></ul></li><li><a href=#%e5%8f%98%e9%87%8f%e5%92%8c%e5%87%bd%e6%95%b0%e5%89%8d%e7%9a%84_ aria-label=变量和函数前的_>变量和函数前的_</a></li><li><a href=#async%e5%92%8cawait aria-label=async和await>async和await</a></li><li><a href=#trycatchfinally aria-label=try,catch,finally>try,catch,finally</a></li></ul></li><li><a href=#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b aria-label=异步编程>异步编程</a><ul><li><a href=#%e4%bd%bf%e7%94%a8future%e5%ae%9e%e7%8e%b0 aria-label=使用Future实现>使用Future实现</a><ul><li><a href=#%e5%92%8cfuture%e6%9c%89%e5%85%b3%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=和Future有关的方法>和Future有关的方法</a><ul><li><a href=#futurevalue aria-label=Future.value>Future.value</a></li><li><a href=#futurethen aria-label=Future.then>Future.then</a></li><li><a href=#futurecatcherror aria-label=Future.catchError>Future.catchError</a></li><li><a href=#futurewhencomplete aria-label=Future.whenComplete>Future.whenComplete</a></li><li><a href=#futurewait aria-label=Future.wait>Future.wait</a></li><li><a href=#futureforeach aria-label=Future.forEach>Future.forEach</a></li></ul></li><li><a href=#future%e5%ae%9e%e7%8e%b0%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e5%8e%9f%e7%90%86 aria-label=Future实现异步编程的原理>Future实现异步编程的原理</a><ul><li><a href=#%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%afevent-loop aria-label="事件循环（Event Loop）">事件循环（Event Loop）</a></li><li><a href=#future-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label="Future 的工作原理">Future 的工作原理</a></li><li><a href=#%e5%bc%82%e6%ad%a5%e6%93%8d%e4%bd%9c%e7%9a%84%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%89%b9%e6%80%a7 aria-label=异步操作的非阻塞特性>异步操作的非阻塞特性</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li><li><a href=#%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6 aria-label=事件循环机制>事件循环机制</a><ul><li><a href=#event-looper aria-label="Event Looper">Event Looper</a></li><li><a href=#event-queue aria-label="Event Queue">Event Queue</a></li><li><a href=#microtask-queue aria-label="Microtask Queue">Microtask Queue</a></li></ul></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8stream%e5%ae%9e%e7%8e%b0 aria-label=使用Stream实现>使用Stream实现</a><ul><li><a href=#%e5%88%9b%e5%bb%ba-stream aria-label="创建 Stream">创建 Stream</a></li><li><a href=#%e4%bd%bf%e7%94%a8-stream-%e7%94%9f%e6%88%90%e5%99%a8 aria-label="使用 Stream 生成器">使用 Stream 生成器</a></li><li><a href=#stream-%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label="Stream 的实现原理">Stream 的实现原理</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8isolate%e5%ae%9e%e7%8e%b0 aria-label=使用Isolate实现>使用Isolate实现</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e5%92%8c%e4%bd%bf%e7%94%a8-isolate aria-label="创建和使用 Isolate">创建和使用 Isolate</a></li><li><a href=#isolate-%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label="Isolate 的实现原理">Isolate 的实现原理</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93-1 aria-label=总结>总结</a></li></ul></li><li><a href=#%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6 aria-label=渲染机制>渲染机制</a></li><li><a href=#%e7%bb%84%e4%bb%b6 aria-label=组件>组件</a><ul><li><a href=#statefulwidget%e5%92%8cstatelesswidget aria-label=StatefulWidget和StatelessWidget>StatefulWidget和StatelessWidget</a><ul><ul><li><a href=#%e6%97%a0%e7%8a%b6%e6%80%81%e5%b0%8f%e9%83%a8%e4%bb%b6statefulwidget aria-label=无状态小部件StatefulWidget><strong>无状态小部件</strong>StatefulWidget</a></li><li><a href=#%e6%9c%89%e7%8a%b6%e6%80%81%e5%b0%8f%e9%83%a8%e4%bb%b6statelesswidget aria-label=有状态小部件StatelessWidget><strong>有状态小部件</strong>StatelessWidget</a></li></ul><li><a href=#%e5%88%9b%e5%bb%ba%e7%bb%a7%e6%89%bf%e5%ae%83%e4%bb%ac%e7%9a%84%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95%e6%9c%89%e4%bb%80%e4%b9%88%e4%b8%8d%e5%90%8c aria-label=创建继承它们的类的方法有什么不同？><strong>创建继承它们的类的方法有什么不同？</strong></a></li><li><a href=#%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8%e6%97%a0%e7%8a%b6%e6%80%81%e5%b0%8f%e9%83%a8%e4%bb%b6 aria-label=何时使用无状态小部件？><strong>何时使用无状态小部件？</strong></a></li></ul></li><li><a href=#appbar%e8%ae%be%e8%ae%a1 aria-label=AppBar设计>AppBar设计</a></li><li><a href=#expanded%e5%8d%a0%e6%8d%ae%e5%89%a9%e4%bd%99%e7%a9%ba%e9%97%b4 aria-label=Expanded：占据剩余空间>Expanded：占据剩余空间</a></li><li><a href=#layoutbuilder%e8%8e%b7%e5%8f%96%e4%b8%80%e4%b8%aa%e7%bb%84%e4%bb%b6%e7%9a%84%e5%ae%bd%e5%ba%a6 aria-label=LayoutBuilder：获取一个组件的宽度>LayoutBuilder：获取一个组件的宽度</a></li><li><a href=#%e5%9c%a8%e5%a4%96%e5%b1%82%e8%b0%83%e7%94%a8opendrawer aria-label=在外层调用openDrawer()>在外层调用openDrawer()</a></li><li><a href=#tabcontroller%e9%a1%b6%e9%83%a8%e6%a0%8f%e5%86%85%e5%ae%b9%e6%bb%91%e5%8a%a8%e6%9b%b4%e6%96%b0 aria-label=TabController：顶部栏内容滑动更新>TabController：顶部栏内容滑动更新</a></li></ul></li><li><a href=#%e9%a1%b5%e9%9d%a2%e9%80%bb%e8%be%91 aria-label=页面逻辑>页面逻辑</a><ul><li><a href=#%e5%89%8d%e7%ab%af%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e7%94%a8%e6%88%b7%e6%98%af%e5%90%a6%e7%99%bb%e5%bd%95 aria-label=前端如何判断用户是否登录>前端如何判断用户是否登录</a><ul><li><a href=#1-%e6%b7%bb%e5%8a%a0%e4%be%9d%e8%b5%96 aria-label="1. 添加依赖">1. 添加依赖</a></li><li><a href=#2-%e5%ad%98%e5%82%a8jwt aria-label="2. 存储JWT">2. 存储JWT</a></li><li><a href=#3-%e6%a3%80%e6%9f%a5%e7%94%a8%e6%88%b7%e6%98%af%e5%90%a6%e7%99%bb%e5%bd%95 aria-label="3. 检查用户是否登录">3. 检查用户是否登录</a></li><li><a href=#4-%e6%b8%85%e9%99%a4jwt%e7%94%a8%e6%88%b7%e7%99%bb%e5%87%ba aria-label="4. 清除JWT（用户登出）">4. 清除JWT（用户登出）</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=关键字>关键字<a hidden class=anchor aria-hidden=true href=#关键字>#</a></h1><h2 id=late>late<a hidden class=anchor aria-hidden=true href=#late>#</a></h2><p><code>late</code>关键字允许变量将在稍后初始化，但必须在使用之前初始化。</p><blockquote><p>这与 <code>final</code> 关键字不同，<code>final</code> 关键字用于声明必须在声明时或构造函数运行之前初始化的变量。</p></blockquote><p><code>late</code> 关键字的主要优点是可以提高性能，尤其是在构造函数中包含复杂初始化逻辑的类的情况下。通过使用 <code>late</code> 关键字，您可以推迟初始化，直到实际需要使用该变量时再进行初始化。这可以<strong>避免在构造函数中执行不必要的初始化工作</strong>，从而提高性能。</p><p>以下是一些有关如何使用 <code>late</code> 关键字的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dart data-lang=Dart><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyWidget</span> <span class=kd>extends</span> <span class=n>StatefulWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>_MyWidgetState</span> <span class=n>createState</span><span class=p>()</span> <span class=o>=&gt;</span> <span class=n>_MyWidgetState</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>_MyWidgetState</span> <span class=kd>extends</span> <span class=n>State</span><span class=o>&lt;</span><span class=n>MyWidget</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>late</span> <span class=kt>String</span> <span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>initState</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>initState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 此处推迟了 _data 变量的初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>_loadData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>_loadData</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 模拟异步数据加载
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>await</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>setState</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>_data</span> <span class=o>=</span> <span class=s1>&#39;Data loaded&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>_data</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>CircularProgressIndicator</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Text</span><span class=p>(</span><span class=n>_data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这个示例中，<code>_data</code> 变量使用 <code>late</code> 关键字声明。这意味着该变量不必在声明时或构造函数运行之前初始化。相反，它可以在稍后初始化，例如在 <code>initState</code> 方法中。这可以提高性能，因为只有在实际需要使用该变量时才会进行初始化。</p><p>请注意，<code>late</code> 关键字只能用于非空类型。这意味着 <code>late</code> 变量不能为 null。如果您需要声明可能为 null 的变量，则可以使用 <code>?</code> 可空性操作符：<code>late String? _data;</code></p><h2 id=final>final<a hidden class=anchor aria-hidden=true href=#final>#</a></h2><p>在 Dart 中，<code>final</code> 关键字用于定义一个只能被赋值一次的变量。它表示该变量的值在被第一次赋值后不可再更改。这对于创建常量或不希望被重新赋值的变量非常有用。</p><h3 id=使用-final-的场景>使用 <code>final</code> 的场景<a hidden class=anchor aria-hidden=true href=#使用-final-的场景>#</a></h3><ol><li><strong>局部变量</strong>：你可以在函数内部使用 <code>final</code> 来定义局部变量。</li><li><strong>类成员变量</strong>：你可以在类中使用 <code>final</code> 来定义成员变量。</li></ol><p><strong>局部变量</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>name</span> <span class=o>=</span> <span class=s1>&#39;Alice&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// name = &#39;Bob&#39;; // 错误：name 已经被赋值，不能再次赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>print</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>类成员变量</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=kt>String</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Person</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=n>name</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=n>age</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>person</span> <span class=o>=</span> <span class=n>Person</span><span class=p>(</span><span class=s1>&#39;Alice&#39;</span><span class=p>,</span> <span class=m>30</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// person.name = &#39;Bob&#39;; // 错误：name 是 final 变量，不能修改
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>${</span><span class=n>person</span><span class=p>.</span><span class=n>name</span><span class=si>}</span><span class=s1>, </span><span class=si>${</span><span class=n>person</span><span class=p>.</span><span class=n>age</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=final-与-const-的区别><code>final</code> 与 <code>const</code> 的区别<a hidden class=anchor aria-hidden=true href=#final-与-const-的区别>#</a></h3><ul><li><code>final</code>：变量的值只能被赋值一次，但它的值在<strong>运行时确定</strong>。例如，<code>final</code> 可以用于构造函数参数。</li><li><code>const</code>：变量的值在<strong>编译时确定</strong>，并且是编译时常量。<code>const</code> 用于定义编译时常量，而 <code>final</code> 只能确保在运行时赋值一次。</li></ul><h2 id=变量和函数前的_>变量和函数前的_<a hidden class=anchor aria-hidden=true href=#变量和函数前的_>#</a></h2><p>在 Dart 中，变量或函数名前的下划线（<code>_</code>）通常用于表示该成员是私有的。</p><p>但是，重要的是要注意，Dart 中没有真正的私有成员。下划线只是约定，通常由程序员遵循来表明成员不应该从外部类或模块访问。</p><h2 id=async和await>async和await<a hidden class=anchor aria-hidden=true href=#async和await>#</a></h2><p><code>async</code> 关键字用于声明一个函数是异步的。异步函数返回一个 <code>Future</code> 对象，表示该函数将在未来某个时间点完成。</p><p><code>await</code> 关键字用于等待一个异步操作完成，并获取其结果。<code>await</code> 只能在 <code>async</code> 函数内部使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;dart:async&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>fetchUserData</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 模拟网络请求
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>await</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=s1>&#39;User data&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Starting...&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>String</span> <span class=n>userData</span> <span class=o>=</span> <span class=kd>await</span> <span class=n>fetchUserData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Fetched data: </span><span class=si>$</span><span class=n>userData</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Finished.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=trycatchfinally>try,catch,finally<a hidden class=anchor aria-hidden=true href=#trycatchfinally>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 可能抛出异常的代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 处理异常
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 无论是否发生异常都会执行的代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h1 id=异步编程>异步编程<a hidden class=anchor aria-hidden=true href=#异步编程>#</a></h1><h2 id=使用future实现>使用Future实现<a hidden class=anchor aria-hidden=true href=#使用future实现>#</a></h2><p><code>Future</code> 是 Dart 的一种核心概念，用于处理异步操作。<strong>当你有一个 <code>Future</code>，你不能立即得到它的结果</strong>，因为它可能还没有完成。你<strong>需要等待 <code>Future</code> 完成，或者注册一个回调函数，在 <code>Future</code> 完成时调用</strong>。</p><h3 id=和future有关的方法>和Future有关的方法<a hidden class=anchor aria-hidden=true href=#和future有关的方法>#</a></h3><h4 id=futurevalue>Future.value<a hidden class=anchor aria-hidden=true href=#futurevalue>#</a></h4><p>返回一个future对象</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>fetchData</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Future</span><span class=p>.</span><span class=n>value</span><span class=p>(</span><span class=s1>&#39;Data from server&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=futurethen>Future.then<a hidden class=anchor aria-hidden=true href=#futurethen>#</a></h4><p>等待future完成之后进行操作</p><h4 id=futurecatcherror>Future.catchError<a hidden class=anchor aria-hidden=true href=#futurecatcherror>#</a></h4><p>方法用于捕获和处理 <code>Future</code> 中的错误</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>fetchData</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>2</span><span class=p>),</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;Data from server&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>fetchData</span><span class=p>().</span><span class=n>then</span><span class=p>((</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Data received: </span><span class=si>$</span><span class=n>data</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}).</span><span class=n>catchError</span><span class=p>((</span><span class=n>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Error: </span><span class=si>$</span><span class=n>error</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=futurewhencomplete>Future.whenComplete<a hidden class=anchor aria-hidden=true href=#futurewhencomplete>#</a></h4><p><code>whenComplete</code> 方法用于在 <code>Future</code> 完成（无论成功还是失败）后执行回调函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>fetchData</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>2</span><span class=p>),</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;Data from server&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>fetchData</span><span class=p>().</span><span class=n>then</span><span class=p>((</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Data received: </span><span class=si>$</span><span class=n>data</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}).</span><span class=n>catchError</span><span class=p>((</span><span class=n>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Error: </span><span class=si>$</span><span class=n>error</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}).</span><span class=n>whenComplete</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Future completed&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=futurewait>Future.wait<a hidden class=anchor aria-hidden=true href=#futurewait>#</a></h4><p><code>Future.wait</code> 方法用于等待多个 <code>Future</code> 全部完成，并返回它们的结果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>fetchData1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>2</span><span class=p>),</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;Data 1 from server&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>fetchData2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>3</span><span class=p>),</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;Data 2 from server&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Future</span><span class=p>.</span><span class=n>wait</span><span class=p>([</span><span class=n>fetchData1</span><span class=p>(),</span> <span class=n>fetchData2</span><span class=p>()]).</span><span class=n>then</span><span class=p>((</span><span class=n>List</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>results</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Data received: </span><span class=si>${</span><span class=n>results</span><span class=p>[</span><span class=m>0</span><span class=p>]</span><span class=si>}</span><span class=s1>, </span><span class=si>${</span><span class=n>results</span><span class=p>[</span><span class=m>1</span><span class=p>]</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}).</span><span class=n>catchError</span><span class=p>((</span><span class=n>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Error: </span><span class=si>$</span><span class=n>error</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=futureforeach>Future.forEach<a hidden class=anchor aria-hidden=true href=#futureforeach>#</a></h4><p><code>Future.forEach</code> 方法用于对集合中的每个元素执行异步操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>processItems</span><span class=p>(</span><span class=n>List</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>items</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Future</span><span class=p>.</span><span class=n>forEach</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span> <span class=n>item</span><span class=p>)</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>await</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Processed item: </span><span class=si>$</span><span class=n>item</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>processItems</span><span class=p>([</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>]).</span><span class=n>then</span><span class=p>((</span><span class=n>_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;All items processed&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}).</span><span class=n>catchError</span><span class=p>((</span><span class=n>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Error: </span><span class=si>$</span><span class=n>error</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=future实现异步编程的原理>Future实现异步编程的原理<a hidden class=anchor aria-hidden=true href=#future实现异步编程的原理>#</a></h3><p><code>Future</code> 是 Dart 语言中用于处理异步操作的核心机制。它的实现原理基于<strong>事件循环</strong>（Event Loop）和<strong>消息队列</strong>（Message Queue）。以下是 <code>Future</code> 实现异步的基本原理：</p><h4 id=事件循环event-loop>事件循环（Event Loop）<a hidden class=anchor aria-hidden=true href=#事件循环event-loop>#</a></h4><p>Dart 是单线程语言，但它通过事件循环机制实现了异步编程。事件循环是一个无限循环，负责处理事件和消息。</p><ol><li><strong>事件循环的启动</strong>：当 Dart 程序启动时，事件循环开始运行。</li><li><strong>消息队列</strong>：事件循环从消息队列中取出消息并处理。消息队列中包含各种事件，如用户输入、网络请求、定时器等。</li></ol><h4 id=future-的工作原理>Future 的工作原理<a hidden class=anchor aria-hidden=true href=#future-的工作原理>#</a></h4><ol><li><p><strong>创建 Future</strong>：当你创建一个 <code>Future</code> 时，实际上是将一个任务（回调函数）添加到消息队列中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>fetchData</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>2</span><span class=p>),</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;Data from server&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这个例子中，<code>Future.delayed</code> 创建了一个 <code>Future</code>，并在2秒后将回调函数添加到消息队列中。</p></li><li><p><strong>事件循环处理</strong>：事件循环在处理完当前任务后，会从消息队列中取出下一个任务并执行。</p></li><li><p><strong>回调函数执行</strong>：当事件循环处理到 <code>Future</code> 的回调函数时，回调函数会被执行。如果回调函数返回一个值，这个值会被包装成一个 <code>Future</code> 对象。</p></li><li><p><strong>完成 Future</strong>：回调函数执行完毕后，<code>Future</code> 被标记为完成，并触发 <code>then</code> 方法中的回调函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>fetchData</span><span class=p>().</span><span class=n>then</span><span class=p>((</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Data received: </span><span class=si>$</span><span class=n>data</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>在这个例子中，<code>then</code> 方法注册的回调函数会在 <code>Future</code> 完成后被调用。</p></li></ol><h4 id=异步操作的非阻塞特性>异步操作的非阻塞特性<a hidden class=anchor aria-hidden=true href=#异步操作的非阻塞特性>#</a></h4><p>由于事件循环和消息队列的存在，Dart 的异步操作不会阻塞主线程。当一个异步操作（如网络请求）开始时，事件循环可以继续处理其他任务，而不是等待异步操作完成。这使得 Dart 程序能够保持响应性。</p><h4 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h4><p><code>Future</code> 实现异步的原理基于事件循环和消息队列。通过将任务添加到消息队列中，事件循环可以在处理完当前任务后，继续处理其他任务，从而实现非阻塞的异步操作。这种机制使得 Dart 程序能够高效地处理异步任务，保持响应性。</p><blockquote><p>下面这一段来源于博客：作者：GitLqr
链接：https://juejin.cn/post/6949898044628271140
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h3 id=事件循环机制>事件循环机制<a hidden class=anchor aria-hidden=true href=#事件循环机制>#</a></h3><p>对于用户点击, 滑动, 硬盘 IO 访问等事件, 你不知道何时发生或以什么顺序发生, 所以得有一个永不停歇且不能阻塞的循环来等待处理这些 &ldquo;突发&rdquo; 事件. 于是, 基于 <code>事件循环机制</code> 的 <code>单线程模型</code> 就出现了:</p><p><img loading=lazy src=https://s2.loli.net/2024/06/24/kPhnqV1gOjLeDQr.webp alt=img></p><p>Dart 事件循环机制由 一个<code>消息循环(Event Looper)</code> 和 两个<code>消息队列(Event Queue)</code> 构成, 这两个消息队列分别是: <code>事件队列(Event queue)</code> 和 <code>微任务队列(MicroTask queue)</code>.</p><h4 id=event-looper>Event Looper<a hidden class=anchor aria-hidden=true href=#event-looper>#</a></h4><p>Dart 在执行完 main 函数后, <code>Event Looper</code> 就开始工作, <code>Event Looper</code> 优先全部执行完 <code>Microtask Queue</code> 中的 event, 直到 <code>Microtask Queue</code> 为空时, 才会执行 <code>Event Looper</code> 中的 event, <code>Event Looper</code> 为空时才可以退出循环.</p><blockquote><p>注意: <code>Event Looper</code> 为空时, 是 <code>可以</code> 而不是 <code>一定</code> 要退出, 视场景而定.</p></blockquote><p><img loading=lazy src=https://s2.loli.net/2024/06/24/5zdW1F4faNKQlMU.webp alt=img></p><h4 id=event-queue>Event Queue<a hidden class=anchor aria-hidden=true href=#event-queue>#</a></h4><pre tabindex=0><code>Event Queue` 的 event 来源于 `外部事件` 和 `Future
</code></pre><ul><li>外部事件: 例如输入/输出, 手势, 绘制, 计时器, Stream 等</li><li>Future: 用于自定义 Event Queue 事件</li></ul><blockquote><p>对于外部事件, 一旦没有任何 microtask 要执行, Event loop才会考虑 event queue中的第一项，并且将会执行它.</p></blockquote><p>通过 Future 实例向 Event Queue 添加事件:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 事件任务
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span></code></pre></div><h4 id=microtask-queue>Microtask Queue<a hidden class=anchor aria-hidden=true href=#microtask-queue>#</a></h4><ul><li><code>Microtask Queue</code> 的优先级高于 <code>Event Queue</code>.</li><li>使用场景: 想要在稍后完成一些任务(microtask) 但又希望在执行下一个事件(event)之前执行.</li></ul><blockquote><p>Microtask 一般用于非常短的内部异步动作, 并且任务量非常少, 如果微任务非常多, 就会造成 Event Queue 排不上队, 会阻塞 Event Queue 的执行(如: 用户点击没有反应). 所以, 大多数情况下优先考虑使用 Event Queue, 整个 Flutter 源代码仅引用 <code>scheduleMicroTask()</code> 方法 7 次.</p></blockquote><p>通过 <code>scheduleMicroTask()</code> 函数向 Microtask Queue 添加任务:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>scheduleMicrotask</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 微任务
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span></code></pre></div><h2 id=使用stream实现>使用Stream实现<a hidden class=anchor aria-hidden=true href=#使用stream实现>#</a></h2><p><code>Stream</code> 是 Dart 中用于处理一系列异步数据的对象。它可以用于处理连续的数据流，如用户输入、文件读取、网络数据等。</p><h3 id=创建-stream>创建 Stream<a hidden class=anchor aria-hidden=true href=#创建-stream>#</a></h3><p>你可以使用 <code>StreamController</code> 来创建和管理一个 <code>Stream</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;dart:async&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建一个 StreamController
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>final</span> <span class=n>controller</span> <span class=o>=</span> <span class=n>StreamController</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 获取 Stream
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>final</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>controller</span><span class=p>.</span><span class=n>stream</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 监听 Stream
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>stream</span><span class=p>.</span><span class=n>listen</span><span class=p>((</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Received data: </span><span class=si>$</span><span class=n>data</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 向 Stream 添加数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>controller</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=m>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>controller</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=m>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>controller</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=m>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 关闭 StreamController
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>controller</span><span class=p>.</span><span class=n>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=使用-stream-生成器>使用 Stream 生成器<a hidden class=anchor aria-hidden=true href=#使用-stream-生成器>#</a></h3><p>你也可以使用 <code>async*</code> 和 <code>yield</code> 关键字来创建一个 <code>Stream</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;dart:async&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>countStream</span><span class=p>(</span><span class=kt>int</span> <span class=n>to</span><span class=p>)</span> <span class=kd>async</span><span class=o>*</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=m>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>to</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>await</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>1</span><span class=p>));</span> <span class=c1>// 模拟延迟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>yield</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>countStream</span><span class=p>(</span><span class=m>5</span><span class=p>).</span><span class=n>listen</span><span class=p>((</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Received data: </span><span class=si>$</span><span class=n>data</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=stream-的实现原理>Stream 的实现原理<a hidden class=anchor aria-hidden=true href=#stream-的实现原理>#</a></h3><p><code>Stream</code> 的实现原理基于事件循环（Event Loop）和消息队列（Message Queue）。当你创建一个 <code>Stream</code> 并添加数据时，这些数据会被放入一个内部队列中。当有监听器（<code>listener</code>）监听这个 <code>Stream</code> 时，事件循环会从队列中取出数据并传递给监听器。</p><h2 id=使用isolate实现>使用Isolate实现<a hidden class=anchor aria-hidden=true href=#使用isolate实现>#</a></h2><p><code>Isolate</code> 是 Dart 的并发模型，用于在单独的线程中<strong>执行耗时任务</strong>，避免阻塞主线程。<strong>每个 <code>Isolate</code> 都有自己的内存和事件循环</strong>。</p><h3 id=创建和使用-isolate>创建和使用 Isolate<a hidden class=anchor aria-hidden=true href=#创建和使用-isolate>#</a></h3><p>你可以使用 <code>Isolate.spawn</code> 方法来创建一个新的 <code>Isolate</code>，并使用 <code>SendPort</code> 和 <code>ReceivePort</code> 来进行通信。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;dart:isolate&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>isolateFunction</span><span class=p>(</span><span class=n>SendPort</span> <span class=n>sendPort</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=m>1000000000</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>+=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>sendPort</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建一个 ReceivePort 来接收消息
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ReceivePort</span> <span class=n>receivePort</span> <span class=o>=</span> <span class=n>ReceivePort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建一个新的 Isolate
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Isolate</span><span class=p>.</span><span class=n>spawn</span><span class=p>(</span><span class=n>isolateFunction</span><span class=p>,</span> <span class=n>receivePort</span><span class=p>.</span><span class=n>sendPort</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 监听 ReceivePort
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>receivePort</span><span class=p>.</span><span class=n>listen</span><span class=p>((</span><span class=n>message</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;Result from isolate: </span><span class=si>$</span><span class=n>message</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=isolate-的实现原理>Isolate 的实现原理<a hidden class=anchor aria-hidden=true href=#isolate-的实现原理>#</a></h3><p><code>Isolate</code> 的实现原理基于 Dart 的并发模型。每个 <code>Isolate</code> 都有自己的内存空间和事件循环，它们之间通过消息传递进行通信。当你创建一个新的 <code>Isolate</code> 时，Dart 会在一个新的线程中运行这个 <code>Isolate</code>，并在主线程和子线程之间建立一个消息通道（<code>SendPort</code> 和 <code>ReceivePort</code>）。通过这个消息通道，你可以安全地在不同的 <code>Isolate</code> 之间传递数据。</p><h2 id=总结-1>总结<a hidden class=anchor aria-hidden=true href=#总结-1>#</a></h2><ul><li><strong>Future</strong>：适用于处理单个异步操作，基于事件循环和消息队列。</li><li><strong>Stream</strong>：适用于处理连续的异步数据流，基于事件循环和消息队列。</li><li><strong>Isolate</strong>：适用于处理耗时任务，基于 Dart 的并发模型和消息传递。</li></ul><h1 id=渲染机制>渲染机制<a hidden class=anchor aria-hidden=true href=#渲染机制>#</a></h1><p><a href=https://juejin.cn/post/6973818961724964901>https://juejin.cn/post/6973818961724964901</a></p><p>三棵树：widget, element, RenderObjects树</p><ul><li>Widget：Widget是Flutter的核心部分，是用户界面的不可变描述。做Flutter开发接触最多的就是Widget，可以说Widget撑起了Flutter的半边天；</li><li>Element：Element是实例化的 Widget 对象，通过 Widget 的 createElement() 方法，是在特定位置使用 Widget配置数据生成；</li><li>RenderObject：用于应用界面的布局和绘制，保存了元素的大小，布局等信息；</li></ul><p><a href=https://www.geekailab.com/2021/01/10/Flutter-three-tree/>https://www.geekailab.com/2021/01/10/Flutter-three-tree/</a></p><h1 id=组件>组件<a hidden class=anchor aria-hidden=true href=#组件>#</a></h1><h2 id=statefulwidget和statelesswidget>StatefulWidget和StatelessWidget<a hidden class=anchor aria-hidden=true href=#statefulwidget和statelesswidget>#</a></h2><p>在 Flutter 中，<strong>StatefulWidget</strong> 和 <strong>StatelessWidget</strong> 是两种基本的小部件类型，用于构建用户界面。它们的主要区别在于它们如何管理状态。</p><h4 id=无状态小部件statefulwidget><strong>无状态小部件</strong>StatefulWidget<a hidden class=anchor aria-hidden=true href=#无状态小部件statefulwidget>#</a></h4><p>无状态小部件没有内部状态。这意味着它们的输出完全由它们的输入和构建时提供的属性决定。无状态小部件在整个生命周期中保持不变，不会因用户交互或其他外部因素而重新渲染。</p><p>创建无状态小部件类的最简单方法是继承 <code>StatelessWidget</code> 类并重写 <code>build</code> 方法。<code>build</code> 方法必须返回一个 <code>Widget</code>，该小部件将呈现到屏幕上。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dart data-lang=Dart><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyStatelessWidget</span> <span class=kd>extends</span> <span class=n>StatelessWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;Hello, World!&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=有状态小部件statelesswidget><strong>有状态小部件</strong>StatelessWidget<a hidden class=anchor aria-hidden=true href=#有状态小部件statelesswidget>#</a></h4><p>有状态小部件包含内部状态，可能会随着时间的推移而改变。此状态用于控制小部件的输出。有状态小部件会在其状态发生变化时重新渲染。</p><p>要创建状态有状态小部件类，您需要继承 <code>StatefulWidget</code> 类并创建一个 <code>State</code> 类。<code>State</code> 类包含小部件的状态并提供以下方法：</p><ul><li><code>initState</code>：此方法将在小部件首次创建时调用。您可以使用它来初始化小部件的状态。</li><li><code>didChangeDependencies</code>：此方法将在小部件的依赖项更改时调用。您可以使用它来响应其他小部件的状态变化。</li><li><code>build</code>：此方法与无状态小部件的 <code>build</code> 方法相同。它用于构建小部件将呈现到屏幕上的内容。</li><li><code>setState</code>：此方法用于更新小部件的状态。这将导致小部件重新渲染。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dart data-lang=Dart><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyStatefulWidget</span> <span class=kd>extends</span> <span class=n>StatefulWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>_MyStatefulWidgetState</span> <span class=n>createState</span><span class=p>()</span> <span class=o>=&gt;</span> <span class=n>_MyStatefulWidgetState</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>_MyStatefulWidgetState</span> <span class=kd>extends</span> <span class=n>State</span><span class=o>&lt;</span><span class=n>MyStatefulWidget</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>_counter</span> <span class=o>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>initState</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>initState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;Counter: </span><span class=si>$</span><span class=n>_counter</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>incrementCounter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>setState</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=创建继承它们的类的方法有什么不同><strong>创建继承它们的类的方法有什么不同？</strong><a hidden class=anchor aria-hidden=true href=#创建继承它们的类的方法有什么不同>#</a></h3><p>创建继承 <code>StatelessWidget</code> 和 <code>StatefulWidget</code> 的类的方法的主要区别在于：</p><ul><li><strong>无状态小部件</strong> 只需要重写 <code>build</code> 方法。</li><li><strong>有状态小部件</strong> 需要创建一个 <code>State</code> 类并重写 <code>initState</code>、<code>didChangeDependencies</code>、<code>build</code> 和 <code>setState</code> 方法。</li></ul><p>此外，有状态小部件通常需要使用 <code>setState</code> 方法来更新其状态。这会导致小部件重新渲染，并反映状态的变化。</p><h3 id=何时使用无状态小部件><strong>何时使用无状态小部件？</strong><a hidden class=anchor aria-hidden=true href=#何时使用无状态小部件>#</a></h3><ul><li>小部件没有内部状态。</li><li>小部件的输出完全由其输入和属性决定。</li><li>小部件不需要响应用户交互或其他外部因素。</li></ul><p><strong>示例</strong></p><p>以下是一个无状态小部件的示例，它显示一个文本小部件，其中包含“Hello, World!”：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dart data-lang=Dart><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyStatelessWidget</span> <span class=kd>extends</span> <span class=n>StatelessWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;Hello, World!&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以下是一个有状态小部件的示例，它显示一个计数器小部件，用户可以点击它来增加计数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dart data-lang=Dart><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyStatefulWidget</span> <span class=kd>extends</span> <span class=n>StatefulWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>_MyStatefulWidgetState</span> <span class=n>createState</span><span class=p>()</span> <span class=o>=&gt;</span> <span class=n>_MyStatefulWidgetState</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>_MyStatefulWidgetState</span> <span class=kd>extends</span> <span class=n>State</span><span class=o>&lt;</span><span class=n>MyStatefulWidget</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>_counter</span> <span class=o>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;Counter: </span><span class=si>$</span><span class=n>_counter</span><span class=s1>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>incrementCounter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>setState</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>_counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=appbar设计>AppBar设计<a hidden class=anchor aria-hidden=true href=#appbar设计>#</a></h2><p>关于appbar的参数：https://juejin.cn/post/7143181602124726308</p><p>想要做成小红书这种，左边目录，中间“关注/推荐”，右边搜索，就直接在appbar的title参数里面加入“关注/推荐”</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>AppBar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nl>elevation:</span> <span class=m>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nl>backgroundColor:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>white</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nl>leading:</span> <span class=n>IconButton</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nl>icon:</span> <span class=kd>const</span> <span class=n>Icon</span><span class=p>(</span><span class=n>Icons</span><span class=p>.</span><span class=n>menu</span><span class=p>,</span> <span class=nl>color:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>blue</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nl>onPressed:</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=c1>// Scaffold.of(context).openDrawer();
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nl>title:</span> <span class=n>Row</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nl>children:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>          <span class=kd>const</span> <span class=n>SizedBox</span><span class=p>(</span><span class=nl>width:</span> <span class=m>25</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>Expanded</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=nl>child:</span> <span class=n>TabBar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=nl>controller:</span> <span class=n>_tabController</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nl>tabs:</span> <span class=n>widget</span><span class=p>.</span><span class=n>tabs</span><span class=p>.</span><span class=n>map</span><span class=p>((</span><span class=n>tab</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=n>Tab</span><span class=p>(</span><span class=nl>text:</span> <span class=n>tab</span><span class=p>)).</span><span class=n>toList</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>              <span class=nl>labelColor:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>blue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nl>unselectedLabelColor:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>grey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nl>indicatorSize:</span> <span class=n>TabBarIndicatorSize</span><span class=p>.</span><span class=n>label</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nl>indicatorWeight:</span> <span class=m>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=kd>const</span> <span class=n>SizedBox</span><span class=p>(</span><span class=nl>width:</span> <span class=m>25</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=p>],</span>
</span></span><span class=line><span class=cl>      <span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nl>actions:</span> <span class=n>widget</span><span class=p>.</span><span class=n>showSearch</span>
</span></span><span class=line><span class=cl>          <span class=o>?</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>              <span class=n>IconButton</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nl>icon:</span> <span class=kd>const</span> <span class=n>Icon</span><span class=p>(</span><span class=n>Icons</span><span class=p>.</span><span class=n>search</span><span class=p>,</span> <span class=nl>color:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>blue</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                <span class=nl>onPressed:</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                  <span class=c1>// 跳转到搜索页面
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>},</span>
</span></span><span class=line><span class=cl>              <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>]</span>
</span></span><span class=line><span class=cl>          <span class=o>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><h2 id=expanded占据剩余空间>Expanded：占据剩余空间<a hidden class=anchor aria-hidden=true href=#expanded占据剩余空间>#</a></h2><p>这里有一篇文章有两个对比用不用expanded：https://stackoverflow.com/questions/68539642/how-expanded-widget-works-in-flutter</p><p>个人感受就是组件expaned的高度是根据父组件的高度自适应分配，弹性布局的意思。</p><h2 id=layoutbuilder获取一个组件的宽度>LayoutBuilder：获取一个组件的宽度<a hidden class=anchor aria-hidden=true href=#layoutbuilder获取一个组件的宽度>#</a></h2><p>要获取最外层容器的宽度，你需要确保容器在布局过程中已经完成测量。在 Flutter 中，你可以使用 <code>LayoutBuilder</code> 小部件来获取布局约束，其中包含了容器的最大宽度。</p><p>下面是一个示例，展示了如何使用 <code>LayoutBuilder</code> 来获取 <code>Container</code> 的宽度：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Container</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nl>child:</span> <span class=n>LayoutBuilder</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nl>builder:</span> <span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>,</span> <span class=n>BoxConstraints</span> <span class=n>constraints</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 获取Container的最大宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kt>double</span> <span class=n>containerWidth</span> <span class=o>=</span> <span class=n>constraints</span><span class=p>.</span><span class=n>maxWidth</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// 使用containerWidth进行后续操作
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>ElevatedButton</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... 其他按钮属性
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nl>child:</span> <span class=n>Stack</span><span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=nl>children:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_selectedOption</span> <span class=o>!=</span> <span class=o>-</span><span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=n>Positioned</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nl>left:</span> <span class=m>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nl>top:</span> <span class=m>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nl>child:</span> <span class=n>Container</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                  <span class=nl>height:</span> <span class=m>20</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=nl>width:</span> <span class=n>containerWidth</span> <span class=o>*</span> <span class=n>votePercentage</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=c1>// 使用containerWidth来设置宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>                  <span class=nl>decoration:</span> <span class=n>BoxDecoration</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=nl>color:</span> <span class=n>_selectedOption</span> <span class=o>==</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                        <span class=o>?</span> <span class=n>colorPercents</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=m>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                        <span class=o>:</span> <span class=n>colorPercents</span><span class=p>[</span><span class=m>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                    <span class=nl>borderRadius:</span> <span class=n>BorderRadius</span><span class=p>.</span><span class=n>circular</span><span class=p>(</span><span class=m>10</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                  <span class=p>),</span>
</span></span><span class=line><span class=cl>                <span class=p>),</span>
</span></span><span class=line><span class=cl>              <span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>Align</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=nl>alignment:</span> <span class=n>Alignment</span><span class=p>.</span><span class=n>center</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nl>child:</span> <span class=n>Text</span><span class=p>(</span><span class=n>text</span><span class=p>[</span><span class=n>i</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>在这个例子中，<code>LayoutBuilder</code> 会为其子级提供一个回调函数，该函数会在布局过程完成后被调用。<code>BoxConstraints</code> 参数包含了子级在布局过程中的约束信息，其中 <code>maxWidth</code> 属性就是容器的最大宽度。</p><p>请注意，<code>LayoutBuilder</code> 本身并不直接参与布局，它只是提供了一个回调函数来获取布局约束。如果你需要在布局过程中动态设置容器的宽度，你可能需要使用 <code>LayoutBuilder</code> 来获取约束，然后根据这些约束来设置容器的宽度。</p><p>确保 <code>LayoutBuilder</code> 小部件是 <code>Container</code> 的直接子级，这样它才能正确地获取到 <code>Container</code> 的布局约束。如果 <code>Container</code> 是其他小部件的子级，你可能需要调整你的小部件树结构以确保 <code>LayoutBuilder</code> 可以正确地获取到 <code>Container</code> 的宽度。</p><h2 id=在外层调用opendrawer>在外层调用openDrawer()<a hidden class=anchor aria-hidden=true href=#在外层调用opendrawer>#</a></h2><p>在Flutter中，<code>Scaffold.of(context).openDrawer()</code> 方法是如何工作的呢？当你调用 <code>Scaffold.of(context).openDrawer()</code> 时，Flutter实际上是在当前的 <code>BuildContext</code> 中查找最近的 <code>Scaffold</code> 组件，并调用它的 <code>openDrawer()</code> 方法。</p><p><code>BuildContext</code> 是一个非常重要的概念，它代表了在widget树中的位置和层次结构。当你调用 <code>Scaffold.of(context)</code> 时，Flutter会从当前的widget开始向上遍历widget树，直到找到最近的 <code>Scaffold</code> 组件。</p><p>在你的代码中，当你点击 <code>AppBar</code> 中的菜单按钮时，<code>onPressed</code> 回调函数是在 <code>DynamicTopBar</code> 内部定义的。但是，<code>Scaffold.of(context).openDrawer()</code> 方法是在 <code>AppBar</code> 内部调用的，它是在 <code>DynamicTopBar</code> 内部定义的 <code>AppBar</code> 小部件中调用的。</p><p><code>Scaffold.of(context)</code> 方法会沿着widget树向上查找最近的 <code>Scaffold</code> 组件，并返回它。在这个例子中，由于 <code>AppBar</code> 是 <code>Scaffold</code> 的子部件，<code>Scaffold.of(context)</code> 会找到 <code>Scaffold</code> 并调用它的 <code>openDrawer()</code> 方法。</p><p>所以，<code>Scaffold.of(context).openDrawer()</code> 是如何工作的，是因为它在widget树中向上查找最近的 <code>Scaffold</code> 组件，并调用它的 <code>openDrawer()</code> 方法。</p><h2 id=tabcontroller顶部栏内容滑动更新>TabController：顶部栏内容滑动更新<a hidden class=anchor aria-hidden=true href=#tabcontroller顶部栏内容滑动更新>#</a></h2><p>通过tabController实现，可以传递这个参数进一个子组件实现控制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;package:flutter/material.dart&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>DynamicTopBar</span> <span class=kd>extends</span> <span class=n>StatelessWidget</span> <span class=kd>implements</span> <span class=n>PreferredSizeWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span> <span class=n>tabs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=kt>bool</span> <span class=n>showSearch</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>TabController</span> <span class=n>tabController</span><span class=p>;</span> <span class=c1>// 接受外部提供的TabController
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kd>const</span> <span class=n>DynamicTopBar</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span><span class=o>?</span> <span class=n>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kd>required</span> <span class=k>this</span><span class=p>.</span><span class=n>tabs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=n>showSearch</span> <span class=o>=</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kd>required</span> <span class=k>this</span><span class=p>.</span><span class=n>tabController</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=o>:</span> <span class=k>super</span><span class=p>(</span><span class=nl>key:</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Size</span> <span class=kd>get</span> <span class=n>preferredSize</span> <span class=o>=&gt;</span> <span class=kd>const</span> <span class=n>Size</span><span class=p>.</span><span class=n>fromHeight</span><span class=p>(</span><span class=n>kToolbarHeight</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>AppBar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nl>elevation:</span> <span class=m>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nl>backgroundColor:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>white</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nl>leading:</span> <span class=n>IconButton</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nl>icon:</span> <span class=n>Icon</span><span class=p>(</span><span class=n>Icons</span><span class=p>.</span><span class=n>menu</span><span class=p>,</span> <span class=nl>color:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>blue</span><span class=p>[</span><span class=m>700</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=nl>onPressed:</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>Scaffold</span><span class=p>.</span><span class=n>of</span><span class=p>(</span><span class=n>context</span><span class=p>).</span><span class=n>openDrawer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nl>title:</span> <span class=n>Row</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nl>children:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>          <span class=kd>const</span> <span class=n>SizedBox</span><span class=p>(</span><span class=nl>width:</span> <span class=m>25</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>Expanded</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=nl>child:</span> <span class=n>TabBar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=nl>controller:</span> <span class=n>tabController</span><span class=p>,</span> <span class=c1>// 使用传入的TabController
</span></span></span><span class=line><span class=cl><span class=c1></span>              <span class=nl>tabs:</span> <span class=n>tabs</span><span class=p>.</span><span class=n>map</span><span class=p>((</span><span class=n>tab</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=n>Tab</span><span class=p>(</span><span class=nl>text:</span> <span class=n>tab</span><span class=p>)).</span><span class=n>toList</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>              <span class=nl>labelColor:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>blue</span><span class=p>[</span><span class=m>700</span><span class=p>],</span>
</span></span><span class=line><span class=cl>              <span class=nl>labelStyle:</span> <span class=kd>const</span> <span class=n>TextStyle</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nl>fontSize:</span> <span class=m>20</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nl>fontFamily:</span> <span class=s1>&#39;SimHei&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nl>fontWeight:</span> <span class=n>FontWeight</span><span class=p>.</span><span class=n>bold</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=p>),</span>
</span></span><span class=line><span class=cl>              <span class=nl>unselectedLabelColor:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>grey</span><span class=p>[</span><span class=m>400</span><span class=p>],</span>
</span></span><span class=line><span class=cl>              <span class=nl>indicatorSize:</span> <span class=n>TabBarIndicatorSize</span><span class=p>.</span><span class=n>label</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nl>indicatorWeight:</span> <span class=m>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nl>indicatorColor:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>blue</span><span class=p>[</span><span class=m>700</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=kd>const</span> <span class=n>SizedBox</span><span class=p>(</span><span class=nl>width:</span> <span class=m>25</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=p>],</span>
</span></span><span class=line><span class=cl>      <span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nl>actions:</span> <span class=n>showSearch</span>
</span></span><span class=line><span class=cl>          <span class=o>?</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>              <span class=n>IconButton</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nl>icon:</span> <span class=n>Icon</span><span class=p>(</span><span class=n>Icons</span><span class=p>.</span><span class=n>search</span><span class=p>,</span> <span class=nl>color:</span> <span class=n>Colors</span><span class=p>.</span><span class=n>blue</span><span class=p>[</span><span class=m>700</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>                <span class=nl>onPressed:</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                  <span class=c1>// 跳转到搜索页面
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>},</span>
</span></span><span class=line><span class=cl>              <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>]</span>
</span></span><span class=line><span class=cl>          <span class=o>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=页面逻辑>页面逻辑<a hidden class=anchor aria-hidden=true href=#页面逻辑>#</a></h1><h2 id=前端如何判断用户是否登录>前端如何判断用户是否登录<a hidden class=anchor aria-hidden=true href=#前端如何判断用户是否登录>#</a></h2><p>在Flutter中，常见的存储和管理JWT的方法包括使用<code>shared_preferences</code>插件来在本地存储和检索JWT，并在需要时进行验证。以下是详细的步骤和示例代码：</p><h3 id=1-添加依赖>1. 添加依赖<a hidden class=anchor aria-hidden=true href=#1-添加依赖>#</a></h3><p>首先，需要在<code>pubspec.yaml</code>文件中添加<code>shared_preferences</code>依赖：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>dependencies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>flutter</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>sdk</span><span class=p>:</span><span class=w> </span><span class=l>flutter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>shared_preferences</span><span class=p>:</span><span class=w> </span><span class=l>^2.0.9</span><span class=w>
</span></span></span></code></pre></div><h3 id=2-存储jwt>2. 存储JWT<a hidden class=anchor aria-hidden=true href=#2-存储jwt>#</a></h3><p>当用户登录成功后，可以将后端返回的JWT存储在本地存储中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;package:shared_preferences/shared_preferences.dart&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>saveToken</span><span class=p>(</span><span class=kt>String</span> <span class=n>token</span><span class=p>)</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>prefs</span> <span class=o>=</span> <span class=kd>await</span> <span class=n>SharedPreferences</span><span class=p>.</span><span class=n>getInstance</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kd>await</span> <span class=n>prefs</span><span class=p>.</span><span class=n>setString</span><span class=p>(</span><span class=s1>&#39;authToken&#39;</span><span class=p>,</span> <span class=n>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=3-检查用户是否登录>3. 检查用户是否登录<a hidden class=anchor aria-hidden=true href=#3-检查用户是否登录>#</a></h3><p>在“我的”界面中，可以通过检查本地存储中的JWT来判断用户是否已经登录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;package:flutter/material.dart&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=s1>&#39;package:shared_preferences/shared_preferences.dart&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyPage</span> <span class=kd>extends</span> <span class=n>StatefulWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>_MyPageState</span> <span class=n>createState</span><span class=p>()</span> <span class=o>=&gt;</span> <span class=n>_MyPageState</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>_MyPageState</span> <span class=kd>extends</span> <span class=n>State</span><span class=o>&lt;</span><span class=n>MyPage</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>isLoggedIn</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>initState</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>initState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>checkLoginStatus</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Future</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>checkLoginStatus</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=n>prefs</span> <span class=o>=</span> <span class=kd>await</span> <span class=n>SharedPreferences</span><span class=p>.</span><span class=n>getInstance</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=n>token</span> <span class=o>=</span> <span class=n>prefs</span><span class=p>.</span><span class=n>getString</span><span class=p>(</span><span class=s1>&#39;authToken&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>token</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 这里可以进一步验证token的有效性
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>setState</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>isLoggedIn</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>setState</span><span class=p>(()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>isLoggedIn</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Scaffold</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nl>appBar:</span> <span class=n>AppBar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nl>title:</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;我的页面&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nl>body:</span> <span class=n>Center</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nl>child:</span> <span class=n>isLoggedIn</span> <span class=o>?</span> <span class=n>LoggedInWidget</span><span class=p>()</span> <span class=o>:</span> <span class=n>LoggedOutWidget</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>      <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>LoggedInWidget</span> <span class=kd>extends</span> <span class=n>StatelessWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;欢迎回来，用户已登录&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>LoggedOutWidget</span> <span class=kd>extends</span> <span class=n>StatelessWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;请登录&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=4-清除jwt用户登出>4. 清除JWT（用户登出）<a hidden class=anchor aria-hidden=true href=#4-清除jwt用户登出>#</a></h3><p>当用户登出时，可以清除本地存储中的JWT：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>logout</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>prefs</span> <span class=o>=</span> <span class=kd>await</span> <span class=n>SharedPreferences</span><span class=p>.</span><span class=n>getInstance</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kd>await</span> <span class=n>prefs</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=s1>&#39;authToken&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过以上步骤，您可以在Flutter应用中存储JWT并在需要时检查用户的登录状态。这样，无论是安卓还是iOS，您都可以确保用户的登录状态得到正确的管理和验证。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/flutter/>Flutter</a></li><li><a href=https://sirius1y.top/tags/dev/>Dev</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/database/use-mongodb/><span class=title>« Prev</span><br><span>MongoDB快速上手</span>
</a><a class=next href=https://sirius1y.top/posts/notes/go-srccode/go-channel/><span class=title>Next »</span><br><span>【go的源码阅读】channel的实现：chan.go</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>