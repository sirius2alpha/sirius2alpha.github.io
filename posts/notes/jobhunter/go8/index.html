<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>golang八股文 | Sirius' Blog</title>
<meta name=keywords content="面经,go"><meta name=description content="Golang goroutine内存泄漏 slice导致
获取长字符串中的一段，导致字符串未释放；
获取长slice中的一段导致长slice未释放；
在长切片中新建sllice导致泄漏
channel导致
发送不接受，接收不发送，nil channel
从 channel 里读，但是同时没有写入操作 向 无缓冲 channel 里写，但是同时没有读操作 向已满的 有缓冲 channel 里写，但是同时没有读操作 select操作在所有case上都阻塞() goroutine进入死循环，一直结束不了 向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。 可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。
传统同步方式sync.mutex，sync.waitgroup导致
用了mutex加lock之后忘记unlock；
在一开始设置了具体数目的wg.wait(n)，但是有没有写够足够数量n的wg.Done()，导致wg.Wait()一直等待下去。（正确方式可以使用wg.Add(1)配合wg.Done使用）
Go调度器的GMP 在Go语言中，GPM通常指的是Goroutine、Processor和Machine，这是Go调度器（scheduler）的核心组成部分。下面是对每个部分的详细介绍：
Goroutine (G):
Goroutine是Go语言中的轻量级线程，由Go运行时管理。它们是并发的基本单位，可以被创建和销毁，而无需操作系统级别的线程开销。Goroutine的创建和销毁非常快速，因此可以轻松地创建成千上万个Goroutine。 Goroutine的调度是协作式的，这意味着一个Goroutine在执行时会自愿放弃CPU，让其他Goroutine有机会执行。这种协作式调度使得Go语言能够高效地利用多核处理器。 Processor (P):
Processor是Go调度器中的一个抽象概念，代表一个逻辑处理器。每个P都有一个本地运行队列，用于存储待执行的Goroutine。P的数量可以通过环境变量或运行时设置来调整，通常设置为CPU的核心数。 P的主要作用是管理Goroutine的执行。当一个Goroutine被调度到P上时，P会将其分配给一个可用的Machine（M）来执行。 Machine (M):
Machine代表一个操作系统线程。M与P关联，负责执行Goroutine。一个M可以与多个P关联，但在任何给定时间，一个M只能执行一个P的Goroutine。 M的主要作用是执行Goroutine的代码。当一个Goroutine被调度到M上时，M会执行该Goroutine的代码，直到该Goroutine自愿放弃CPU或被抢占。 Go调度器的工作原理是将Goroutine（G）分配到Processor（P）上，然后由Machine（M）执行。这种设计使得Go语言能够高效地利用多核处理器，并实现高并发。
在 Go 语言的运行时系统中，Goroutine（简称 G）有多种状态，用于描述它在不同时间点的执行情况。这些状态在 Go 的调度器（GMP 模型）中扮演重要角色。GMP 模型由 Goroutine（G）、工作线程（M）和处理器（P）三部分组成。以下是 G 的主要状态及其转变过程，以及它们与 GMP 模型的关系。
G 的状态 _Gidle：空闲状态。Goroutine 尚未被使用或已经完成执行，等待被分配新任务。 _Grunnable：可运行状态。Goroutine 已经准备好运行，等待被调度器选中运行。 _Grunning：运行状态。Goroutine 正在运行中。 _Gsyscall：系统调用状态。Goroutine 正在执行系统调用，处于阻塞状态，不会被调度器调度。 _Gwaiting：等待状态。Goroutine 在等待某个条件（例如通道操作、定时器、网络 I/O 等）完成。 _Gdead：死亡状态。Goroutine 已经完成执行，无法再被重新使用。 _Gcopystack：堆栈复制状态。Goroutine 的堆栈正在被复制，以调整其大小。 状态转变及其与 GMP 的关系 创建 Goroutine _Gidle -> _Grunnable 创建一个新的 Goroutine，并将其状态设置为 _Grunnable，表示该 Goroutine 准备好运行。 由 P 将新的 Goroutine 添加到其本地运行队列或全局运行队列中。 g := newGoroutine() g."><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/jobhunter/go8/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/jobhunter/go8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="golang八股文"><meta property="og:description" content="Golang goroutine内存泄漏 slice导致
获取长字符串中的一段，导致字符串未释放；
获取长slice中的一段导致长slice未释放；
在长切片中新建sllice导致泄漏
channel导致
发送不接受，接收不发送，nil channel
从 channel 里读，但是同时没有写入操作 向 无缓冲 channel 里写，但是同时没有读操作 向已满的 有缓冲 channel 里写，但是同时没有读操作 select操作在所有case上都阻塞() goroutine进入死循环，一直结束不了 向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。 可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。
传统同步方式sync.mutex，sync.waitgroup导致
用了mutex加lock之后忘记unlock；
在一开始设置了具体数目的wg.wait(n)，但是有没有写够足够数量n的wg.Done()，导致wg.Wait()一直等待下去。（正确方式可以使用wg.Add(1)配合wg.Done使用）
Go调度器的GMP 在Go语言中，GPM通常指的是Goroutine、Processor和Machine，这是Go调度器（scheduler）的核心组成部分。下面是对每个部分的详细介绍：
Goroutine (G):
Goroutine是Go语言中的轻量级线程，由Go运行时管理。它们是并发的基本单位，可以被创建和销毁，而无需操作系统级别的线程开销。Goroutine的创建和销毁非常快速，因此可以轻松地创建成千上万个Goroutine。 Goroutine的调度是协作式的，这意味着一个Goroutine在执行时会自愿放弃CPU，让其他Goroutine有机会执行。这种协作式调度使得Go语言能够高效地利用多核处理器。 Processor (P):
Processor是Go调度器中的一个抽象概念，代表一个逻辑处理器。每个P都有一个本地运行队列，用于存储待执行的Goroutine。P的数量可以通过环境变量或运行时设置来调整，通常设置为CPU的核心数。 P的主要作用是管理Goroutine的执行。当一个Goroutine被调度到P上时，P会将其分配给一个可用的Machine（M）来执行。 Machine (M):
Machine代表一个操作系统线程。M与P关联，负责执行Goroutine。一个M可以与多个P关联，但在任何给定时间，一个M只能执行一个P的Goroutine。 M的主要作用是执行Goroutine的代码。当一个Goroutine被调度到M上时，M会执行该Goroutine的代码，直到该Goroutine自愿放弃CPU或被抢占。 Go调度器的工作原理是将Goroutine（G）分配到Processor（P）上，然后由Machine（M）执行。这种设计使得Go语言能够高效地利用多核处理器，并实现高并发。
在 Go 语言的运行时系统中，Goroutine（简称 G）有多种状态，用于描述它在不同时间点的执行情况。这些状态在 Go 的调度器（GMP 模型）中扮演重要角色。GMP 模型由 Goroutine（G）、工作线程（M）和处理器（P）三部分组成。以下是 G 的主要状态及其转变过程，以及它们与 GMP 模型的关系。
G 的状态 _Gidle：空闲状态。Goroutine 尚未被使用或已经完成执行，等待被分配新任务。 _Grunnable：可运行状态。Goroutine 已经准备好运行，等待被调度器选中运行。 _Grunning：运行状态。Goroutine 正在运行中。 _Gsyscall：系统调用状态。Goroutine 正在执行系统调用，处于阻塞状态，不会被调度器调度。 _Gwaiting：等待状态。Goroutine 在等待某个条件（例如通道操作、定时器、网络 I/O 等）完成。 _Gdead：死亡状态。Goroutine 已经完成执行，无法再被重新使用。 _Gcopystack：堆栈复制状态。Goroutine 的堆栈正在被复制，以调整其大小。 状态转变及其与 GMP 的关系 创建 Goroutine _Gidle -> _Grunnable 创建一个新的 Goroutine，并将其状态设置为 _Grunnable，表示该 Goroutine 准备好运行。 由 P 将新的 Goroutine 添加到其本地运行队列或全局运行队列中。 g := newGoroutine() g."><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/jobhunter/go8/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-12T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-12T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="golang八股文"><meta name=twitter:description content="Golang goroutine内存泄漏 slice导致
获取长字符串中的一段，导致字符串未释放；
获取长slice中的一段导致长slice未释放；
在长切片中新建sllice导致泄漏
channel导致
发送不接受，接收不发送，nil channel
从 channel 里读，但是同时没有写入操作 向 无缓冲 channel 里写，但是同时没有读操作 向已满的 有缓冲 channel 里写，但是同时没有读操作 select操作在所有case上都阻塞() goroutine进入死循环，一直结束不了 向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。 可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。
传统同步方式sync.mutex，sync.waitgroup导致
用了mutex加lock之后忘记unlock；
在一开始设置了具体数目的wg.wait(n)，但是有没有写够足够数量n的wg.Done()，导致wg.Wait()一直等待下去。（正确方式可以使用wg.Add(1)配合wg.Done使用）
Go调度器的GMP 在Go语言中，GPM通常指的是Goroutine、Processor和Machine，这是Go调度器（scheduler）的核心组成部分。下面是对每个部分的详细介绍：
Goroutine (G):
Goroutine是Go语言中的轻量级线程，由Go运行时管理。它们是并发的基本单位，可以被创建和销毁，而无需操作系统级别的线程开销。Goroutine的创建和销毁非常快速，因此可以轻松地创建成千上万个Goroutine。 Goroutine的调度是协作式的，这意味着一个Goroutine在执行时会自愿放弃CPU，让其他Goroutine有机会执行。这种协作式调度使得Go语言能够高效地利用多核处理器。 Processor (P):
Processor是Go调度器中的一个抽象概念，代表一个逻辑处理器。每个P都有一个本地运行队列，用于存储待执行的Goroutine。P的数量可以通过环境变量或运行时设置来调整，通常设置为CPU的核心数。 P的主要作用是管理Goroutine的执行。当一个Goroutine被调度到P上时，P会将其分配给一个可用的Machine（M）来执行。 Machine (M):
Machine代表一个操作系统线程。M与P关联，负责执行Goroutine。一个M可以与多个P关联，但在任何给定时间，一个M只能执行一个P的Goroutine。 M的主要作用是执行Goroutine的代码。当一个Goroutine被调度到M上时，M会执行该Goroutine的代码，直到该Goroutine自愿放弃CPU或被抢占。 Go调度器的工作原理是将Goroutine（G）分配到Processor（P）上，然后由Machine（M）执行。这种设计使得Go语言能够高效地利用多核处理器，并实现高并发。
在 Go 语言的运行时系统中，Goroutine（简称 G）有多种状态，用于描述它在不同时间点的执行情况。这些状态在 Go 的调度器（GMP 模型）中扮演重要角色。GMP 模型由 Goroutine（G）、工作线程（M）和处理器（P）三部分组成。以下是 G 的主要状态及其转变过程，以及它们与 GMP 模型的关系。
G 的状态 _Gidle：空闲状态。Goroutine 尚未被使用或已经完成执行，等待被分配新任务。 _Grunnable：可运行状态。Goroutine 已经准备好运行，等待被调度器选中运行。 _Grunning：运行状态。Goroutine 正在运行中。 _Gsyscall：系统调用状态。Goroutine 正在执行系统调用，处于阻塞状态，不会被调度器调度。 _Gwaiting：等待状态。Goroutine 在等待某个条件（例如通道操作、定时器、网络 I/O 等）完成。 _Gdead：死亡状态。Goroutine 已经完成执行，无法再被重新使用。 _Gcopystack：堆栈复制状态。Goroutine 的堆栈正在被复制，以调整其大小。 状态转变及其与 GMP 的关系 创建 Goroutine _Gidle -> _Grunnable 创建一个新的 Goroutine，并将其状态设置为 _Grunnable，表示该 Goroutine 准备好运行。 由 P 将新的 Goroutine 添加到其本地运行队列或全局运行队列中。 g := newGoroutine() g."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"golang八股文","item":"https://sirius1y.top/posts/notes/jobhunter/go8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang八股文","name":"golang八股文","description":"Golang goroutine内存泄漏 slice导致\n获取长字符串中的一段，导致字符串未释放；\n获取长slice中的一段导致长slice未释放；\n在长切片中新建sllice导致泄漏\nchannel导致\n发送不接受，接收不发送，nil channel\n从 channel 里读，但是同时没有写入操作 向 无缓冲 channel 里写，但是同时没有读操作 向已满的 有缓冲 channel 里写，但是同时没有读操作 select操作在所有case上都阻塞() goroutine进入死循环，一直结束不了 向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。 可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。\n传统同步方式sync.mutex，sync.waitgroup导致\n用了mutex加lock之后忘记unlock；\n在一开始设置了具体数目的wg.wait(n)，但是有没有写够足够数量n的wg.Done()，导致wg.Wait()一直等待下去。（正确方式可以使用wg.Add(1)配合wg.Done使用）\nGo调度器的GMP 在Go语言中，GPM通常指的是Goroutine、Processor和Machine，这是Go调度器（scheduler）的核心组成部分。下面是对每个部分的详细介绍：\nGoroutine (G):\nGoroutine是Go语言中的轻量级线程，由Go运行时管理。它们是并发的基本单位，可以被创建和销毁，而无需操作系统级别的线程开销。Goroutine的创建和销毁非常快速，因此可以轻松地创建成千上万个Goroutine。 Goroutine的调度是协作式的，这意味着一个Goroutine在执行时会自愿放弃CPU，让其他Goroutine有机会执行。这种协作式调度使得Go语言能够高效地利用多核处理器。 Processor (P):\nProcessor是Go调度器中的一个抽象概念，代表一个逻辑处理器。每个P都有一个本地运行队列，用于存储待执行的Goroutine。P的数量可以通过环境变量或运行时设置来调整，通常设置为CPU的核心数。 P的主要作用是管理Goroutine的执行。当一个Goroutine被调度到P上时，P会将其分配给一个可用的Machine（M）来执行。 Machine (M):\nMachine代表一个操作系统线程。M与P关联，负责执行Goroutine。一个M可以与多个P关联，但在任何给定时间，一个M只能执行一个P的Goroutine。 M的主要作用是执行Goroutine的代码。当一个Goroutine被调度到M上时，M会执行该Goroutine的代码，直到该Goroutine自愿放弃CPU或被抢占。 Go调度器的工作原理是将Goroutine（G）分配到Processor（P）上，然后由Machine（M）执行。这种设计使得Go语言能够高效地利用多核处理器，并实现高并发。\n在 Go 语言的运行时系统中，Goroutine（简称 G）有多种状态，用于描述它在不同时间点的执行情况。这些状态在 Go 的调度器（GMP 模型）中扮演重要角色。GMP 模型由 Goroutine（G）、工作线程（M）和处理器（P）三部分组成。以下是 G 的主要状态及其转变过程，以及它们与 GMP 模型的关系。\nG 的状态 _Gidle：空闲状态。Goroutine 尚未被使用或已经完成执行，等待被分配新任务。 _Grunnable：可运行状态。Goroutine 已经准备好运行，等待被调度器选中运行。 _Grunning：运行状态。Goroutine 正在运行中。 _Gsyscall：系统调用状态。Goroutine 正在执行系统调用，处于阻塞状态，不会被调度器调度。 _Gwaiting：等待状态。Goroutine 在等待某个条件（例如通道操作、定时器、网络 I/O 等）完成。 _Gdead：死亡状态。Goroutine 已经完成执行，无法再被重新使用。 _Gcopystack：堆栈复制状态。Goroutine 的堆栈正在被复制，以调整其大小。 状态转变及其与 GMP 的关系 创建 Goroutine _Gidle -\u0026gt; _Grunnable 创建一个新的 Goroutine，并将其状态设置为 _Grunnable，表示该 Goroutine 准备好运行。 由 P 将新的 Goroutine 添加到其本地运行队列或全局运行队列中。 g := newGoroutine() g.","keywords":["面经","go"],"articleBody":"Golang goroutine内存泄漏 slice导致\n获取长字符串中的一段，导致字符串未释放；\n获取长slice中的一段导致长slice未释放；\n在长切片中新建sllice导致泄漏\nchannel导致\n发送不接受，接收不发送，nil channel\n从 channel 里读，但是同时没有写入操作 向 无缓冲 channel 里写，但是同时没有读操作 向已满的 有缓冲 channel 里写，但是同时没有读操作 select操作在所有case上都阻塞() goroutine进入死循环，一直结束不了 向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。 可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。\n传统同步方式sync.mutex，sync.waitgroup导致\n用了mutex加lock之后忘记unlock；\n在一开始设置了具体数目的wg.wait(n)，但是有没有写够足够数量n的wg.Done()，导致wg.Wait()一直等待下去。（正确方式可以使用wg.Add(1)配合wg.Done使用）\nGo调度器的GMP 在Go语言中，GPM通常指的是Goroutine、Processor和Machine，这是Go调度器（scheduler）的核心组成部分。下面是对每个部分的详细介绍：\nGoroutine (G):\nGoroutine是Go语言中的轻量级线程，由Go运行时管理。它们是并发的基本单位，可以被创建和销毁，而无需操作系统级别的线程开销。Goroutine的创建和销毁非常快速，因此可以轻松地创建成千上万个Goroutine。 Goroutine的调度是协作式的，这意味着一个Goroutine在执行时会自愿放弃CPU，让其他Goroutine有机会执行。这种协作式调度使得Go语言能够高效地利用多核处理器。 Processor (P):\nProcessor是Go调度器中的一个抽象概念，代表一个逻辑处理器。每个P都有一个本地运行队列，用于存储待执行的Goroutine。P的数量可以通过环境变量或运行时设置来调整，通常设置为CPU的核心数。 P的主要作用是管理Goroutine的执行。当一个Goroutine被调度到P上时，P会将其分配给一个可用的Machine（M）来执行。 Machine (M):\nMachine代表一个操作系统线程。M与P关联，负责执行Goroutine。一个M可以与多个P关联，但在任何给定时间，一个M只能执行一个P的Goroutine。 M的主要作用是执行Goroutine的代码。当一个Goroutine被调度到M上时，M会执行该Goroutine的代码，直到该Goroutine自愿放弃CPU或被抢占。 Go调度器的工作原理是将Goroutine（G）分配到Processor（P）上，然后由Machine（M）执行。这种设计使得Go语言能够高效地利用多核处理器，并实现高并发。\n在 Go 语言的运行时系统中，Goroutine（简称 G）有多种状态，用于描述它在不同时间点的执行情况。这些状态在 Go 的调度器（GMP 模型）中扮演重要角色。GMP 模型由 Goroutine（G）、工作线程（M）和处理器（P）三部分组成。以下是 G 的主要状态及其转变过程，以及它们与 GMP 模型的关系。\nG 的状态 _Gidle：空闲状态。Goroutine 尚未被使用或已经完成执行，等待被分配新任务。 _Grunnable：可运行状态。Goroutine 已经准备好运行，等待被调度器选中运行。 _Grunning：运行状态。Goroutine 正在运行中。 _Gsyscall：系统调用状态。Goroutine 正在执行系统调用，处于阻塞状态，不会被调度器调度。 _Gwaiting：等待状态。Goroutine 在等待某个条件（例如通道操作、定时器、网络 I/O 等）完成。 _Gdead：死亡状态。Goroutine 已经完成执行，无法再被重新使用。 _Gcopystack：堆栈复制状态。Goroutine 的堆栈正在被复制，以调整其大小。 状态转变及其与 GMP 的关系 创建 Goroutine _Gidle -\u003e _Grunnable 创建一个新的 Goroutine，并将其状态设置为 _Grunnable，表示该 Goroutine 准备好运行。 由 P 将新的 Goroutine 添加到其本地运行队列或全局运行队列中。 g := newGoroutine() g.status = _Grunnable p.runqput(g) 调度和运行 Goroutine _Grunnable -\u003e _Grunning P 从本地运行队列或全局运行队列中取出一个 Goroutine，将其状态设置为 _Grunning，并将其分配给一个 M 来执行。 g := p.runqget() g.status = _Grunning m.execute(g) 系统调用 _Grunning -\u003e _Gsyscall Goroutine 在运行过程中进行系统调用，状态转变为 _Gsyscall。 由于系统调用可能会阻塞，M 会寻找其他可运行的 Goroutine 来执行。 g.status = _Gsyscall m.scheduleNextGoroutine() _Gsyscall -\u003e _Grunnable 系统调用完成后，Goroutine 状态从 _Gsyscall 转变为 _Grunnable，等待再次被调度运行。 g.status = _Grunnable p.runqput(g) 等待和唤醒 _Grunning -\u003e _Gwaiting Goroutine 在运行过程中等待某个条件完成，例如通道操作，状态转变为 _Gwaiting。 g.status = _Gwaiting m.scheduleNextGoroutine() _Gwaiting -\u003e _Grunnable 等待的条件满足后，Goroutine 状态从 _Gwaiting 转变为 _Grunnable，等待被再次调度运行。 g.status = _Grunnable p.runqput(g) 结束执行 _Grunning -\u003e _Gdead Goroutine 执行完毕，状态转变为 _Gdead，等待被回收。 g.status = _Gdead GMP 模型与状态转变的关系 G（Goroutine）：G 是 Go 语言中的轻量级线程。G 的状态在其生命周期中不断变化，GMP 模型通过调度 G 来实现高效并发。 M（Machine）：M 是实际的操作系统线程，负责执行 G。M 可以在不同的 P 上运行不同的 G。 P（Processor）：P 是调度器的抽象，管理本地运行队列中的 G，并调度 M 来执行 G。每个 P 持有一个本地的 Goroutine 队列。 总结\nG 的状态转变和 GMP 模型的关系密不可分。Goroutine 从创建到运行、等待、系统调用和结束，状态不断变化，而这些状态变化由 P 管理的运行队列和 M 执行 G 来实现。GMP 模型确保了 Go 语言的高效并发能力，通过合理的状态管理和调度，充分利用系统资源，优化 Goroutine 的执行。\n一个goroutine阻塞，会不会影响其他的goroutine？ 一个 Goroutine 阻塞不会影响其他的 Goroutine。Go 的运行时调度器会自动将阻塞的 Goroutine 挂起，并调度其他可运行的 Goroutine 执行。因此，多个 Goroutine 可以并发执行，即使其中一些 Goroutine 阻塞了，也不会影响其他 Goroutine 的执行。\nChannel是怎么实现的？ Go语言中的通道（channel）是实现并发编程的核心机制之一。通道提供了一种在多个goroutine之间安全地传递数据的方式。通道的实现是Go运行时系统的一部分，它基于一种称为“goroutine-safe”的队列数据结构，并结合了锁和条件变量来确保并发安全性。\n以下是Go通道实现的一些关键点：\n数据结构：\nhchan 结构体：这是Go运行时系统中用于表示通道的核心数据结构。它包含了通道的各种属性，如缓冲区、发送队列、接收队列、锁、类型信息等。 sudog 结构体：用于表示等待在通道上的goroutine。每个等待的goroutine都会被包装成一个sudog对象，并放入发送队列或接收队列中。 缓冲区：\n通道可以是缓冲的或非缓冲的。缓冲通道有一个固定大小的缓冲区，用于存储发送的数据，直到它们被接收。非缓冲通道没有缓冲区，发送和接收操作是同步的。 锁：\n通道使用互斥锁（mutex）来保护其内部数据结构，确保在任何时候只有一个goroutine可以访问通道的状态。 条件变量：\n通道使用条件变量来实现goroutine的阻塞和唤醒。当goroutine尝试向满的缓冲通道发送数据或从空的缓冲通道接收数据时，它们会被阻塞，并放入相应的发送队列或接收队列中。 发送和接收操作：\n发送操作（ch \u003c- value）：如果通道有空间（对于非缓冲通道，意味着有等待的接收者；对于缓冲通道，意味着缓冲区未满），则数据被复制到通道的缓冲区或直接传递给接收者。否则，发送goroutine会被阻塞，直到通道有空间。 接收操作（value := \u003c-ch）：如果通道有数据（对于非缓冲通道，意味着有等待的发送者；对于缓冲通道，意味着缓冲区非空），则数据被复制到接收者的变量中。否则，接收goroutine会被阻塞，直到通道有数据。 关闭操作：\n关闭操作（close(ch)）：关闭通道会释放所有等待的goroutine，并通知它们通道已关闭。关闭一个已经关闭的通道或一个nil通道都会导致panic。 垃圾回收：\n通道的内存管理与Go的垃圾回收机制集成。当通道不再被引用时，它会被垃圾回收器回收。 Go通道的实现确保了goroutine之间的同步和通信是高效且安全的。通过使用通道，开发者可以避免显式地处理锁和其他并发控制机制，从而简化了并发编程。\nContext 在Go语言中，context（上下文）是一个标准库包，它提供了一种在goroutine之间传递请求范围的值、取消信号和截止时间的机制。context包的核心是Context接口，它定义了四个方法：\nDeadline：返回Context被取消的时间，也就是完成工作的截止时间。 Done：返回一个\u003c-chan struct{}，当Context被取消或者超时时，该通道会被关闭，从而发出信号。 Err：返回Context被取消的原因。 Value：返回与Context关联的键值对数据。 context包的主要用途包括：\n取消操作：当一个请求被取消或超时时，可以使用context来通知所有处理该请求的goroutine停止工作，从而避免不必要的资源消耗。\n传递请求范围的值：在处理请求的过程中，可能需要在多个goroutine之间共享一些数据，如认证令牌、请求ID等。context提供了一种方便的方式来传递这些数据。\n截止时间管理：在处理请求时，可能需要设置一个截止时间，超过这个时间后，无论工作是否完成，都应该停止工作。context可以用来设置和管理这些截止时间。\n使用context的基本模式是：\n在处理请求的顶级goroutine中创建一个Context对象，通常是通过调用context.Background()或context.TODO()来获取一个空的Context，然后使用context.WithCancel、context.WithDeadline、context.WithTimeout或context.WithValue来创建一个具体的Context。 将这个Context传递给处理请求的所有goroutine。 在goroutine中，通过检查Context的Done通道来判断是否应该停止工作。 使用Context的Value方法来获取请求范围的值。 例如，以下是一个使用context来取消操作的简单示例：\npackage main import ( \"context\" \"fmt\" \"time\" ) func main() { // 创建一个可以取消的Context ctx, cancel := context.WithCancel(context.Background()) // 启动一个goroutine来执行任务 go func() { printLine(\"Working...\") time.Sleep(2 * time.Second) // 模拟工作 printLine(\"Work done.\") }() // 等待一段时间后取消任务 time.Sleep(1 * time.Second) cancel() // 等待goroutine结束 time.Sleep(2 * time.Second) printLine(\"Main function done.\") } func printLine(s string) { fmt.Println(s, time.Now().Format(time.RFC3339)) } 在这个例子中，context.WithCancel创建了一个可以取消的Context，cancel函数用于发出取消信号。当cancel被调用时，所有监听ctx.Done()通道的goroutine都会收到信号，从而知道应该停止工作。\nGo的内存分布 Go 的内存分布主要包括以下几个区域：\n栈内存（Stack Memory）：\n每个 Goroutine 都有一个独立的栈内存，初始大小很小（如 2KB），但可以动态增长。 栈内存用于存储局部变量、函数参数和返回值等。 堆内存（Heap Memory）：\n动态分配的内存块（通过 new 和 make 分配）存储在堆上。 堆内存由 Go 的垃圾回收器管理。 全局/静态内存（Global/Static Memory）：\n用于存储全局变量和静态变量。 在程序的整个生命周期内都存在。 文本段（Text Segment）：\n存储程序的代码，即可执行指令。 数据段（Data Segment）：\n存储已初始化的全局变量和静态变量。 Go的GC（垃圾回收） Go 的垃圾回收器是一个非分代、并发标记清除垃圾回收器。其工作过程如下：\n标记阶段（Marking Phase）：\n垃圾回收器遍历所有的可达对象并标记它们。 可达对象是指从根对象（全局变量、栈变量、寄存器等）开始，沿着引用链可以访问到的对象。 清除阶段（Sweeping Phase）：\n标记阶段结束后，垃圾回收器会清除未标记的对象，并将这些对象的内存归还给堆。 Go 的垃圾回收器是并发的，这意味着它可以与应用程序的 Goroutine 同时运行，以减少垃圾回收带来的停顿时间（STW，Stop-The-World）。\nsync.Map是如何实现并发安全的？ sync.Map 是 Go 提供的一个并发安全的 map 实现，主要通过以下方式实现并发安全：\n读写分离：\n使用两个不同的数据结构（read 和 dirty）来存储数据，read 用于大多数读取操作，dirty 用于写入操作。 读取操作不会锁住整个 map，而是直接访问 read 数据结构。 原子操作：\n对于读取操作，使用原子操作来确保并发安全。 当写入操作需要修改 dirty map 时，会使用互斥锁（sync.Mutex）来确保安全。 惰性初始化：\n如果 dirty map 的某个键被访问多次，就会将它提升到 read map，以减少锁竞争。 鸭子类型 不要求显式的定义对象的类型，只要这个对象实现了接口中的方法，就可以视作同一类型。\npackage main import \"fmt\" // 定义一个接口 type Quacker interface { Quack() } // 定义一个Duck结构体 type Duck struct{} func (d Duck) Quack() { fmt.Println(\"Quack!\") } // 定义一个Person结构体 type Person struct{} func (p Person) Quack() { fmt.Println(\"I'm not a duck, but I can quack!\") } func makeItQuack(q Quacker) { q.Quack() } func main() { var d Duck var p Person makeItQuack(d) // 输出：Quack! makeItQuack(p) // 输出：I'm not a duck, but I can quack! } 在上述代码中，Duck 和 Person 都实现了 Quacker 接口中的 Quack 方法，因此它们都可以作为 Quacker 类型的参数传递给 makeItQuack 函数。\n","wordCount":"498","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-06-12T00:00:00Z","dateModified":"2024-06-12T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/jobhunter/go8/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">golang八股文</h1><div class=post-meta><span title='2024-06-12 00:00:00 +0000 UTC'>June 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;498 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#golang aria-label=Golang>Golang</a><ul><li><a href=#goroutine%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f aria-label=goroutine内存泄漏>goroutine内存泄漏</a></li><li><a href=#go%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84gmp aria-label=Go调度器的GMP>Go调度器的GMP</a><ul><li><a href=#g-%e7%9a%84%e7%8a%b6%e6%80%81 aria-label="G 的状态">G 的状态</a></li><li><a href=#%e7%8a%b6%e6%80%81%e8%bd%ac%e5%8f%98%e5%8f%8a%e5%85%b6%e4%b8%8e-gmp-%e7%9a%84%e5%85%b3%e7%b3%bb aria-label="状态转变及其与 GMP 的关系">状态转变及其与 GMP 的关系</a><ul><li><a href=#%e5%88%9b%e5%bb%ba-goroutine aria-label="创建 Goroutine">创建 Goroutine</a></li><li><a href=#%e8%b0%83%e5%ba%a6%e5%92%8c%e8%bf%90%e8%a1%8c-goroutine aria-label="调度和运行 Goroutine">调度和运行 Goroutine</a></li><li><a href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-label=系统调用>系统调用</a></li><li><a href=#%e7%ad%89%e5%be%85%e5%92%8c%e5%94%a4%e9%86%92 aria-label=等待和唤醒>等待和唤醒</a></li><li><a href=#%e7%bb%93%e6%9d%9f%e6%89%a7%e8%a1%8c aria-label=结束执行>结束执行</a></li></ul></li><li><a href=#gmp-%e6%a8%a1%e5%9e%8b%e4%b8%8e%e7%8a%b6%e6%80%81%e8%bd%ac%e5%8f%98%e7%9a%84%e5%85%b3%e7%b3%bb aria-label="GMP 模型与状态转变的关系">GMP 模型与状态转变的关系</a></li><li><a href=#%e4%b8%80%e4%b8%aagoroutine%e9%98%bb%e5%a1%9e%e4%bc%9a%e4%b8%8d%e4%bc%9a%e5%bd%b1%e5%93%8d%e5%85%b6%e4%bb%96%e7%9a%84goroutine aria-label=一个goroutine阻塞，会不会影响其他的goroutine？>一个goroutine阻塞，会不会影响其他的goroutine？</a></li></ul></li><li><a href=#channel%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84 aria-label=Channel是怎么实现的？>Channel是怎么实现的？</a></li><li><a href=#context aria-label=Context>Context</a></li><li><a href=#go%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e5%b8%83 aria-label=Go的内存分布>Go的内存分布</a></li><li><a href=#go%e7%9a%84gc%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 aria-label=Go的GC（垃圾回收）>Go的GC（垃圾回收）</a></li><li><a href=#syncmap%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e7%9a%84 aria-label=sync.Map是如何实现并发安全的？>sync.Map是如何实现并发安全的？</a></li><li><a href=#%e9%b8%ad%e5%ad%90%e7%b1%bb%e5%9e%8b aria-label=鸭子类型>鸭子类型</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=golang>Golang<a hidden class=anchor aria-hidden=true href=#golang>#</a></h1><h2 id=goroutine内存泄漏>goroutine内存泄漏<a hidden class=anchor aria-hidden=true href=#goroutine内存泄漏>#</a></h2><p><strong>slice导致</strong></p><p>获取长字符串中的一段，导致字符串未释放；</p><p>获取长slice中的一段导致长slice未释放；</p><p>在长切片中新建sllice导致泄漏</p><p><strong>channel导致</strong></p><p>发送不接受，接收不发送，nil channel</p><ol><li>从 channel 里读，但是同时没有写入操作</li><li>向 无缓冲 channel 里写，但是同时没有读操作</li><li>向已满的 有缓冲 channel 里写，但是同时没有读操作</li><li>select操作在所有case上都阻塞()</li><li>goroutine进入死循环，一直结束不了</li><li>向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。</li></ol><p>可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。</p><p><strong>传统同步方式sync.mutex，sync.waitgroup导致</strong></p><p>用了mutex加lock之后忘记unlock；</p><p>在一开始设置了具体数目的wg.wait(n)，但是有没有写够足够数量n的wg.Done()，导致wg.Wait()一直等待下去。（正确方式可以使用wg.Add(1)配合wg.Done使用）</p><h2 id=go调度器的gmp>Go调度器的GMP<a hidden class=anchor aria-hidden=true href=#go调度器的gmp>#</a></h2><p>在Go语言中，GPM通常指的是Goroutine、Processor和Machine，这是Go调度器（scheduler）的核心组成部分。下面是对每个部分的详细介绍：</p><ol><li><p><strong>Goroutine (G)</strong>:</p><ul><li>Goroutine是Go语言中的轻量级线程，由Go运行时管理。它们是并发的基本单位，可以被创建和销毁，而无需操作系统级别的线程开销。Goroutine的创建和销毁非常快速，因此可以轻松地创建成千上万个Goroutine。</li><li>Goroutine的调度是协作式的，这意味着一个Goroutine在执行时会自愿放弃CPU，让其他Goroutine有机会执行。这种协作式调度使得Go语言能够高效地利用多核处理器。</li></ul></li><li><p><strong>Processor (P)</strong>:</p><ul><li>Processor是Go调度器中的一个抽象概念，代表一个逻辑处理器。每个P都有一个本地运行队列，用于存储待执行的Goroutine。P的数量可以通过环境变量或运行时设置来调整，通常设置为CPU的核心数。</li><li>P的主要作用是管理Goroutine的执行。当一个Goroutine被调度到P上时，P会将其分配给一个可用的Machine（M）来执行。</li></ul></li><li><p><strong>Machine (M)</strong>:</p><ul><li>Machine代表一个操作系统线程。M与P关联，负责执行Goroutine。一个M可以与多个P关联，但在任何给定时间，一个M只能执行一个P的Goroutine。</li><li>M的主要作用是执行Goroutine的代码。当一个Goroutine被调度到M上时，M会执行该Goroutine的代码，直到该Goroutine自愿放弃CPU或被抢占。</li></ul></li></ol><p>Go调度器的工作原理是将Goroutine（G）分配到Processor（P）上，然后由Machine（M）执行。这种设计使得Go语言能够高效地利用多核处理器，并实现高并发。</p><p>在 Go 语言的运行时系统中，Goroutine（简称 G）有多种状态，用于描述它在不同时间点的执行情况。这些状态在 Go 的调度器（GMP 模型）中扮演重要角色。GMP 模型由 Goroutine（G）、工作线程（M）和处理器（P）三部分组成。以下是 G 的主要状态及其转变过程，以及它们与 GMP 模型的关系。</p><h3 id=g-的状态>G 的状态<a hidden class=anchor aria-hidden=true href=#g-的状态>#</a></h3><ol><li><strong>_Gidle</strong>：空闲状态。Goroutine 尚未被使用或已经完成执行，等待被分配新任务。</li><li><strong>_Grunnable</strong>：可运行状态。Goroutine 已经准备好运行，等待被调度器选中运行。</li><li><strong>_Grunning</strong>：运行状态。Goroutine 正在运行中。</li><li><strong>_Gsyscall</strong>：系统调用状态。Goroutine 正在执行系统调用，处于阻塞状态，不会被调度器调度。</li><li><strong>_Gwaiting</strong>：等待状态。Goroutine 在等待某个条件（例如通道操作、定时器、网络 I/O 等）完成。</li><li><strong>_Gdead</strong>：死亡状态。Goroutine 已经完成执行，无法再被重新使用。</li><li><strong>_Gcopystack</strong>：堆栈复制状态。Goroutine 的堆栈正在被复制，以调整其大小。</li></ol><h3 id=状态转变及其与-gmp-的关系>状态转变及其与 GMP 的关系<a hidden class=anchor aria-hidden=true href=#状态转变及其与-gmp-的关系>#</a></h3><h4 id=创建-goroutine>创建 Goroutine<a hidden class=anchor aria-hidden=true href=#创建-goroutine>#</a></h4><ol><li><strong>_Gidle -> _Grunnable</strong><ul><li>创建一个新的 Goroutine，并将其状态设置为 <code>_Grunnable</code>，表示该 Goroutine 准备好运行。</li><li>由 P 将新的 Goroutine 添加到其本地运行队列或全局运行队列中。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>g</span> <span class=o>:=</span> <span class=nf>newGoroutine</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Grunnable</span>
</span></span><span class=line><span class=cl><span class=nx>p</span><span class=p>.</span><span class=nf>runqput</span><span class=p>(</span><span class=nx>g</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=调度和运行-goroutine>调度和运行 Goroutine<a hidden class=anchor aria-hidden=true href=#调度和运行-goroutine>#</a></h4><ol start=2><li><strong>_Grunnable -> _Grunning</strong><ul><li>P 从本地运行队列或全局运行队列中取出一个 Goroutine，将其状态设置为 <code>_Grunning</code>，并将其分配给一个 M 来执行。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>g</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>runqget</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Grunning</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nf>execute</span><span class=p>(</span><span class=nx>g</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=系统调用>系统调用<a hidden class=anchor aria-hidden=true href=#系统调用>#</a></h4><ol start=3><li><strong>_Grunning -> _Gsyscall</strong><ul><li>Goroutine 在运行过程中进行系统调用，状态转变为 <code>_Gsyscall</code>。</li><li>由于系统调用可能会阻塞，M 会寻找其他可运行的 Goroutine 来执行。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Gsyscall</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nf>scheduleNextGoroutine</span><span class=p>()</span>
</span></span></code></pre></div><ol start=4><li><strong>_Gsyscall -> _Grunnable</strong><ul><li>系统调用完成后，Goroutine 状态从 <code>_Gsyscall</code> 转变为 <code>_Grunnable</code>，等待再次被调度运行。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Grunnable</span>
</span></span><span class=line><span class=cl><span class=nx>p</span><span class=p>.</span><span class=nf>runqput</span><span class=p>(</span><span class=nx>g</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=等待和唤醒>等待和唤醒<a hidden class=anchor aria-hidden=true href=#等待和唤醒>#</a></h4><ol start=5><li><strong>_Grunning -> _Gwaiting</strong><ul><li>Goroutine 在运行过程中等待某个条件完成，例如通道操作，状态转变为 <code>_Gwaiting</code>。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Gwaiting</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nf>scheduleNextGoroutine</span><span class=p>()</span>
</span></span></code></pre></div><ol start=6><li><strong>_Gwaiting -> _Grunnable</strong><ul><li>等待的条件满足后，Goroutine 状态从 <code>_Gwaiting</code> 转变为 <code>_Grunnable</code>，等待被再次调度运行。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Grunnable</span>
</span></span><span class=line><span class=cl><span class=nx>p</span><span class=p>.</span><span class=nf>runqput</span><span class=p>(</span><span class=nx>g</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=结束执行>结束执行<a hidden class=anchor aria-hidden=true href=#结束执行>#</a></h4><ol start=7><li><strong>_Grunning -> _Gdead</strong><ul><li>Goroutine 执行完毕，状态转变为 <code>_Gdead</code>，等待被回收。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>status</span> <span class=p>=</span> <span class=nx>_Gdead</span>
</span></span></code></pre></div><h3 id=gmp-模型与状态转变的关系>GMP 模型与状态转变的关系<a hidden class=anchor aria-hidden=true href=#gmp-模型与状态转变的关系>#</a></h3><ul><li><strong>G（Goroutine）</strong>：G 是 Go 语言中的轻量级线程。G 的状态在其生命周期中不断变化，GMP 模型通过调度 G 来实现高效并发。</li><li><strong>M（Machine）</strong>：M 是实际的操作系统线程，负责执行 G。M 可以在不同的 P 上运行不同的 G。</li><li><strong>P（Processor）</strong>：P 是调度器的抽象，管理本地运行队列中的 G，并调度 M 来执行 G。每个 P 持有一个本地的 Goroutine 队列。</li></ul><p><strong>总结</strong></p><p>G 的状态转变和 GMP 模型的关系密不可分。Goroutine 从创建到运行、等待、系统调用和结束，状态不断变化，而这些状态变化由 P 管理的运行队列和 M 执行 G 来实现。GMP 模型确保了 Go 语言的高效并发能力，通过合理的状态管理和调度，充分利用系统资源，优化 Goroutine 的执行。</p><h3 id=一个goroutine阻塞会不会影响其他的goroutine>一个goroutine阻塞，会不会影响其他的goroutine？<a hidden class=anchor aria-hidden=true href=#一个goroutine阻塞会不会影响其他的goroutine>#</a></h3><p>一个 Goroutine 阻塞不会影响其他的 Goroutine。Go 的运行时调度器会自动将阻塞的 Goroutine 挂起，并调度其他可运行的 Goroutine 执行。因此，多个 Goroutine 可以并发执行，即使其中一些 Goroutine 阻塞了，也不会影响其他 Goroutine 的执行。</p><h2 id=channel是怎么实现的>Channel是怎么实现的？<a hidden class=anchor aria-hidden=true href=#channel是怎么实现的>#</a></h2><p>Go语言中的通道（channel）是实现并发编程的核心机制之一。通道提供了一种在多个goroutine之间安全地传递数据的方式。通道的实现是Go运行时系统的一部分，它基于一种称为“goroutine-safe”的队列数据结构，并结合了锁和条件变量来确保并发安全性。</p><p>以下是Go通道实现的一些关键点：</p><ol><li><p><strong>数据结构</strong>：</p><ul><li><code>hchan</code> 结构体：这是Go运行时系统中用于表示通道的核心数据结构。它包含了通道的各种属性，如缓冲区、发送队列、接收队列、锁、类型信息等。</li><li><code>sudog</code> 结构体：用于表示等待在通道上的goroutine。每个等待的goroutine都会被包装成一个<code>sudog</code>对象，并放入发送队列或接收队列中。</li></ul></li><li><p><strong>缓冲区</strong>：</p><ul><li>通道可以是缓冲的或非缓冲的。缓冲通道有一个固定大小的缓冲区，用于存储发送的数据，直到它们被接收。非缓冲通道没有缓冲区，发送和接收操作是同步的。</li></ul></li><li><p><strong>锁</strong>：</p><ul><li>通道使用互斥锁（<code>mutex</code>）来保护其内部数据结构，确保在任何时候只有一个goroutine可以访问通道的状态。</li></ul></li><li><p><strong>条件变量</strong>：</p><ul><li>通道使用条件变量来实现goroutine的阻塞和唤醒。当goroutine尝试向满的缓冲通道发送数据或从空的缓冲通道接收数据时，它们会被阻塞，并放入相应的发送队列或接收队列中。</li></ul></li><li><p><strong>发送和接收操作</strong>：</p><ul><li>发送操作（<code>ch &lt;- value</code>）：如果通道有空间（对于非缓冲通道，意味着有等待的接收者；对于缓冲通道，意味着缓冲区未满），则数据被复制到通道的缓冲区或直接传递给接收者。否则，发送goroutine会被阻塞，直到通道有空间。</li><li>接收操作（<code>value := &lt;-ch</code>）：如果通道有数据（对于非缓冲通道，意味着有等待的发送者；对于缓冲通道，意味着缓冲区非空），则数据被复制到接收者的变量中。否则，接收goroutine会被阻塞，直到通道有数据。</li></ul></li><li><p><strong>关闭操作</strong>：</p><ul><li>关闭操作（<code>close(ch)</code>）：关闭通道会释放所有等待的goroutine，并通知它们通道已关闭。关闭一个已经关闭的通道或一个<code>nil</code>通道都会导致panic。</li></ul></li><li><p><strong>垃圾回收</strong>：</p><ul><li>通道的内存管理与Go的垃圾回收机制集成。当通道不再被引用时，它会被垃圾回收器回收。</li></ul></li></ol><p>Go通道的实现确保了goroutine之间的同步和通信是高效且安全的。通过使用通道，开发者可以避免显式地处理锁和其他并发控制机制，从而简化了并发编程。</p><h2 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h2><p>在Go语言中，<code>context</code>（上下文）是一个标准库包，它提供了一种在goroutine之间传递请求范围的值、取消信号和截止时间的机制。<code>context</code>包的核心是<code>Context</code>接口，它定义了四个方法：</p><ul><li><code>Deadline</code>：返回<code>Context</code>被取消的时间，也就是完成工作的截止时间。</li><li><code>Done</code>：返回一个<code>&lt;-chan struct{}</code>，当<code>Context</code>被取消或者超时时，该通道会被关闭，从而发出信号。</li><li><code>Err</code>：返回<code>Context</code>被取消的原因。</li><li><code>Value</code>：返回与<code>Context</code>关联的键值对数据。</li></ul><p><code>context</code>包的主要用途包括：</p><ol><li><p><strong>取消操作</strong>：当一个请求被取消或超时时，可以使用<code>context</code>来通知所有处理该请求的goroutine停止工作，从而避免不必要的资源消耗。</p></li><li><p><strong>传递请求范围的值</strong>：在处理请求的过程中，可能需要在多个goroutine之间共享一些数据，如认证令牌、请求ID等。<code>context</code>提供了一种方便的方式来传递这些数据。</p></li><li><p><strong>截止时间管理</strong>：在处理请求时，可能需要设置一个截止时间，超过这个时间后，无论工作是否完成，都应该停止工作。<code>context</code>可以用来设置和管理这些截止时间。</p></li></ol><p>使用<code>context</code>的基本模式是：</p><ul><li>在处理请求的顶级goroutine中创建一个<code>Context</code>对象，通常是通过调用<code>context.Background()</code>或<code>context.TODO()</code>来获取一个空的<code>Context</code>，然后使用<code>context.WithCancel</code>、<code>context.WithDeadline</code>、<code>context.WithTimeout</code>或<code>context.WithValue</code>来创建一个具体的<code>Context</code>。</li><li>将这个<code>Context</code>传递给处理请求的所有goroutine。</li><li>在goroutine中，通过检查<code>Context</code>的<code>Done</code>通道来判断是否应该停止工作。</li><li>使用<code>Context</code>的<code>Value</code>方法来获取请求范围的值。</li></ul><p>例如，以下是一个使用<code>context</code>来取消操作的简单示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 创建一个可以取消的Context
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 启动一个goroutine来执行任务
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>printLine</span><span class=p>(</span><span class=s>&#34;Working...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 模拟工作
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>printLine</span><span class=p>(</span><span class=s>&#34;Work done.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 等待一段时间后取消任务
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 等待goroutine结束
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>printLine</span><span class=p>(</span><span class=s>&#34;Main function done.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printLine</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Format</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>RFC3339</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这个例子中，<code>context.WithCancel</code>创建了一个可以取消的<code>Context</code>，<code>cancel</code>函数用于发出取消信号。当<code>cancel</code>被调用时，所有监听<code>ctx.Done()</code>通道的goroutine都会收到信号，从而知道应该停止工作。</p><h2 id=go的内存分布>Go的内存分布<a hidden class=anchor aria-hidden=true href=#go的内存分布>#</a></h2><p>Go 的内存分布主要包括以下几个区域：</p><ol><li><p><strong>栈内存（Stack Memory）</strong>：</p><ul><li>每个 Goroutine 都有一个独立的栈内存，初始大小很小（如 2KB），但可以动态增长。</li><li>栈内存用于存储局部变量、函数参数和返回值等。</li></ul></li><li><p><strong>堆内存（Heap Memory）</strong>：</p><ul><li>动态分配的内存块（通过 <code>new</code> 和 <code>make</code> 分配）存储在堆上。</li><li>堆内存由 Go 的垃圾回收器管理。</li></ul></li><li><p><strong>全局/静态内存（Global/Static Memory）</strong>：</p><ul><li>用于存储全局变量和静态变量。</li><li>在程序的整个生命周期内都存在。</li></ul></li><li><p><strong>文本段（Text Segment）</strong>：</p><ul><li>存储程序的代码，即可执行指令。</li></ul></li><li><p><strong>数据段（Data Segment）</strong>：</p><ul><li>存储已初始化的全局变量和静态变量。</li></ul></li></ol><h2 id=go的gc垃圾回收>Go的GC（垃圾回收）<a hidden class=anchor aria-hidden=true href=#go的gc垃圾回收>#</a></h2><p>Go 的垃圾回收器是一个非分代、并发标记清除垃圾回收器。其工作过程如下：</p><ol><li><p><strong>标记阶段（Marking Phase）</strong>：</p><ul><li>垃圾回收器遍历所有的可达对象并标记它们。</li><li>可达对象是指从根对象（全局变量、栈变量、寄存器等）开始，沿着引用链可以访问到的对象。</li></ul></li><li><p><strong>清除阶段（Sweeping Phase）</strong>：</p><ul><li>标记阶段结束后，垃圾回收器会清除未标记的对象，并将这些对象的内存归还给堆。</li></ul></li></ol><p>Go 的垃圾回收器是并发的，这意味着它可以与应用程序的 Goroutine 同时运行，以减少垃圾回收带来的停顿时间（STW，Stop-The-World）。</p><h2 id=syncmap是如何实现并发安全的>sync.Map是如何实现并发安全的？<a hidden class=anchor aria-hidden=true href=#syncmap是如何实现并发安全的>#</a></h2><p><code>sync.Map</code> 是 Go 提供的一个并发安全的 map 实现，主要通过以下方式实现并发安全：</p><ol><li><p><strong>读写分离</strong>：</p><ul><li>使用两个不同的数据结构（read 和 dirty）来存储数据，read 用于大多数读取操作，dirty 用于写入操作。</li><li>读取操作不会锁住整个 map，而是直接访问 read 数据结构。</li></ul></li><li><p><strong>原子操作</strong>：</p><ul><li>对于读取操作，使用原子操作来确保并发安全。</li><li>当写入操作需要修改 dirty map 时，会使用互斥锁（<code>sync.Mutex</code>）来确保安全。</li></ul></li><li><p><strong>惰性初始化</strong>：</p><ul><li>如果 dirty map 的某个键被访问多次，就会将它提升到 read map，以减少锁竞争。</li></ul></li></ol><h2 id=鸭子类型>鸭子类型<a hidden class=anchor aria-hidden=true href=#鸭子类型>#</a></h2><p>不要求显式的定义对象的类型，只要这个对象实现了接口中的方法，就可以视作同一类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 定义一个接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Quacker</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Quack</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 定义一个Duck结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Duck</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=nx>Duck</span><span class=p>)</span> <span class=nf>Quack</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Quack!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 定义一个Person结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Person</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>Person</span><span class=p>)</span> <span class=nf>Quack</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;I&#39;m not a duck, but I can quack!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makeItQuack</span><span class=p>(</span><span class=nx>q</span> <span class=nx>Quacker</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>q</span><span class=p>.</span><span class=nf>Quack</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>d</span> <span class=nx>Duck</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>p</span> <span class=nx>Person</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>makeItQuack</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span> <span class=c1>// 输出：Quack!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>makeItQuack</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span> <span class=c1>// 输出：I&#39;m not a duck, but I can quack!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>在上述代码中，<code>Duck</code> 和 <code>Person</code> 都实现了 <code>Quacker</code> 接口中的 <code>Quack</code> 方法，因此它们都可以作为 <code>Quacker</code> 类型的参数传递给 <code>makeItQuack</code> 函数。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/%E9%9D%A2%E7%BB%8F/>面经</a></li><li><a href=https://sirius1y.top/tags/go/>Go</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/dev/dev-aorb-protorpc/><span class=title>« Prev</span><br><span>Protobuf与gRPC初次使用</span>
</a><a class=next href=https://sirius1y.top/posts/notes/jobhunter/system-design-prime/><span class=title>Next »</span><br><span>system-design-prime</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>