<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis常用指令 | Sirius' Blog</title>
<meta name=keywords content="开发,Redis,MySQL,DB,字节青训营"><meta name=description content="快速了解Redis Redis是什么？为什么要使用Redis？他有什么好处和优势？他的弊端又有哪些呢？他的基本模型和技术有哪些？
Redis是什么？ Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息代理。它被设计用于快速访问、存储和分析数据，以及支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis支持持久化，可以将数据保存在磁盘上，以便在重启后恢复数据。
为什么要使用Redis？ Redis有许多优点，使其成为广泛使用的数据存储和缓存解决方案：
优势 快速访问： Redis数据存储在内存中，因此具有非常快速的读写性能，适合用作缓存层，加速数据访问。 丰富的数据结构： Redis不仅支持简单的键值存储，还支持多种数据结构，如列表、集合、有序集合等，这使得它适用于更多不同类型的应用场景。 持久化： Redis支持数据的持久化，可以将数据保存在磁盘上，以便在服务器重启后恢复数据。 分布式架构： Redis支持分布式集群，可以将数据分散在多个节点上，提高数据的可用性和性能。 发布/订阅： Redis具有消息代理功能，可以用于发布和订阅消息，支持实时数据推送和通知。 事务支持： Redis支持事务，允许一系列操作以原子方式执行，保证数据的一致性。 弊端 内存消耗： Redis的数据存储在内存中，因此对于大规模数据集可能会占用大量内存。尽管有持久化选项，但内存仍然是其主要的存储介质。 单线程： Redis在单个进程中使用单线程处理所有的命令请求。这在某些高并发情况下可能成为性能瓶颈。 基本模型和技术 键值存储： Redis的基本模型是键值存储，您可以使用键来检索存储在Redis中的数据。 数据结构： Redis支持字符串、哈希表、列表、集合、有序集合等多种数据结构，使其非常灵活。 持久化： Redis支持两种持久化方式，分别是快照（snapshotting）和日志（append-only file）。 发布/订阅： Redis支持发布/订阅模式，允许客户端订阅特定的频道并接收实时消息。 分布式： Redis可以通过分片或复制来构建分布式架构，提高可用性和扩展性。 Redis vs. MySQL 性能比较 读写性能： Redis在内存中存储数据，因此具有非常快速的读写性能，尤其适合高并发读取和写入场景。与此相比，MySQL可能受到磁盘IO和索引的影响，其读写性能相对较低。 数据结构： Redis支持多种数据结构，使其适合用于更复杂的数据模型，如实时计数、排行榜、分布式锁等。MySQL虽然也支持多种数据类型，但通常用于结构化数据的存储。 缓存： Redis非常适合用作缓存层，可以减轻数据库的负载，提高数据访问速度。MySQL也可以用作缓存，但Redis的读取速度更快。 事务和持久化： Redis支持事务，但它的事务模型不如MySQL严格。MySQL提供强大的事务支持和多种持久化选项。 适用领域和场景 Redis适合场景 实时数据：例如实时计数、统计信息和分析。 缓存：用作高速缓存，提高数据访问速度。 实时消息：发布/订阅模式用于实时消息传递。 会话存储：存储用户会话数据，适用于分布式系统。 分布式锁：实现分布式锁以协调多个系统的并发操作。 MySQL适合场景 结构化数据：适用于关系型、事务性的结构化数据。 复杂查询：支持复杂的查询和连接操作。 大规模数据存储：适合大规模数据存储和管理。 强大事务：需要强大的事务支持和ACID特性。 Redis和MySQL有各自独特的优势和用途，它们并不是直接替代关系。Redis可以在某些情况下用来增强项目性能，或者作为辅助数据库来存储特定类型的数据，例如缓存、会话、排行榜等。然而，对于需要复杂查询、关联性和事务的应用，Redis并不是MySQL的替代品。对于大部分应用，两者可以共同使用，以发挥各自的优势，构建更高效的系统。
Redis基本命令 现在很多大公司的后端服务都是基础存储服务+Redis缓存的形式，使用Redis进行缓存很大程度上提高了服务的效率，当然也存在缓存穿透、缓存雪崩的问题，但是在此之前还是要从Redis的基础命令开始学习掌握，所以在这里整理了Redis常用的命令。
字符串 在Redis中，字符串可以存储以下3中类型的值：字节串（byte string），整数，浮点数。
自增自减命令 INCR key-name：将键存储的值加上1"><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/database/use-redis/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/database/use-redis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redis常用指令"><meta property="og:description" content="快速了解Redis Redis是什么？为什么要使用Redis？他有什么好处和优势？他的弊端又有哪些呢？他的基本模型和技术有哪些？
Redis是什么？ Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息代理。它被设计用于快速访问、存储和分析数据，以及支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis支持持久化，可以将数据保存在磁盘上，以便在重启后恢复数据。
为什么要使用Redis？ Redis有许多优点，使其成为广泛使用的数据存储和缓存解决方案：
优势 快速访问： Redis数据存储在内存中，因此具有非常快速的读写性能，适合用作缓存层，加速数据访问。 丰富的数据结构： Redis不仅支持简单的键值存储，还支持多种数据结构，如列表、集合、有序集合等，这使得它适用于更多不同类型的应用场景。 持久化： Redis支持数据的持久化，可以将数据保存在磁盘上，以便在服务器重启后恢复数据。 分布式架构： Redis支持分布式集群，可以将数据分散在多个节点上，提高数据的可用性和性能。 发布/订阅： Redis具有消息代理功能，可以用于发布和订阅消息，支持实时数据推送和通知。 事务支持： Redis支持事务，允许一系列操作以原子方式执行，保证数据的一致性。 弊端 内存消耗： Redis的数据存储在内存中，因此对于大规模数据集可能会占用大量内存。尽管有持久化选项，但内存仍然是其主要的存储介质。 单线程： Redis在单个进程中使用单线程处理所有的命令请求。这在某些高并发情况下可能成为性能瓶颈。 基本模型和技术 键值存储： Redis的基本模型是键值存储，您可以使用键来检索存储在Redis中的数据。 数据结构： Redis支持字符串、哈希表、列表、集合、有序集合等多种数据结构，使其非常灵活。 持久化： Redis支持两种持久化方式，分别是快照（snapshotting）和日志（append-only file）。 发布/订阅： Redis支持发布/订阅模式，允许客户端订阅特定的频道并接收实时消息。 分布式： Redis可以通过分片或复制来构建分布式架构，提高可用性和扩展性。 Redis vs. MySQL 性能比较 读写性能： Redis在内存中存储数据，因此具有非常快速的读写性能，尤其适合高并发读取和写入场景。与此相比，MySQL可能受到磁盘IO和索引的影响，其读写性能相对较低。 数据结构： Redis支持多种数据结构，使其适合用于更复杂的数据模型，如实时计数、排行榜、分布式锁等。MySQL虽然也支持多种数据类型，但通常用于结构化数据的存储。 缓存： Redis非常适合用作缓存层，可以减轻数据库的负载，提高数据访问速度。MySQL也可以用作缓存，但Redis的读取速度更快。 事务和持久化： Redis支持事务，但它的事务模型不如MySQL严格。MySQL提供强大的事务支持和多种持久化选项。 适用领域和场景 Redis适合场景 实时数据：例如实时计数、统计信息和分析。 缓存：用作高速缓存，提高数据访问速度。 实时消息：发布/订阅模式用于实时消息传递。 会话存储：存储用户会话数据，适用于分布式系统。 分布式锁：实现分布式锁以协调多个系统的并发操作。 MySQL适合场景 结构化数据：适用于关系型、事务性的结构化数据。 复杂查询：支持复杂的查询和连接操作。 大规模数据存储：适合大规模数据存储和管理。 强大事务：需要强大的事务支持和ACID特性。 Redis和MySQL有各自独特的优势和用途，它们并不是直接替代关系。Redis可以在某些情况下用来增强项目性能，或者作为辅助数据库来存储特定类型的数据，例如缓存、会话、排行榜等。然而，对于需要复杂查询、关联性和事务的应用，Redis并不是MySQL的替代品。对于大部分应用，两者可以共同使用，以发挥各自的优势，构建更高效的系统。
Redis基本命令 现在很多大公司的后端服务都是基础存储服务+Redis缓存的形式，使用Redis进行缓存很大程度上提高了服务的效率，当然也存在缓存穿透、缓存雪崩的问题，但是在此之前还是要从Redis的基础命令开始学习掌握，所以在这里整理了Redis常用的命令。
字符串 在Redis中，字符串可以存储以下3中类型的值：字节串（byte string），整数，浮点数。
自增自减命令 INCR key-name：将键存储的值加上1"><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/database/use-redis/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-03T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-03T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Redis常用指令"><meta name=twitter:description content="快速了解Redis Redis是什么？为什么要使用Redis？他有什么好处和优势？他的弊端又有哪些呢？他的基本模型和技术有哪些？
Redis是什么？ Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息代理。它被设计用于快速访问、存储和分析数据，以及支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis支持持久化，可以将数据保存在磁盘上，以便在重启后恢复数据。
为什么要使用Redis？ Redis有许多优点，使其成为广泛使用的数据存储和缓存解决方案：
优势 快速访问： Redis数据存储在内存中，因此具有非常快速的读写性能，适合用作缓存层，加速数据访问。 丰富的数据结构： Redis不仅支持简单的键值存储，还支持多种数据结构，如列表、集合、有序集合等，这使得它适用于更多不同类型的应用场景。 持久化： Redis支持数据的持久化，可以将数据保存在磁盘上，以便在服务器重启后恢复数据。 分布式架构： Redis支持分布式集群，可以将数据分散在多个节点上，提高数据的可用性和性能。 发布/订阅： Redis具有消息代理功能，可以用于发布和订阅消息，支持实时数据推送和通知。 事务支持： Redis支持事务，允许一系列操作以原子方式执行，保证数据的一致性。 弊端 内存消耗： Redis的数据存储在内存中，因此对于大规模数据集可能会占用大量内存。尽管有持久化选项，但内存仍然是其主要的存储介质。 单线程： Redis在单个进程中使用单线程处理所有的命令请求。这在某些高并发情况下可能成为性能瓶颈。 基本模型和技术 键值存储： Redis的基本模型是键值存储，您可以使用键来检索存储在Redis中的数据。 数据结构： Redis支持字符串、哈希表、列表、集合、有序集合等多种数据结构，使其非常灵活。 持久化： Redis支持两种持久化方式，分别是快照（snapshotting）和日志（append-only file）。 发布/订阅： Redis支持发布/订阅模式，允许客户端订阅特定的频道并接收实时消息。 分布式： Redis可以通过分片或复制来构建分布式架构，提高可用性和扩展性。 Redis vs. MySQL 性能比较 读写性能： Redis在内存中存储数据，因此具有非常快速的读写性能，尤其适合高并发读取和写入场景。与此相比，MySQL可能受到磁盘IO和索引的影响，其读写性能相对较低。 数据结构： Redis支持多种数据结构，使其适合用于更复杂的数据模型，如实时计数、排行榜、分布式锁等。MySQL虽然也支持多种数据类型，但通常用于结构化数据的存储。 缓存： Redis非常适合用作缓存层，可以减轻数据库的负载，提高数据访问速度。MySQL也可以用作缓存，但Redis的读取速度更快。 事务和持久化： Redis支持事务，但它的事务模型不如MySQL严格。MySQL提供强大的事务支持和多种持久化选项。 适用领域和场景 Redis适合场景 实时数据：例如实时计数、统计信息和分析。 缓存：用作高速缓存，提高数据访问速度。 实时消息：发布/订阅模式用于实时消息传递。 会话存储：存储用户会话数据，适用于分布式系统。 分布式锁：实现分布式锁以协调多个系统的并发操作。 MySQL适合场景 结构化数据：适用于关系型、事务性的结构化数据。 复杂查询：支持复杂的查询和连接操作。 大规模数据存储：适合大规模数据存储和管理。 强大事务：需要强大的事务支持和ACID特性。 Redis和MySQL有各自独特的优势和用途，它们并不是直接替代关系。Redis可以在某些情况下用来增强项目性能，或者作为辅助数据库来存储特定类型的数据，例如缓存、会话、排行榜等。然而，对于需要复杂查询、关联性和事务的应用，Redis并不是MySQL的替代品。对于大部分应用，两者可以共同使用，以发挥各自的优势，构建更高效的系统。
Redis基本命令 现在很多大公司的后端服务都是基础存储服务+Redis缓存的形式，使用Redis进行缓存很大程度上提高了服务的效率，当然也存在缓存穿透、缓存雪崩的问题，但是在此之前还是要从Redis的基础命令开始学习掌握，所以在这里整理了Redis常用的命令。
字符串 在Redis中，字符串可以存储以下3中类型的值：字节串（byte string），整数，浮点数。
自增自减命令 INCR key-name：将键存储的值加上1"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"Redis常用指令","item":"https://sirius1y.top/posts/notes/database/use-redis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis常用指令","name":"Redis常用指令","description":"快速了解Redis Redis是什么？为什么要使用Redis？他有什么好处和优势？他的弊端又有哪些呢？他的基本模型和技术有哪些？\nRedis是什么？ Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息代理。它被设计用于快速访问、存储和分析数据，以及支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis支持持久化，可以将数据保存在磁盘上，以便在重启后恢复数据。\n为什么要使用Redis？ Redis有许多优点，使其成为广泛使用的数据存储和缓存解决方案：\n优势 快速访问： Redis数据存储在内存中，因此具有非常快速的读写性能，适合用作缓存层，加速数据访问。 丰富的数据结构： Redis不仅支持简单的键值存储，还支持多种数据结构，如列表、集合、有序集合等，这使得它适用于更多不同类型的应用场景。 持久化： Redis支持数据的持久化，可以将数据保存在磁盘上，以便在服务器重启后恢复数据。 分布式架构： Redis支持分布式集群，可以将数据分散在多个节点上，提高数据的可用性和性能。 发布/订阅： Redis具有消息代理功能，可以用于发布和订阅消息，支持实时数据推送和通知。 事务支持： Redis支持事务，允许一系列操作以原子方式执行，保证数据的一致性。 弊端 内存消耗： Redis的数据存储在内存中，因此对于大规模数据集可能会占用大量内存。尽管有持久化选项，但内存仍然是其主要的存储介质。 单线程： Redis在单个进程中使用单线程处理所有的命令请求。这在某些高并发情况下可能成为性能瓶颈。 基本模型和技术 键值存储： Redis的基本模型是键值存储，您可以使用键来检索存储在Redis中的数据。 数据结构： Redis支持字符串、哈希表、列表、集合、有序集合等多种数据结构，使其非常灵活。 持久化： Redis支持两种持久化方式，分别是快照（snapshotting）和日志（append-only file）。 发布/订阅： Redis支持发布/订阅模式，允许客户端订阅特定的频道并接收实时消息。 分布式： Redis可以通过分片或复制来构建分布式架构，提高可用性和扩展性。 Redis vs. MySQL 性能比较 读写性能： Redis在内存中存储数据，因此具有非常快速的读写性能，尤其适合高并发读取和写入场景。与此相比，MySQL可能受到磁盘IO和索引的影响，其读写性能相对较低。 数据结构： Redis支持多种数据结构，使其适合用于更复杂的数据模型，如实时计数、排行榜、分布式锁等。MySQL虽然也支持多种数据类型，但通常用于结构化数据的存储。 缓存： Redis非常适合用作缓存层，可以减轻数据库的负载，提高数据访问速度。MySQL也可以用作缓存，但Redis的读取速度更快。 事务和持久化： Redis支持事务，但它的事务模型不如MySQL严格。MySQL提供强大的事务支持和多种持久化选项。 适用领域和场景 Redis适合场景 实时数据：例如实时计数、统计信息和分析。 缓存：用作高速缓存，提高数据访问速度。 实时消息：发布/订阅模式用于实时消息传递。 会话存储：存储用户会话数据，适用于分布式系统。 分布式锁：实现分布式锁以协调多个系统的并发操作。 MySQL适合场景 结构化数据：适用于关系型、事务性的结构化数据。 复杂查询：支持复杂的查询和连接操作。 大规模数据存储：适合大规模数据存储和管理。 强大事务：需要强大的事务支持和ACID特性。 Redis和MySQL有各自独特的优势和用途，它们并不是直接替代关系。Redis可以在某些情况下用来增强项目性能，或者作为辅助数据库来存储特定类型的数据，例如缓存、会话、排行榜等。然而，对于需要复杂查询、关联性和事务的应用，Redis并不是MySQL的替代品。对于大部分应用，两者可以共同使用，以发挥各自的优势，构建更高效的系统。\nRedis基本命令 现在很多大公司的后端服务都是基础存储服务+Redis缓存的形式，使用Redis进行缓存很大程度上提高了服务的效率，当然也存在缓存穿透、缓存雪崩的问题，但是在此之前还是要从Redis的基础命令开始学习掌握，所以在这里整理了Redis常用的命令。\n字符串 在Redis中，字符串可以存储以下3中类型的值：字节串（byte string），整数，浮点数。\n自增自减命令 INCR key-name：将键存储的值加上1","keywords":["开发","Redis","MySQL","DB","字节青训营"],"articleBody":"快速了解Redis Redis是什么？为什么要使用Redis？他有什么好处和优势？他的弊端又有哪些呢？他的基本模型和技术有哪些？\nRedis是什么？ Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息代理。它被设计用于快速访问、存储和分析数据，以及支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis支持持久化，可以将数据保存在磁盘上，以便在重启后恢复数据。\n为什么要使用Redis？ Redis有许多优点，使其成为广泛使用的数据存储和缓存解决方案：\n优势 快速访问： Redis数据存储在内存中，因此具有非常快速的读写性能，适合用作缓存层，加速数据访问。 丰富的数据结构： Redis不仅支持简单的键值存储，还支持多种数据结构，如列表、集合、有序集合等，这使得它适用于更多不同类型的应用场景。 持久化： Redis支持数据的持久化，可以将数据保存在磁盘上，以便在服务器重启后恢复数据。 分布式架构： Redis支持分布式集群，可以将数据分散在多个节点上，提高数据的可用性和性能。 发布/订阅： Redis具有消息代理功能，可以用于发布和订阅消息，支持实时数据推送和通知。 事务支持： Redis支持事务，允许一系列操作以原子方式执行，保证数据的一致性。 弊端 内存消耗： Redis的数据存储在内存中，因此对于大规模数据集可能会占用大量内存。尽管有持久化选项，但内存仍然是其主要的存储介质。 单线程： Redis在单个进程中使用单线程处理所有的命令请求。这在某些高并发情况下可能成为性能瓶颈。 基本模型和技术 键值存储： Redis的基本模型是键值存储，您可以使用键来检索存储在Redis中的数据。 数据结构： Redis支持字符串、哈希表、列表、集合、有序集合等多种数据结构，使其非常灵活。 持久化： Redis支持两种持久化方式，分别是快照（snapshotting）和日志（append-only file）。 发布/订阅： Redis支持发布/订阅模式，允许客户端订阅特定的频道并接收实时消息。 分布式： Redis可以通过分片或复制来构建分布式架构，提高可用性和扩展性。 Redis vs. MySQL 性能比较 读写性能： Redis在内存中存储数据，因此具有非常快速的读写性能，尤其适合高并发读取和写入场景。与此相比，MySQL可能受到磁盘IO和索引的影响，其读写性能相对较低。 数据结构： Redis支持多种数据结构，使其适合用于更复杂的数据模型，如实时计数、排行榜、分布式锁等。MySQL虽然也支持多种数据类型，但通常用于结构化数据的存储。 缓存： Redis非常适合用作缓存层，可以减轻数据库的负载，提高数据访问速度。MySQL也可以用作缓存，但Redis的读取速度更快。 事务和持久化： Redis支持事务，但它的事务模型不如MySQL严格。MySQL提供强大的事务支持和多种持久化选项。 适用领域和场景 Redis适合场景 实时数据：例如实时计数、统计信息和分析。 缓存：用作高速缓存，提高数据访问速度。 实时消息：发布/订阅模式用于实时消息传递。 会话存储：存储用户会话数据，适用于分布式系统。 分布式锁：实现分布式锁以协调多个系统的并发操作。 MySQL适合场景 结构化数据：适用于关系型、事务性的结构化数据。 复杂查询：支持复杂的查询和连接操作。 大规模数据存储：适合大规模数据存储和管理。 强大事务：需要强大的事务支持和ACID特性。 Redis和MySQL有各自独特的优势和用途，它们并不是直接替代关系。Redis可以在某些情况下用来增强项目性能，或者作为辅助数据库来存储特定类型的数据，例如缓存、会话、排行榜等。然而，对于需要复杂查询、关联性和事务的应用，Redis并不是MySQL的替代品。对于大部分应用，两者可以共同使用，以发挥各自的优势，构建更高效的系统。\nRedis基本命令 现在很多大公司的后端服务都是基础存储服务+Redis缓存的形式，使用Redis进行缓存很大程度上提高了服务的效率，当然也存在缓存穿透、缓存雪崩的问题，但是在此之前还是要从Redis的基础命令开始学习掌握，所以在这里整理了Redis常用的命令。\n字符串 在Redis中，字符串可以存储以下3中类型的值：字节串（byte string），整数，浮点数。\n自增自减命令 INCR key-name：将键存储的值加上1\nDECR key-name：将键存储的值减去1\nINCRBY key-name amount：将键存储的值加上整数amount\nDECRBY key-name amount：将键存储的值减去整数amount\nINCRBYFLOAT key-name amount：将键存储的值价上浮点数amount，版本2.6以上可用\n处理子串命令 APPEND key-name value：将value追加到key-name末尾\nGETRANGE key-name start end：获取一个从start到end（包括）的子串\nSETRANGE key-name offset value：将key-name的第offset位（从左到右，从0开始数）开始，设置成value\n二进制位命令 GETBIT key-name offset：获取偏移量为offset的二进制位的值\nSETBIT key-name offset value：将偏移量为offset的二进制位的值设置为value\nBITCOUNT key-name [start end]：统计二进制串中1的个数，范围可选\nBITOP operation dest-key key-name [key-name ...]，对key-name进行操作（operation可以为AND,OR,XOR,NOT）,将结果存储在dest-key中\n列表 常用命令 RPUSH key-name value [value ...]：将一个值或多个值推入列表右侧\nLPUSH key-name value [value ...]：将一个或多个值推入列表左侧\nRPOP key-name：从列表最右侧移除并返回一个元素\nLPOP key-name：从列表最左侧移除并返回一个元素\nLINDEX key-name offset：返回列表中偏移量为offset的元素\nLRANGE key-name start end：返回列表中从偏移量为start到end的元素，包括start和end\nLTRIM key-name start end：对列表进行修剪，只保留从偏移量为start到end范围内的元素，包括start和end\n集合 常用命令 SADD key-name item [item ...]：将一个元素或者多个元素添加到集合里面，并返回添加元素当中原本并不存在于集合里面的元素数量\nSREM key-name item [item ...]：从集合里面移除一个或者多个元素，并返回移除元素的数量\nSISMEMBER key-name item：检查元素item是否存在于集合key-name里\nSCARD key-name：返回集合中包含的元素数量\nSMEMBERS key-name：返回集合包含的所有元素\nSRANDMEMBER key-name [count]：随机返回一个或多个元素，当count为整数的时候，命令返回的随机元素不会重复，负数时则可能会出现重复\nSPOP key-name：随机地从集合中一出一个元素，并返回被移除的元素\nSMOVE source-key dest-key item：如果source-key中包含item，则从source-key中移除元素item，并添加到dest-key中。如果item被成功移除命令返回1，否则返回0\n散列 常用命令 HEXISTS key-name key：检查给定键是否存在于散列中\nHKEYS key-name：获取散列包含的所有键\nHVALS key-name：获取散列包含的所有值\nHGETALL key-name：获取散列包含的所有键值对\nHINCRBY key-name key increment：将键key存储的值加上整数increment\nHINCRBYFLOAT key-name key increment：将键key存储的值加上浮点数increment\n有序集合 常用命令 ZADD key-name score member [score member ...]：将带有给定分值的成员添加到有序集合里面\nZREM key-name member [member ....]：从有序集合里面移除给定成员，并返回被移除成员的数量\nZCARD key-name：返回有序集合包含的成员数量\nZINCRYBY key-name increment member：将member成员的分值加上increment\nZCOUNT key-name min max：返回分值介于min和max之间的成员数量\nZRANK key-name member：返回成员member在有序集合的排名\nZSCORE key-name member：返回成员member的分值\nZRANGE key-name start stop [WITHSCORES]：返回有序集合中排名介于start和stop之间的成员，如果给定年了可选的WITHSCORES选项，那么命令会将成员的分值一并返回\n有序集合的范围性数据 ZREVRANK key-namemember：返回有序集合里成员member的排名，成员按照分值 从大到小排列\nZREVRANGE key-name start stop[WITHSCORES]：返回有序集合给定排名范围内 的成员，成员按照分值从大到小排列\nZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]：返回 有序集合中，分值介于min和max之间的所有成员 获取有序集合中分值介于min和max之间的所有成员，并按照分值从大到小的顺序来返 回它们\nZREMRANGEBYRANK key-name start stop ：移除有序集合中排名介于start和stop 之间的所有成员\nZREMRANGEBYSCORE key-name min max：移除有序集合中分值介于min和max之间的所有成员\nZINTERSTORE dest-key key-count key [key ...] [WEIGHTS weight[weight ...]] [AGGREGATE SUMIMIN|MAX]：对给定的有序集合执行类似于集合的交集运算\nZUNIONSTORE dest-key key-count key [key ...] [WEIGHTS weight[weight ...]] [AGGREGATE SUM|MIN|MAX]：对给定的有序集合执行类似于集合的并集运算\n其他命令 排序 SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASCIDESC] [ALPHA] [STORE dest-key]：根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果\n处理过期时间 PERSIST key-name：移除键的过期时间\nTTLkey-name：查看给定键距离过期还有多少秒\nEXPIRE key-nameseconds：让给定键在指定的秒数之后过期\nEXPIREAT key-nametimestamp：将给定键的过期时间设置为给定的UNIX时间戳\nPTTLkey-name：查看给定键距离过期时间还有多少毫秒，这个命令在Redis2.6或以上版本可用\nPEXPIRE key-name milliseconds ：让给定键在指定的毫秒数之后过期，这个命令在Redis2.6 或以上版本可用\nPEXPIREAT key-name timestamp-milliseconds：将一个毫秒级精度的UNIX时间戳设置 为给定键的过期时间，这个命令在Redis2.6或以上版本可用\n","wordCount":"309","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-08-03T00:00:00Z","dateModified":"2023-08-03T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/database/use-redis/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Redis常用指令</h1><div class=post-meta><span title='2023-08-03 00:00:00 +0000 UTC'>August 3, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%bf%ab%e9%80%9f%e4%ba%86%e8%a7%a3redis aria-label=快速了解Redis>快速了解Redis</a><ul><li><a href=#redis%e6%98%af%e4%bb%80%e4%b9%88 aria-label=Redis是什么？>Redis是什么？</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8redis aria-label=为什么要使用Redis？>为什么要使用Redis？</a><ul><li><a href=#%e4%bc%98%e5%8a%bf aria-label=优势>优势</a></li><li><a href=#%e5%bc%8a%e7%ab%af aria-label=弊端>弊端</a></li></ul></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a8%a1%e5%9e%8b%e5%92%8c%e6%8a%80%e6%9c%af aria-label=基本模型和技术>基本模型和技术</a></li></ul></li><li><a href=#redis-vs-mysql aria-label="Redis vs. MySQL">Redis vs. MySQL</a><ul><li><a href=#%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83 aria-label=性能比较>性能比较</a></li><li><a href=#%e9%80%82%e7%94%a8%e9%a2%86%e5%9f%9f%e5%92%8c%e5%9c%ba%e6%99%af aria-label=适用领域和场景>适用领域和场景</a><ul><li><a href=#redis%e9%80%82%e5%90%88%e5%9c%ba%e6%99%af aria-label=Redis适合场景>Redis适合场景</a></li><li><a href=#mysql%e9%80%82%e5%90%88%e5%9c%ba%e6%99%af aria-label=MySQL适合场景>MySQL适合场景</a></li></ul></li></ul></li><li><a href=#redis%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4 aria-label=Redis基本命令>Redis基本命令</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a><ul><li><a href=#%e8%87%aa%e5%a2%9e%e8%87%aa%e5%87%8f%e5%91%bd%e4%bb%a4 aria-label=自增自减命令>自增自减命令</a></li><li><a href=#%e5%a4%84%e7%90%86%e5%ad%90%e4%b8%b2%e5%91%bd%e4%bb%a4 aria-label=处理子串命令>处理子串命令</a></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%bd%8d%e5%91%bd%e4%bb%a4 aria-label=二进制位命令>二进制位命令</a></li></ul></li><li><a href=#%e5%88%97%e8%a1%a8 aria-label=列表>列表</a><ul><li><a href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4 aria-label=常用命令>常用命令</a></li></ul></li><li><a href=#%e9%9b%86%e5%90%88 aria-label=集合>集合</a><ul><li><a href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-1 aria-label=常用命令>常用命令</a></li></ul></li><li><a href=#%e6%95%a3%e5%88%97 aria-label=散列>散列</a><ul><li><a href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-2 aria-label=常用命令>常用命令</a></li></ul></li><li><a href=#%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88 aria-label=有序集合>有序集合</a><ul><li><a href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-3 aria-label=常用命令>常用命令</a></li><li><a href=#%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88%e7%9a%84%e8%8c%83%e5%9b%b4%e6%80%a7%e6%95%b0%e6%8d%ae aria-label=有序集合的范围性数据>有序集合的范围性数据</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e5%91%bd%e4%bb%a4 aria-label=其他命令>其他命令</a><ul><li><a href=#%e6%8e%92%e5%ba%8f aria-label=排序>排序</a></li><li><a href=#%e5%a4%84%e7%90%86%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4 aria-label=处理过期时间>处理过期时间</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=快速了解redis>快速了解Redis<a hidden class=anchor aria-hidden=true href=#快速了解redis>#</a></h2><p>Redis是什么？为什么要使用Redis？他有什么好处和优势？他的弊端又有哪些呢？他的基本模型和技术有哪些？</p><h3 id=redis是什么>Redis是什么？<a hidden class=anchor aria-hidden=true href=#redis是什么>#</a></h3><p>Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以<strong>用作数据库、缓存和消息代理</strong>。它被设计用于快速访问、存储和分析数据，以及支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis支持持久化，可以将数据保存在磁盘上，以便在重启后恢复数据。</p><h3 id=为什么要使用redis>为什么要使用Redis？<a hidden class=anchor aria-hidden=true href=#为什么要使用redis>#</a></h3><p>Redis有许多优点，使其成为广泛使用的数据存储和缓存解决方案：</p><h4 id=优势>优势<a hidden class=anchor aria-hidden=true href=#优势>#</a></h4><ol><li><strong>快速访问：</strong> Redis数据存储在内存中，因此具有非常快速的读写性能，适合用作缓存层，加速数据访问。</li><li><strong>丰富的数据结构：</strong> Redis不仅支持简单的键值存储，还支持多种数据结构，如列表、集合、有序集合等，这使得它适用于更多不同类型的应用场景。</li><li><strong>持久化：</strong> Redis支持数据的持久化，可以将数据保存在磁盘上，以便在服务器重启后恢复数据。</li><li><strong>分布式架构：</strong> Redis支持分布式集群，可以将数据分散在多个节点上，提高数据的可用性和性能。</li><li><strong>发布/订阅：</strong> Redis具有消息代理功能，可以用于发布和订阅消息，支持实时数据推送和通知。</li><li><strong>事务支持：</strong> Redis支持事务，允许一系列操作以原子方式执行，保证数据的一致性。</li></ol><h4 id=弊端>弊端<a hidden class=anchor aria-hidden=true href=#弊端>#</a></h4><ol><li><strong>内存消耗：</strong> Redis的数据存储在内存中，因此对于大规模数据集可能会占用大量内存。尽管有持久化选项，但内存仍然是其主要的存储介质。</li><li><strong>单线程：</strong> Redis在单个进程中使用单线程处理所有的命令请求。这在某些高并发情况下可能成为性能瓶颈。</li></ol><h3 id=基本模型和技术>基本模型和技术<a hidden class=anchor aria-hidden=true href=#基本模型和技术>#</a></h3><ol><li><strong>键值存储：</strong> Redis的基本模型是键值存储，您可以使用键来检索存储在Redis中的数据。</li><li><strong>数据结构：</strong> Redis支持字符串、哈希表、列表、集合、有序集合等多种数据结构，使其非常灵活。</li><li><strong>持久化：</strong> Redis支持两种持久化方式，分别是快照（snapshotting）和日志（append-only file）。</li><li><strong>发布/订阅：</strong> Redis支持发布/订阅模式，允许客户端订阅特定的频道并接收实时消息。</li><li><strong>分布式：</strong> Redis可以通过分片或复制来构建分布式架构，提高可用性和扩展性。</li></ol><h2 id=redis-vs-mysql>Redis vs. MySQL<a hidden class=anchor aria-hidden=true href=#redis-vs-mysql>#</a></h2><h3 id=性能比较>性能比较<a hidden class=anchor aria-hidden=true href=#性能比较>#</a></h3><ol><li><strong>读写性能：</strong> Redis在内存中存储数据，因此具有非常快速的读写性能，尤其适合高并发读取和写入场景。与此相比，MySQL可能受到磁盘IO和索引的影响，其读写性能相对较低。</li><li><strong>数据结构：</strong> Redis支持多种数据结构，使其适合用于更复杂的数据模型，如实时计数、排行榜、分布式锁等。MySQL虽然也支持多种数据类型，但通常用于结构化数据的存储。</li><li><strong>缓存：</strong> Redis非常适合用作缓存层，可以减轻数据库的负载，提高数据访问速度。MySQL也可以用作缓存，但Redis的读取速度更快。</li><li><strong>事务和持久化：</strong> Redis支持事务，但它的事务模型不如MySQL严格。MySQL提供强大的事务支持和多种持久化选项。</li></ol><h3 id=适用领域和场景>适用领域和场景<a hidden class=anchor aria-hidden=true href=#适用领域和场景>#</a></h3><h4 id=redis适合场景>Redis适合场景<a hidden class=anchor aria-hidden=true href=#redis适合场景>#</a></h4><ul><li>实时数据：例如实时计数、统计信息和分析。</li><li>缓存：用作高速缓存，提高数据访问速度。</li><li>实时消息：发布/订阅模式用于实时消息传递。</li><li>会话存储：存储用户会话数据，适用于分布式系统。</li><li>分布式锁：实现分布式锁以协调多个系统的并发操作。</li></ul><h4 id=mysql适合场景>MySQL适合场景<a hidden class=anchor aria-hidden=true href=#mysql适合场景>#</a></h4><ul><li>结构化数据：适用于关系型、事务性的结构化数据。</li><li>复杂查询：支持复杂的查询和连接操作。</li><li>大规模数据存储：适合大规模数据存储和管理。</li><li>强大事务：需要强大的事务支持和ACID特性。</li></ul><p>Redis和MySQL有各自独特的优势和用途，它们并不是直接替代关系。Redis可以在某些情况下用来增强项目性能，或者作为辅助数据库来存储特定类型的数据，例如缓存、会话、排行榜等。然而，对于需要复杂查询、关联性和事务的应用，Redis并不是MySQL的替代品。对于大部分应用，两者可以共同使用，以发挥各自的优势，构建更高效的系统。</p><h2 id=redis基本命令>Redis基本命令<a hidden class=anchor aria-hidden=true href=#redis基本命令>#</a></h2><p>现在很多大公司的后端服务都是基础存储服务+Redis缓存的形式，使用Redis进行缓存很大程度上提高了服务的效率，当然也存在缓存穿透、缓存雪崩的问题，但是在此之前还是要从Redis的基础命令开始学习掌握，所以在这里整理了Redis常用的命令。</p><h3 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h3><p>在Redis中，字符串可以存储以下3中类型的值：字节串（byte string），整数，浮点数。</p><h4 id=自增自减命令>自增自减命令<a hidden class=anchor aria-hidden=true href=#自增自减命令>#</a></h4><p><code>INCR key-name</code>：将键存储的值加上1</p><p><code>DECR key-name</code>：将键存储的值减去1</p><p><code>INCRBY key-name amount</code>：将键存储的值加上整数amount</p><p><code>DECRBY key-name amount</code>：将键存储的值减去整数amount</p><p><code>INCRBYFLOAT key-name amount</code>：将键存储的值价上浮点数amount，版本2.6以上可用</p><h4 id=处理子串命令>处理子串命令<a hidden class=anchor aria-hidden=true href=#处理子串命令>#</a></h4><p><code>APPEND key-name value</code>：将value追加到key-name末尾</p><p><code>GETRANGE key-name start end</code>：获取一个从start到end（包括）的子串</p><p><code>SETRANGE key-name offset value</code>：将key-name的第offset位（从左到右，从0开始数）开始，设置成value</p><h4 id=二进制位命令>二进制位命令<a hidden class=anchor aria-hidden=true href=#二进制位命令>#</a></h4><p><code>GETBIT key-name offset</code>：获取偏移量为offset的二进制位的值</p><p><code>SETBIT key-name offset value</code>：将偏移量为offset的二进制位的值设置为value</p><p><code>BITCOUNT key-name [start end]</code>：统计二进制串中1的个数，范围可选</p><p><code>BITOP operation dest-key key-name [key-name ...]</code>，对key-name进行操作（operation可以为AND,OR,XOR,NOT）,将结果存储在dest-key中</p><h3 id=列表>列表<a hidden class=anchor aria-hidden=true href=#列表>#</a></h3><h4 id=常用命令>常用命令<a hidden class=anchor aria-hidden=true href=#常用命令>#</a></h4><p><code>RPUSH key-name value [value ...]</code>：将一个值或多个值推入列表右侧</p><p><code>LPUSH key-name value [value ...]</code>：将一个或多个值推入列表左侧</p><p><code>RPOP key-name</code>：从列表最右侧移除并返回一个元素</p><p><code>LPOP key-name</code>：从列表最左侧移除并返回一个元素</p><p><code>LINDEX key-name offset</code>：返回列表中偏移量为offset的元素</p><p><code>LRANGE key-name start end</code>：返回列表中从偏移量为start到end的元素，包括start和end</p><p><code>LTRIM key-name start end</code>：对列表进行修剪，只保留从偏移量为start到end范围内的元素，包括start和end</p><h3 id=集合>集合<a hidden class=anchor aria-hidden=true href=#集合>#</a></h3><h4 id=常用命令-1>常用命令<a hidden class=anchor aria-hidden=true href=#常用命令-1>#</a></h4><p><code>SADD key-name item [item ...]</code>：将一个元素或者多个元素添加到集合里面，并返回添加元素当中原本并不存在于集合里面的元素数量</p><p><code>SREM key-name item [item ...]</code>：从集合里面移除一个或者多个元素，并返回移除元素的数量</p><p><code>SISMEMBER key-name item</code>：检查元素item是否存在于集合key-name里</p><p><code>SCARD key-name</code>：返回集合中包含的元素数量</p><p><code>SMEMBERS key-name</code>：返回集合包含的所有元素</p><p><code>SRANDMEMBER key-name [count]</code>：随机返回一个或多个元素，当count为整数的时候，命令返回的随机元素不会重复，负数时则可能会出现重复</p><p><code>SPOP key-name</code>：随机地从集合中一出一个元素，并返回被移除的元素</p><p><code>SMOVE source-key dest-key item</code>：如果source-key中包含item，则从source-key中移除元素item，并添加到dest-key中。如果item被成功移除命令返回1，否则返回0</p><h3 id=散列>散列<a hidden class=anchor aria-hidden=true href=#散列>#</a></h3><h4 id=常用命令-2>常用命令<a hidden class=anchor aria-hidden=true href=#常用命令-2>#</a></h4><p><code>HEXISTS key-name key</code>：检查给定键是否存在于散列中</p><p><code>HKEYS key-name</code>：获取散列包含的所有键</p><p><code>HVALS key-name</code>：获取散列包含的所有值</p><p><code>HGETALL key-name</code>：获取散列包含的所有键值对</p><p><code>HINCRBY key-name key increment</code>：将键key存储的值加上整数increment</p><p><code>HINCRBYFLOAT key-name key increment</code>：将键key存储的值加上浮点数increment</p><h3 id=有序集合>有序集合<a hidden class=anchor aria-hidden=true href=#有序集合>#</a></h3><h4 id=常用命令-3>常用命令<a hidden class=anchor aria-hidden=true href=#常用命令-3>#</a></h4><p><code>ZADD key-name score member [score member ...]</code>：将带有给定分值的成员添加到有序集合里面</p><p><code>ZREM key-name member [member ....]</code>：从有序集合里面移除给定成员，并返回被移除成员的数量</p><p><code>ZCARD key-name</code>：返回有序集合包含的成员数量</p><p><code>ZINCRYBY key-name increment member</code>：将member成员的分值加上increment</p><p><code>ZCOUNT key-name min max</code>：返回分值介于min和max之间的成员数量</p><p><code>ZRANK key-name member</code>：返回成员member在有序集合的排名</p><p><code>ZSCORE key-name member</code>：返回成员member的分值</p><p><code>ZRANGE key-name start stop [WITHSCORES]</code>：返回有序集合中排名介于start和stop之间的成员，如果给定年了可选的WITHSCORES选项，那么命令会将成员的分值一并返回</p><h4 id=有序集合的范围性数据>有序集合的范围性数据<a hidden class=anchor aria-hidden=true href=#有序集合的范围性数据>#</a></h4><p><code>ZREVRANK key-namemember</code>：返回有序集合里成员member的排名，成员按照分值 从大到小排列</p><p><code>ZREVRANGE key-name start stop[WITHSCORES]</code>：返回有序集合给定排名范围内 的成员，成员按照分值从大到小排列</p><p><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code>：返回 有序集合中，分值介于min和max之间的所有成员 获取有序集合中分值介于min和max之间的所有成员，并按照分值从大到小的顺序来返 回它们</p><p><code>ZREMRANGEBYRANK key-name start stop</code> ：移除有序集合中排名介于start和stop 之间的所有成员</p><p><code>ZREMRANGEBYSCORE key-name min max</code>：移除有序集合中分值介于min和max之间的所有成员</p><p><code>ZINTERSTORE dest-key key-count key [key ...] [WEIGHTS weight[weight ...]] [AGGREGATE SUMIMIN|MAX]</code>：对给定的有序集合执行类似于集合的交集运算</p><p><code>ZUNIONSTORE dest-key key-count key [key ...] [WEIGHTS weight[weight ...]] [AGGREGATE SUM|MIN|MAX]</code>：对给定的有序集合执行类似于集合的并集运算</p><h3 id=其他命令>其他命令<a hidden class=anchor aria-hidden=true href=#其他命令>#</a></h3><h4 id=排序>排序<a hidden class=anchor aria-hidden=true href=#排序>#</a></h4><p><code>SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASCIDESC] [ALPHA] [STORE dest-key]</code>：根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果</p><h4 id=处理过期时间>处理过期时间<a hidden class=anchor aria-hidden=true href=#处理过期时间>#</a></h4><p><code>PERSIST key-name</code>：移除键的过期时间</p><p><code>TTLkey-name</code>：查看给定键距离过期还有多少秒</p><p><code>EXPIRE key-nameseconds</code>：让给定键在指定的秒数之后过期</p><p><code>EXPIREAT key-nametimestamp</code>：将给定键的过期时间设置为给定的UNIX时间戳</p><p><code>PTTLkey-name</code>：查看给定键距离过期时间还有多少毫秒，这个命令在Redis2.6或以上版本可用</p><p><code>PEXPIRE key-name milliseconds</code> ：让给定键在指定的毫秒数之后过期，这个命令在Redis2.6 或以上版本可用</p><p><code>PEXPIREAT key-name timestamp-milliseconds</code>：将一个毫秒级精度的UNIX时间戳设置 为给定键的过期时间，这个命令在Redis2.6或以上版本可用</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/redis/>Redis</a></li><li><a href=https://sirius1y.top/tags/database/>Database</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/basic/objectstore/><span class=title>« Prev</span><br><span>关于对象存储</span>
</a><a class=next href=https://sirius1y.top/posts/notes/problems/pycharm-not-found-packages/><span class=title>Next »</span><br><span>pycharm中找不到包的问题</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>