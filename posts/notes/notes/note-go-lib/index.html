<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go log库，encoding/json | Sirius' Blog</title>
<meta name=keywords content="json,log"><meta name=description content="log Go语言内置的log包实现了简单的日志服务。本文介绍了标准库log的基本使用。
Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如logrus、zap等。
使用Logger log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。
例如，我们可以像下面的代码一样直接通过log包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：
package main import ( &amp;quot;log&amp;quot; ) func main() { log.Println(&amp;quot;这是一条很普通的日志。&amp;quot;) v := &amp;quot;很普通的&amp;quot; log.Printf(&amp;quot;这是一条%s日志。\n&amp;quot;, v) log.Fatalln(&amp;quot;这是一条会触发fatal的日志。&amp;quot;) log.Panicln(&amp;quot;这是一条会触发panic的日志。&amp;quot;) } 编译并执行上面的代码会得到如下输出：
2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条会触发fatal的日志。 logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。
配置logger 标准logger的配置 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法。
log标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置。
func Flags() int func SetFlags(flag int) flag选项 log标准库提供了如下的flag选项，它们是一系列定义好的常量。
const ( // 控制输出日志信息的细节，不能控制输出的顺序和格式。 // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 << iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒级别的时间：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d."><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/notes/note-go-lib/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/notes/note-go-lib/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go log库，encoding/json"><meta property="og:description" content="log Go语言内置的log包实现了简单的日志服务。本文介绍了标准库log的基本使用。
Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如logrus、zap等。
使用Logger log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。
例如，我们可以像下面的代码一样直接通过log包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：
package main import ( &amp;quot;log&amp;quot; ) func main() { log.Println(&amp;quot;这是一条很普通的日志。&amp;quot;) v := &amp;quot;很普通的&amp;quot; log.Printf(&amp;quot;这是一条%s日志。\n&amp;quot;, v) log.Fatalln(&amp;quot;这是一条会触发fatal的日志。&amp;quot;) log.Panicln(&amp;quot;这是一条会触发panic的日志。&amp;quot;) } 编译并执行上面的代码会得到如下输出：
2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条会触发fatal的日志。 logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。
配置logger 标准logger的配置 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法。
log标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置。
func Flags() int func SetFlags(flag int) flag选项 log标准库提供了如下的flag选项，它们是一系列定义好的常量。
const ( // 控制输出日志信息的细节，不能控制输出的顺序和格式。 // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 << iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒级别的时间：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d."><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/notes/note-go-lib/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-22T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Go log库，encoding/json"><meta name=twitter:description content="log Go语言内置的log包实现了简单的日志服务。本文介绍了标准库log的基本使用。
Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如logrus、zap等。
使用Logger log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。
例如，我们可以像下面的代码一样直接通过log包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：
package main import ( &amp;quot;log&amp;quot; ) func main() { log.Println(&amp;quot;这是一条很普通的日志。&amp;quot;) v := &amp;quot;很普通的&amp;quot; log.Printf(&amp;quot;这是一条%s日志。\n&amp;quot;, v) log.Fatalln(&amp;quot;这是一条会触发fatal的日志。&amp;quot;) log.Panicln(&amp;quot;这是一条会触发panic的日志。&amp;quot;) } 编译并执行上面的代码会得到如下输出：
2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条会触发fatal的日志。 logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。
配置logger 标准logger的配置 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法。
log标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置。
func Flags() int func SetFlags(flag int) flag选项 log标准库提供了如下的flag选项，它们是一系列定义好的常量。
const ( // 控制输出日志信息的细节，不能控制输出的顺序和格式。 // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 << iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒级别的时间：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"Go log库，encoding/json","item":"https://sirius1y.top/posts/notes/notes/note-go-lib/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go log库，encoding/json","name":"Go log库，encoding\/json","description":"log Go语言内置的log包实现了简单的日志服务。本文介绍了标准库log的基本使用。\nGo内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如logrus、zap等。\n使用Logger log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。\n例如，我们可以像下面的代码一样直接通过log包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：\npackage main import ( \u0026amp;quot;log\u0026amp;quot; ) func main() { log.Println(\u0026amp;quot;这是一条很普通的日志。\u0026amp;quot;) v := \u0026amp;quot;很普通的\u0026amp;quot; log.Printf(\u0026amp;quot;这是一条%s日志。\\n\u0026amp;quot;, v) log.Fatalln(\u0026amp;quot;这是一条会触发fatal的日志。\u0026amp;quot;) log.Panicln(\u0026amp;quot;这是一条会触发panic的日志。\u0026amp;quot;) } 编译并执行上面的代码会得到如下输出：\n2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条会触发fatal的日志。 logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。\n配置logger 标准logger的配置 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法。\nlog标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置。\nfunc Flags() int func SetFlags(flag int) flag选项 log标准库提供了如下的flag选项，它们是一系列定义好的常量。\nconst ( // 控制输出日志信息的细节，不能控制输出的顺序和格式。 // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 \u0026lt;\u0026lt; iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒级别的时间：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d.","keywords":["json","log"],"articleBody":"log Go语言内置的log包实现了简单的日志服务。本文介绍了标准库log的基本使用。\nGo内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如logrus、zap等。\n使用Logger log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。\n例如，我们可以像下面的代码一样直接通过log包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：\npackage main import ( \u0026quot;log\u0026quot; ) func main() { log.Println(\u0026quot;这是一条很普通的日志。\u0026quot;) v := \u0026quot;很普通的\u0026quot; log.Printf(\u0026quot;这是一条%s日志。\\n\u0026quot;, v) log.Fatalln(\u0026quot;这是一条会触发fatal的日志。\u0026quot;) log.Panicln(\u0026quot;这是一条会触发panic的日志。\u0026quot;) } 编译并执行上面的代码会得到如下输出：\n2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条很普通的日志。 2017/06/19 14:04:17 这是一条会触发fatal的日志。 logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。\n配置logger 标准logger的配置 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法。\nlog标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置。\nfunc Flags() int func SetFlags(flag int) flag选项 log标准库提供了如下的flag选项，它们是一系列定义好的常量。\nconst ( // 控制输出日志信息的细节，不能控制输出的顺序和格式。 // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 \u003c\u003c iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒级别的时间：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d.go:23 Lshortfile // 文件名+行号：d.go:23（会覆盖掉Llongfile） LUTC // 使用UTC时间 LstdFlags = Ldate | Ltime // 标准logger的初始值 ) 下面我们在记录日志之前先设置一下标准logger的输出选项如下：\nfunc main() { log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(\u0026quot;这是一条很普通的日志。\u0026quot;) } 编译执行后得到的输出结果如下：\n2017/06/19 14:05:17.494943 .../log_demo/main.go:11: 这是一条很普通的日志。 配置日志前缀 log标准库中还提供了关于日志信息前缀的两个方法：\nfunc Prefix() string func SetPrefix(prefix string) 其中Prefix函数用来查看标准logger的输出前缀，SetPrefix函数用来设置输出前缀。\nfunc main() { log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(\u0026quot;这是一条很普通的日志。\u0026quot;) log.SetPrefix(\u0026quot;[小王子]\u0026quot;) log.Println(\u0026quot;这是一条很普通的日志。\u0026quot;) } 上面的代码输出如下：\n[小王子]2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。 这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。\n配置日志输出位置 func SetOutput(w io.Writer) SetOutput函数用来设置标准logger的输出目的地，默认是标准错误输出。\n例如，下面的代码会把日志输出到同目录下的xx.log文件中。\nfunc main() { logFile, err := os.OpenFile(\u0026quot;./xx.log\u0026quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\u0026quot;open log file failed, err:\u0026quot;, err) return } log.SetOutput(logFile) log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(\u0026quot;这是一条很普通的日志。\u0026quot;) log.SetPrefix(\u0026quot;[小王子]\u0026quot;) log.Println(\u0026quot;这是一条很普通的日志。\u0026quot;) } 如果你要使用标准的logger，我们通常会把上面的配置操作写到init函数中。\nfunc init() { logFile, err := os.OpenFile(\u0026quot;./xx.log\u0026quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\u0026quot;open log file failed, err:\u0026quot;, err) return } log.SetOutput(logFile) log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) } 创建logger log标准库中还提供了一个创建新logger对象的构造函数–New，支持我们创建自己的logger示例。New函数的签名如下：\nfunc New(out io.Writer, prefix string, flag int) *Logger New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。\n举个例子：\nfunc main() { logger := log.New(os.Stdout, \u0026quot;\u003cNew\u003e\u0026quot;, log.Lshortfile|log.Ldate|log.Ltime) logger.Println(\u0026quot;这是自定义的logger记录的日志。\u0026quot;) } 将上面的代码编译执行之后，得到结果如下：\n2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。 encoding/json json.Marshal json.Marshal 用于将Go的结构体或其他数据类型序列化为JSON格式的字节数组。如果序列化成功，它返回JSON格式的字节切片和nil作为错误值。如果序列化失败，它返回错误。\nbytes_slice, err := json.Marshal(a_struct) if err != nil { log.Fatalf(\"JSON marshaling failed: %s\", err) } json.MarshalIndent json.MarshalIndent 类似于 json.Marshal，但它会产生格式化的JSON，使输出更易读。它接受额外的参数来控制缩进。第一个参数是要序列化的数据，第二个参数是每行输出的前缀字符串，第三个参数是每个层级的缩进字符串。\nbytes_slice, err := json.MarshalIndent(a_struct, \"\", \" \") if err != nil { log.Fatalf(\"JSON marshaling failed: %s\", err) } json.Unmarshal json.Unmarshal 用于将JSON字节切片反序列化为Go的数据结构。它接受一个JSON字节切片和一个指向要填充的数据结构的指针。\nerr := json.Unmarshal(bytes_slice, \u0026a_struct) if err != nil { log.Fatalf(\"JSON unmarshaling failed: %s\", err) } json.Encode json.Encode 用于直接将Go的数据结构序列化为JSON格式并写入io.Writer接口（如文件、网络连接等）。这个函数是流式的，适用于将数据直接输出到HTTP响应体或文件中。\nencoder := json.NewEncoder(outputWriter) err := encoder.Encode(a_struct) if err != nil { log.Fatalf(\"JSON encoding failed: %s\", err) } json.Decode json.Decode 用于直接从io.Reader接口（如文件、网络连接等）读取并反序列化JSON数据到Go的数据结构。这个函数是流式的，适用于从HTTP请求体或文件中读取数据。\ndecoder := json.NewDecoder(inputReader) err := decoder.Decode(\u0026a_struct) if err != nil { log.Fatalf(\"JSON decoding failed: %s\", err) } 在这些函数中，json.Marshal 和 json.MarshalIndent 用于将Go数据结构转换为JSON格式的字节切片，而json.Unmarshal 用于将JSON字节切片转换回Go数据结构。json.Encode 和 json.Decode 则提供了一种流式的方式来直接序列化和反序列化JSON数据。\n","wordCount":"332","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-06-22T00:00:00Z","dateModified":"2023-06-22T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/notes/note-go-lib/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go log库，encoding/json</h1><div class=post-meta><span title='2023-06-22 00:00:00 +0000 UTC'>June 22, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;332 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#log aria-label=log>log</a><ul><li><a href=#%e4%bd%bf%e7%94%a8logger aria-label=使用Logger>使用Logger</a></li><li><a href=#%e9%85%8d%e7%bd%aelogger aria-label=配置logger>配置logger</a><ul><li><a href=#%e6%a0%87%e5%87%86logger%e7%9a%84%e9%85%8d%e7%bd%ae aria-label=标准logger的配置>标准logger的配置</a></li><li><a href=#flag%e9%80%89%e9%a1%b9 aria-label=flag选项>flag选项</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e6%97%a5%e5%bf%97%e5%89%8d%e7%bc%80 aria-label=配置日志前缀>配置日志前缀</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e6%97%a5%e5%bf%97%e8%be%93%e5%87%ba%e4%bd%8d%e7%bd%ae aria-label=配置日志输出位置>配置日志输出位置</a></li></ul></li><li><a href=#%e5%88%9b%e5%bb%balogger aria-label=创建logger>创建logger</a></li></ul></li><li><a href=#encodingjson aria-label=encoding/json>encoding/json</a><ul><li><a href=#jsonmarshal aria-label=json.Marshal>json.Marshal</a></li><li><a href=#jsonmarshalindent aria-label=json.MarshalIndent>json.MarshalIndent</a></li><li><a href=#jsonunmarshal aria-label=json.Unmarshal>json.Unmarshal</a></li><li><a href=#jsonencode aria-label=json.Encode>json.Encode</a></li><li><a href=#jsondecode aria-label=json.Decode>json.Decode</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=log>log<a hidden class=anchor aria-hidden=true href=#log>#</a></h1><p>Go语言内置的<code>log</code>包实现了简单的日志服务。本文介绍了标准库<code>log</code>的基本使用。</p><p>Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如logrus、zap等。</p><h2 id=使用logger>使用Logger<a hidden class=anchor aria-hidden=true href=#使用logger>#</a></h2><p>log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数<code>Print系列</code>(Print|Printf|Println）、<code>Fatal系列</code>（Fatal|Fatalf|Fatalln）、和<code>Panic系列</code>（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。</p><p>例如，我们可以像下面的代码一样直接通过<code>log</code>包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>log</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条很普通的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl>	<span class=nx>v</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>很普通的</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条</span><span class=o>%</span><span class=nx>s日志</span><span class=err>。\</span><span class=nx>n</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalln</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条会触发fatal的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Panicln</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条会触发panic的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>编译并执行上面的代码会得到如下输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>2017/06/19 14:04:17 这是一条很普通的日志。
</span></span><span class=line><span class=cl>2017/06/19 14:04:17 这是一条很普通的日志。
</span></span><span class=line><span class=cl>2017/06/19 14:04:17 这是一条会触发fatal的日志。
</span></span></code></pre></div><p>logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。</p><h2 id=配置logger>配置logger<a hidden class=anchor aria-hidden=true href=#配置logger>#</a></h2><h3 id=标准logger的配置>标准logger的配置<a hidden class=anchor aria-hidden=true href=#标准logger的配置>#</a></h3><p>默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。<code>log</code>标准库中为我们提供了定制这些设置的方法。</p><p><code>log</code>标准库中的<code>Flags</code>函数会返回标准logger的输出配置，而<code>SetFlags</code>函数用来设置标准logger的输出配置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Flags</span><span class=p>()</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>SetFlags</span><span class=p>(</span><span class=nx>flag</span> <span class=kt>int</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=flag选项>flag选项<a hidden class=anchor aria-hidden=true href=#flag选项>#</a></h3><p><code>log</code>标准库提供了如下的flag选项，它们是一系列定义好的常量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 控制输出日志信息的细节，不能控制输出的顺序和格式。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Ldate</span>         <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=kc>iota</span>     <span class=c1>// 日期：2009/01/23
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Ltime</span>                         <span class=c1>// 时间：01:23:23
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Lmicroseconds</span>                 <span class=c1>// 微秒级别的时间：01:23:23.123123（用于增强Ltime位）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Llongfile</span>                     <span class=c1>// 文件全路径名+行号： /a/b/c/d.go:23
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Lshortfile</span>                    <span class=c1>// 文件名+行号：d.go:23（会覆盖掉Llongfile）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>LUTC</span>                          <span class=c1>// 使用UTC时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>LstdFlags</span>     <span class=p>=</span> <span class=nx>Ldate</span> <span class=p>|</span> <span class=nx>Ltime</span> <span class=c1>// 标准logger的初始值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></div><p>下面我们在记录日志之前先设置一下标准logger的输出选项如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetFlags</span><span class=p>(</span><span class=nx>log</span><span class=p>.</span><span class=nx>Llongfile</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Lmicroseconds</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Ldate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条很普通的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>编译执行后得到的输出结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=mi>2017</span><span class=o>/</span><span class=mo>06</span><span class=o>/</span><span class=mi>19</span> <span class=mi>14</span><span class=p>:</span><span class=mo>05</span><span class=p>:</span><span class=mf>17.494943</span> <span class=o>.../</span><span class=nx>log_demo</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span> <span class=nx>这是一条很普通的日志</span><span class=err>。</span>
</span></span></code></pre></div><h3 id=配置日志前缀>配置日志前缀<a hidden class=anchor aria-hidden=true href=#配置日志前缀>#</a></h3><p><code>log</code>标准库中还提供了关于日志信息前缀的两个方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Prefix</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>SetPrefix</span><span class=p>(</span><span class=nx>prefix</span> <span class=kt>string</span><span class=p>)</span>
</span></span></code></pre></div><p>其中<code>Prefix</code>函数用来查看标准logger的输出前缀，<code>SetPrefix</code>函数用来设置输出前缀。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetFlags</span><span class=p>(</span><span class=nx>log</span><span class=p>.</span><span class=nx>Llongfile</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Lmicroseconds</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Ldate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条很普通的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetPrefix</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;[</span><span class=nx>小王子</span><span class=p>]</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条很普通的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的代码输出如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>小王子<span class=o>]</span>2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。
</span></span></code></pre></div><p>这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。</p><h3 id=配置日志输出位置>配置日志输出位置<a hidden class=anchor aria-hidden=true href=#配置日志输出位置>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>SetOutput</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span>
</span></span></code></pre></div><p><code>SetOutput</code>函数用来设置标准logger的输出目的地，默认是标准错误输出。</p><p>例如，下面的代码会把日志输出到同目录下的<code>xx.log</code>文件中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>logFile</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>OpenFile</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;.</span><span class=o>/</span><span class=nx>xx</span><span class=p>.</span><span class=nx>log</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;,</span> <span class=nx>os</span><span class=p>.</span><span class=nx>O_CREATE</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span><span class=nx>O_WRONLY</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span><span class=nx>O_APPEND</span><span class=p>,</span> <span class=mo>0644</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>open</span> <span class=nx>log</span> <span class=nx>file</span> <span class=nx>failed</span><span class=p>,</span> <span class=nx>err</span><span class=p>:</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetOutput</span><span class=p>(</span><span class=nx>logFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetFlags</span><span class=p>(</span><span class=nx>log</span><span class=p>.</span><span class=nx>Llongfile</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Lmicroseconds</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Ldate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条很普通的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetPrefix</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;[</span><span class=nx>小王子</span><span class=p>]</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是一条很普通的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果你要使用标准的logger，我们通常会把上面的配置操作写到<code>init</code>函数中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>logFile</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>OpenFile</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;.</span><span class=o>/</span><span class=nx>xx</span><span class=p>.</span><span class=nx>log</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;,</span> <span class=nx>os</span><span class=p>.</span><span class=nx>O_CREATE</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span><span class=nx>O_WRONLY</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span><span class=nx>O_APPEND</span><span class=p>,</span> <span class=mo>0644</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>open</span> <span class=nx>log</span> <span class=nx>file</span> <span class=nx>failed</span><span class=p>,</span> <span class=nx>err</span><span class=p>:</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetOutput</span><span class=p>(</span><span class=nx>logFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetFlags</span><span class=p>(</span><span class=nx>log</span><span class=p>.</span><span class=nx>Llongfile</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Lmicroseconds</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Ldate</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=创建logger>创建logger<a hidden class=anchor aria-hidden=true href=#创建logger>#</a></h2><p><code>log</code>标准库中还提供了一个创建新logger对象的构造函数–<code>New</code>，支持我们创建自己的logger示例。<code>New</code>函数的签名如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>New</span><span class=p>(</span><span class=nx>out</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>prefix</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>flag</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Logger</span>
</span></span></code></pre></div><p>New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。</p><p>举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>logger</span> <span class=o>:=</span> <span class=nx>log</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>quot</span><span class=p>;&lt;</span><span class=nx>New</span><span class=p>&gt;</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;,</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Lshortfile</span><span class=p>|</span><span class=nx>log</span><span class=p>.</span><span class=nx>Ldate</span><span class=p>|</span><span class=nx>log</span><span class=p>.</span><span class=nx>Ltime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>logger</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;</span><span class=nx>这是自定义的logger记录的日志</span><span class=err>。</span><span class=o>&amp;</span><span class=nx>quot</span><span class=p>;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>将上面的代码编译执行之后，得到结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&lt;New&gt;2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。
</span></span></code></pre></div><h1 id=encodingjson>encoding/json<a hidden class=anchor aria-hidden=true href=#encodingjson>#</a></h1><h2 id=jsonmarshal>json.Marshal<a hidden class=anchor aria-hidden=true href=#jsonmarshal>#</a></h2><p><code>json.Marshal</code> 用于将Go的结构体或其他数据类型序列化为JSON格式的字节数组。如果序列化成功，它返回JSON格式的字节切片和<code>nil</code>作为错误值。如果序列化失败，它返回错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>bytes_slice</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>a_struct</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;JSON marshaling failed: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=jsonmarshalindent>json.MarshalIndent<a hidden class=anchor aria-hidden=true href=#jsonmarshalindent>#</a></h2><p><code>json.MarshalIndent</code> 类似于 <code>json.Marshal</code>，但它会产生格式化的JSON，使输出更易读。它接受额外的参数来控制缩进。第一个参数是要序列化的数据，第二个参数是每行输出的前缀字符串，第三个参数是每个层级的缩进字符串。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>bytes_slice</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>MarshalIndent</span><span class=p>(</span><span class=nx>a_struct</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=s>&#34;    &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;JSON marshaling failed: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=jsonunmarshal>json.Unmarshal<a hidden class=anchor aria-hidden=true href=#jsonunmarshal>#</a></h2><p><code>json.Unmarshal</code> 用于将JSON字节切片反序列化为Go的数据结构。它接受一个JSON字节切片和一个指向要填充的数据结构的指针。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>bytes_slice</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>a_struct</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;JSON unmarshaling failed: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=jsonencode>json.Encode<a hidden class=anchor aria-hidden=true href=#jsonencode>#</a></h2><p><code>json.Encode</code> 用于直接将Go的数据结构序列化为JSON格式并写入<code>io.Writer</code>接口（如文件、网络连接等）。这个函数是流式的，适用于将数据直接输出到HTTP响应体或文件中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>encoder</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=nx>outputWriter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>encoder</span><span class=p>.</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>a_struct</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;JSON encoding failed: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=jsondecode>json.Decode<a hidden class=anchor aria-hidden=true href=#jsondecode>#</a></h2><p><code>json.Decode</code> 用于直接从<code>io.Reader</code>接口（如文件、网络连接等）读取并反序列化JSON数据到Go的数据结构。这个函数是流式的，适用于从HTTP请求体或文件中读取数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>decoder</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>inputReader</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>decoder</span><span class=p>.</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>a_struct</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;JSON decoding failed: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这些函数中，<code>json.Marshal</code> 和 <code>json.MarshalIndent</code> 用于将Go数据结构转换为JSON格式的字节切片，而<code>json.Unmarshal</code> 用于将JSON字节切片转换回Go数据结构。<code>json.Encode</code> 和 <code>json.Decode</code> 则提供了一种流式的方式来直接序列化和反序列化JSON数据。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/json/>Json</a></li><li><a href=https://sirius1y.top/tags/log/>Log</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/problems/ping-github.com/><span class=title>« Prev</span><br><span>ping github.com</span>
</a><a class=next href=https://sirius1y.top/posts/notes/notes/note-go/><span class=title>Next »</span><br><span>Go学习笔记</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>