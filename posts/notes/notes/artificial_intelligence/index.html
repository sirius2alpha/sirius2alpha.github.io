<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>人工智能期末复习 | Sirius' Blog</title>
<meta name=keywords content="AI"><meta name=description content="基本概念 语义角色 指有关语言成分在语句所表达的事件中所扮演的参与者角色
在自然语言处理中对自然语言进行划分处理称为各个语义角色，其中每个语义角色相互依赖，相互关联
常见的语义角色类型有：施事、受事、与事、工具、方式、时间、处所、结果、目的、原因等 例如对于语句：小明昨天晚上在公园遇到了小红
就可以分为Agent、Time、Location、Predicate、Patient等角色
语义角色从一开始的6个扩充到了现在的13个，依据是美国语言学家查理斯·费尔莫尔提出的“格语法”
机器学习 让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力 启发函数&估值函数 启发函数：对当前结点到大目标结点未来可能需要付出的代价的估计
对于同一个问题，可能有不同的启发函数，不同的启发函数带来的效果良莠不齐，而各个节点的代价函数是统一确定的，因此选择和优化启发函数是至关重要的
估值函数：为了防止在单独利用启发函数的时候误入歧途，会将启发函数和代价函数结合生成估值函数；即初始结点到达结点x处已经付出的代价与结点x到达目标结点的接近程度估计值的总和
语义标注 在NLP领域中对于自然语言进行分割，并且对每个部分都判断是什么类型的语义角色
语义角色标注是一种浅层的语义分析技术，它只标注谓词（谓语动词、名词、形容词）的语义角色
例如：
昨天张三在家吃苹果。
谓语动词“吃”的语义角色有：施事-张三，受事-苹果，时间-昨天，处所-家
博弈树 将双人完备的信息博弈过程用图表示出来，能得到一颗与或树，称为博弈树
在博弈树中，下一步该MAX走步的结点称为MAX结点；下一步该MIN走步的结点称为MIN结点 博弈树特点： 初始状态为初始结点 博弈树中的或结点和与结点是逐层交替出现的 整个博弈过程都是站在某一方的立场上，所有能使自己获胜的都是本源问题，相应的结点都是可解结点；所有会使对方获胜的结点都是不可解结点 博弈树采用变对子结点进行估值函数计算，再扩展结点的方法，使用的是极大极小化分析，因此引申出了阿尔法-贝塔剪枝
阿尔法-贝塔剪枝： 阿尔法剪枝： 对于一个MIN结点，如果能够推导出其上确界b，并且b不大于MIN结点的父节点下确界a（即a >= b），则不必再扩展MIN结点的其他子结点了，剪枝即可 贝塔剪枝： 对于一个MAX结点，如果能够推导出其下确界a，并且a不小于MAX结点的父节点上确界b（即a >= b），则不必再扩展MAX结点的其他子结点了，剪枝即可 专家系统 专家系统的概念：
专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题
专家系统的组成：
专家&mdash;-知识库&mdash;-推理机&mdash;-系统用户
专家系统的特点：
有专家水平的专业知识、能进行有效的推理、启发性、灵活性、透明性、交互性
知识库与推理机分离、具有解释功能
专家系统的类型：
按照解决类型划分：解释、诊断、预测、设计、规划、控制&mldr;&mldr; 按照应用类型划分：化学、电子学、地质学&mldr;&mldr; 按照系统体系结构划分：集中式、分布式、云计算 按照知识表示形式划分：基于规则、基于一阶谓词、基于框架、基于语义网 按照采用技术划分：符号推断、神经网络 专家系统实例：
医学专家系统——MYCIN 系统使用INTER LISP语言编写 推理策略：反向推理、深度优先的搜索 地质勘探专家系统——PROSPECTOR 推理方式：似然推理、逻辑推理、上下文推理 希望树 在启发式搜索与或树的过程中，有希望成为最优解树的部分结点所组成的树
定义如下：
初始结点S0一定在希望树中 如果结点x在希望树中，则一定有： 如果x是具有子结点的或结点，则其具有最小代价的子结点一定在希望树中 如果x是具有子结点的与结点，则其全部子结点都在希望树中 与或树的有序搜索过程本质上是寻找希望树的过程，因此随着搜索深度的增加，希望树也会随之变化
Agent Agent的概念：
一种能够在一定环境中自主运行和自主交互，以满足其设计目标的计算实体
按照属性区分Agent："><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/notes/artificial_intelligence/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/notes/artificial_intelligence/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="人工智能期末复习"><meta property="og:description" content="基本概念 语义角色 指有关语言成分在语句所表达的事件中所扮演的参与者角色
在自然语言处理中对自然语言进行划分处理称为各个语义角色，其中每个语义角色相互依赖，相互关联
常见的语义角色类型有：施事、受事、与事、工具、方式、时间、处所、结果、目的、原因等 例如对于语句：小明昨天晚上在公园遇到了小红
就可以分为Agent、Time、Location、Predicate、Patient等角色
语义角色从一开始的6个扩充到了现在的13个，依据是美国语言学家查理斯·费尔莫尔提出的“格语法”
机器学习 让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力 启发函数&估值函数 启发函数：对当前结点到大目标结点未来可能需要付出的代价的估计
对于同一个问题，可能有不同的启发函数，不同的启发函数带来的效果良莠不齐，而各个节点的代价函数是统一确定的，因此选择和优化启发函数是至关重要的
估值函数：为了防止在单独利用启发函数的时候误入歧途，会将启发函数和代价函数结合生成估值函数；即初始结点到达结点x处已经付出的代价与结点x到达目标结点的接近程度估计值的总和
语义标注 在NLP领域中对于自然语言进行分割，并且对每个部分都判断是什么类型的语义角色
语义角色标注是一种浅层的语义分析技术，它只标注谓词（谓语动词、名词、形容词）的语义角色
例如：
昨天张三在家吃苹果。
谓语动词“吃”的语义角色有：施事-张三，受事-苹果，时间-昨天，处所-家
博弈树 将双人完备的信息博弈过程用图表示出来，能得到一颗与或树，称为博弈树
在博弈树中，下一步该MAX走步的结点称为MAX结点；下一步该MIN走步的结点称为MIN结点 博弈树特点： 初始状态为初始结点 博弈树中的或结点和与结点是逐层交替出现的 整个博弈过程都是站在某一方的立场上，所有能使自己获胜的都是本源问题，相应的结点都是可解结点；所有会使对方获胜的结点都是不可解结点 博弈树采用变对子结点进行估值函数计算，再扩展结点的方法，使用的是极大极小化分析，因此引申出了阿尔法-贝塔剪枝
阿尔法-贝塔剪枝： 阿尔法剪枝： 对于一个MIN结点，如果能够推导出其上确界b，并且b不大于MIN结点的父节点下确界a（即a >= b），则不必再扩展MIN结点的其他子结点了，剪枝即可 贝塔剪枝： 对于一个MAX结点，如果能够推导出其下确界a，并且a不小于MAX结点的父节点上确界b（即a >= b），则不必再扩展MAX结点的其他子结点了，剪枝即可 专家系统 专家系统的概念：
专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题
专家系统的组成：
专家&mdash;-知识库&mdash;-推理机&mdash;-系统用户
专家系统的特点：
有专家水平的专业知识、能进行有效的推理、启发性、灵活性、透明性、交互性
知识库与推理机分离、具有解释功能
专家系统的类型：
按照解决类型划分：解释、诊断、预测、设计、规划、控制&mldr;&mldr; 按照应用类型划分：化学、电子学、地质学&mldr;&mldr; 按照系统体系结构划分：集中式、分布式、云计算 按照知识表示形式划分：基于规则、基于一阶谓词、基于框架、基于语义网 按照采用技术划分：符号推断、神经网络 专家系统实例：
医学专家系统——MYCIN 系统使用INTER LISP语言编写 推理策略：反向推理、深度优先的搜索 地质勘探专家系统——PROSPECTOR 推理方式：似然推理、逻辑推理、上下文推理 希望树 在启发式搜索与或树的过程中，有希望成为最优解树的部分结点所组成的树
定义如下：
初始结点S0一定在希望树中 如果结点x在希望树中，则一定有： 如果x是具有子结点的或结点，则其具有最小代价的子结点一定在希望树中 如果x是具有子结点的与结点，则其全部子结点都在希望树中 与或树的有序搜索过程本质上是寻找希望树的过程，因此随着搜索深度的增加，希望树也会随之变化
Agent Agent的概念：
一种能够在一定环境中自主运行和自主交互，以满足其设计目标的计算实体
按照属性区分Agent："><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/notes/artificial_intelligence/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-09T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="人工智能期末复习"><meta name=twitter:description content="基本概念 语义角色 指有关语言成分在语句所表达的事件中所扮演的参与者角色
在自然语言处理中对自然语言进行划分处理称为各个语义角色，其中每个语义角色相互依赖，相互关联
常见的语义角色类型有：施事、受事、与事、工具、方式、时间、处所、结果、目的、原因等 例如对于语句：小明昨天晚上在公园遇到了小红
就可以分为Agent、Time、Location、Predicate、Patient等角色
语义角色从一开始的6个扩充到了现在的13个，依据是美国语言学家查理斯·费尔莫尔提出的“格语法”
机器学习 让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力 启发函数&估值函数 启发函数：对当前结点到大目标结点未来可能需要付出的代价的估计
对于同一个问题，可能有不同的启发函数，不同的启发函数带来的效果良莠不齐，而各个节点的代价函数是统一确定的，因此选择和优化启发函数是至关重要的
估值函数：为了防止在单独利用启发函数的时候误入歧途，会将启发函数和代价函数结合生成估值函数；即初始结点到达结点x处已经付出的代价与结点x到达目标结点的接近程度估计值的总和
语义标注 在NLP领域中对于自然语言进行分割，并且对每个部分都判断是什么类型的语义角色
语义角色标注是一种浅层的语义分析技术，它只标注谓词（谓语动词、名词、形容词）的语义角色
例如：
昨天张三在家吃苹果。
谓语动词“吃”的语义角色有：施事-张三，受事-苹果，时间-昨天，处所-家
博弈树 将双人完备的信息博弈过程用图表示出来，能得到一颗与或树，称为博弈树
在博弈树中，下一步该MAX走步的结点称为MAX结点；下一步该MIN走步的结点称为MIN结点 博弈树特点： 初始状态为初始结点 博弈树中的或结点和与结点是逐层交替出现的 整个博弈过程都是站在某一方的立场上，所有能使自己获胜的都是本源问题，相应的结点都是可解结点；所有会使对方获胜的结点都是不可解结点 博弈树采用变对子结点进行估值函数计算，再扩展结点的方法，使用的是极大极小化分析，因此引申出了阿尔法-贝塔剪枝
阿尔法-贝塔剪枝： 阿尔法剪枝： 对于一个MIN结点，如果能够推导出其上确界b，并且b不大于MIN结点的父节点下确界a（即a >= b），则不必再扩展MIN结点的其他子结点了，剪枝即可 贝塔剪枝： 对于一个MAX结点，如果能够推导出其下确界a，并且a不小于MAX结点的父节点上确界b（即a >= b），则不必再扩展MAX结点的其他子结点了，剪枝即可 专家系统 专家系统的概念：
专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题
专家系统的组成：
专家&mdash;-知识库&mdash;-推理机&mdash;-系统用户
专家系统的特点：
有专家水平的专业知识、能进行有效的推理、启发性、灵活性、透明性、交互性
知识库与推理机分离、具有解释功能
专家系统的类型：
按照解决类型划分：解释、诊断、预测、设计、规划、控制&mldr;&mldr; 按照应用类型划分：化学、电子学、地质学&mldr;&mldr; 按照系统体系结构划分：集中式、分布式、云计算 按照知识表示形式划分：基于规则、基于一阶谓词、基于框架、基于语义网 按照采用技术划分：符号推断、神经网络 专家系统实例：
医学专家系统——MYCIN 系统使用INTER LISP语言编写 推理策略：反向推理、深度优先的搜索 地质勘探专家系统——PROSPECTOR 推理方式：似然推理、逻辑推理、上下文推理 希望树 在启发式搜索与或树的过程中，有希望成为最优解树的部分结点所组成的树
定义如下：
初始结点S0一定在希望树中 如果结点x在希望树中，则一定有： 如果x是具有子结点的或结点，则其具有最小代价的子结点一定在希望树中 如果x是具有子结点的与结点，则其全部子结点都在希望树中 与或树的有序搜索过程本质上是寻找希望树的过程，因此随着搜索深度的增加，希望树也会随之变化
Agent Agent的概念：
一种能够在一定环境中自主运行和自主交互，以满足其设计目标的计算实体
按照属性区分Agent："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"人工智能期末复习","item":"https://sirius1y.top/posts/notes/notes/artificial_intelligence/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"人工智能期末复习","name":"人工智能期末复习","description":"基本概念 语义角色 指有关语言成分在语句所表达的事件中所扮演的参与者角色\n在自然语言处理中对自然语言进行划分处理称为各个语义角色，其中每个语义角色相互依赖，相互关联\n常见的语义角色类型有：施事、受事、与事、工具、方式、时间、处所、结果、目的、原因等 例如对于语句：小明昨天晚上在公园遇到了小红\n就可以分为Agent、Time、Location、Predicate、Patient等角色\n语义角色从一开始的6个扩充到了现在的13个，依据是美国语言学家查理斯·费尔莫尔提出的“格语法”\n机器学习 让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力 启发函数\u0026amp;估值函数 启发函数：对当前结点到大目标结点未来可能需要付出的代价的估计\n对于同一个问题，可能有不同的启发函数，不同的启发函数带来的效果良莠不齐，而各个节点的代价函数是统一确定的，因此选择和优化启发函数是至关重要的\n估值函数：为了防止在单独利用启发函数的时候误入歧途，会将启发函数和代价函数结合生成估值函数；即初始结点到达结点x处已经付出的代价与结点x到达目标结点的接近程度估计值的总和\n语义标注 在NLP领域中对于自然语言进行分割，并且对每个部分都判断是什么类型的语义角色\n语义角色标注是一种浅层的语义分析技术，它只标注谓词（谓语动词、名词、形容词）的语义角色\n例如：\n昨天张三在家吃苹果。\n谓语动词“吃”的语义角色有：施事-张三，受事-苹果，时间-昨天，处所-家\n博弈树 将双人完备的信息博弈过程用图表示出来，能得到一颗与或树，称为博弈树\n在博弈树中，下一步该MAX走步的结点称为MAX结点；下一步该MIN走步的结点称为MIN结点 博弈树特点： 初始状态为初始结点 博弈树中的或结点和与结点是逐层交替出现的 整个博弈过程都是站在某一方的立场上，所有能使自己获胜的都是本源问题，相应的结点都是可解结点；所有会使对方获胜的结点都是不可解结点 博弈树采用变对子结点进行估值函数计算，再扩展结点的方法，使用的是极大极小化分析，因此引申出了阿尔法-贝塔剪枝\n阿尔法-贝塔剪枝： 阿尔法剪枝： 对于一个MIN结点，如果能够推导出其上确界b，并且b不大于MIN结点的父节点下确界a（即a \u0026gt;= b），则不必再扩展MIN结点的其他子结点了，剪枝即可 贝塔剪枝： 对于一个MAX结点，如果能够推导出其下确界a，并且a不小于MAX结点的父节点上确界b（即a \u0026gt;= b），则不必再扩展MAX结点的其他子结点了，剪枝即可 专家系统 专家系统的概念：\n专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题\n专家系统的组成：\n专家\u0026mdash;-知识库\u0026mdash;-推理机\u0026mdash;-系统用户\n专家系统的特点：\n有专家水平的专业知识、能进行有效的推理、启发性、灵活性、透明性、交互性\n知识库与推理机分离、具有解释功能\n专家系统的类型：\n按照解决类型划分：解释、诊断、预测、设计、规划、控制\u0026hellip;\u0026hellip; 按照应用类型划分：化学、电子学、地质学\u0026hellip;\u0026hellip; 按照系统体系结构划分：集中式、分布式、云计算 按照知识表示形式划分：基于规则、基于一阶谓词、基于框架、基于语义网 按照采用技术划分：符号推断、神经网络 专家系统实例：\n医学专家系统——MYCIN 系统使用INTER LISP语言编写 推理策略：反向推理、深度优先的搜索 地质勘探专家系统——PROSPECTOR 推理方式：似然推理、逻辑推理、上下文推理 希望树 在启发式搜索与或树的过程中，有希望成为最优解树的部分结点所组成的树\n定义如下：\n初始结点S0一定在希望树中 如果结点x在希望树中，则一定有： 如果x是具有子结点的或结点，则其具有最小代价的子结点一定在希望树中 如果x是具有子结点的与结点，则其全部子结点都在希望树中 与或树的有序搜索过程本质上是寻找希望树的过程，因此随着搜索深度的增加，希望树也会随之变化\nAgent Agent的概念：\n一种能够在一定环境中自主运行和自主交互，以满足其设计目标的计算实体\n按照属性区分Agent：","keywords":["AI"],"articleBody":"基本概念 语义角色 指有关语言成分在语句所表达的事件中所扮演的参与者角色\n在自然语言处理中对自然语言进行划分处理称为各个语义角色，其中每个语义角色相互依赖，相互关联\n常见的语义角色类型有：施事、受事、与事、工具、方式、时间、处所、结果、目的、原因等 例如对于语句：小明昨天晚上在公园遇到了小红\n就可以分为Agent、Time、Location、Predicate、Patient等角色\n语义角色从一开始的6个扩充到了现在的13个，依据是美国语言学家查理斯·费尔莫尔提出的“格语法”\n机器学习 让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力 启发函数\u0026估值函数 启发函数：对当前结点到大目标结点未来可能需要付出的代价的估计\n对于同一个问题，可能有不同的启发函数，不同的启发函数带来的效果良莠不齐，而各个节点的代价函数是统一确定的，因此选择和优化启发函数是至关重要的\n估值函数：为了防止在单独利用启发函数的时候误入歧途，会将启发函数和代价函数结合生成估值函数；即初始结点到达结点x处已经付出的代价与结点x到达目标结点的接近程度估计值的总和\n语义标注 在NLP领域中对于自然语言进行分割，并且对每个部分都判断是什么类型的语义角色\n语义角色标注是一种浅层的语义分析技术，它只标注谓词（谓语动词、名词、形容词）的语义角色\n例如：\n昨天张三在家吃苹果。\n谓语动词“吃”的语义角色有：施事-张三，受事-苹果，时间-昨天，处所-家\n博弈树 将双人完备的信息博弈过程用图表示出来，能得到一颗与或树，称为博弈树\n在博弈树中，下一步该MAX走步的结点称为MAX结点；下一步该MIN走步的结点称为MIN结点 博弈树特点： 初始状态为初始结点 博弈树中的或结点和与结点是逐层交替出现的 整个博弈过程都是站在某一方的立场上，所有能使自己获胜的都是本源问题，相应的结点都是可解结点；所有会使对方获胜的结点都是不可解结点 博弈树采用变对子结点进行估值函数计算，再扩展结点的方法，使用的是极大极小化分析，因此引申出了阿尔法-贝塔剪枝\n阿尔法-贝塔剪枝： 阿尔法剪枝： 对于一个MIN结点，如果能够推导出其上确界b，并且b不大于MIN结点的父节点下确界a（即a \u003e= b），则不必再扩展MIN结点的其他子结点了，剪枝即可 贝塔剪枝： 对于一个MAX结点，如果能够推导出其下确界a，并且a不小于MAX结点的父节点上确界b（即a \u003e= b），则不必再扩展MAX结点的其他子结点了，剪枝即可 专家系统 专家系统的概念：\n专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题\n专家系统的组成：\n专家—-知识库—-推理机—-系统用户\n专家系统的特点：\n有专家水平的专业知识、能进行有效的推理、启发性、灵活性、透明性、交互性\n知识库与推理机分离、具有解释功能\n专家系统的类型：\n按照解决类型划分：解释、诊断、预测、设计、规划、控制…… 按照应用类型划分：化学、电子学、地质学…… 按照系统体系结构划分：集中式、分布式、云计算 按照知识表示形式划分：基于规则、基于一阶谓词、基于框架、基于语义网 按照采用技术划分：符号推断、神经网络 专家系统实例：\n医学专家系统——MYCIN 系统使用INTER LISP语言编写 推理策略：反向推理、深度优先的搜索 地质勘探专家系统——PROSPECTOR 推理方式：似然推理、逻辑推理、上下文推理 希望树 在启发式搜索与或树的过程中，有希望成为最优解树的部分结点所组成的树\n定义如下：\n初始结点S0一定在希望树中 如果结点x在希望树中，则一定有： 如果x是具有子结点的或结点，则其具有最小代价的子结点一定在希望树中 如果x是具有子结点的与结点，则其全部子结点都在希望树中 与或树的有序搜索过程本质上是寻找希望树的过程，因此随着搜索深度的增加，希望树也会随之变化\nAgent Agent的概念：\n一种能够在一定环境中自主运行和自主交互，以满足其设计目标的计算实体\n按照属性区分Agent：\n反应Agent：Agent中包含了感知内外部状态变化的感知器、一组对相关事件作出反应的过程,和一个依据感知器激活某过程执行的控制系统,Agent的活动是由于受到内外部某种\"刺激\"而发生的 认知Agent：Agent中包含了显式表示的世界符号模型,Agent的决策是通过基于模板匹配和符号操作的逻辑(或准逻辑)推理作出的,如同人们通过\"深思熟虑\"后作出决定一样 混合Agent：Agent中包含了认知式和反应式两个子系统,通常这两个子系统是分层次的,前者建立在后者的基础之上 按照存储方式区分多Agent系统：\n反应式多Agent系统：系统由反应式Agent构成，其行为以对环境的感知为基础 黑板模式多Agent系统：系统中的信息均存储在一个称为黑板的存储区内 分布式存储多Agent系统：系统中的Agent通过数据封装拥有自己的私有信息，并且利用消息通信实现不同Agent之间信息交换、知识共享和协作求解 Agent通信：\n指多Agent系统中不同Agent之间的信息交换，其基本问题包括\n通信方式\n常用的有消息传送和黑板系统\n通信语言\n常用语言有知识查询和操纵语言KQML\n对话管理\n通信协议：\n包括底层和高层的协议。底层的有TCP、HTTP、FTP等；高层的有有限状态自动机和Petri网等\n移动Agent：\n一种可以从网络上一个结点自主移动到另一个结点，实现分布式问题处理的特殊Agent，由移动Agent和移动Agent环境两部分组成\n决策树 一种由结点和边构成的用来描述分类过程的层次数据结构\n一般可以通过：信息增益、增益率、基尼系数等属性来划分\nID3决策树以信息增益来选择划分属性： 熵：$$Entropy(S) = \\sum_{i = 1}^{c}{-p_ilog_2p_i}$$，其中S为训练样例集，c为标记值的总数，pi为第i个标记值的样例子集占的比例 如果p=0，则总体为0 信息增益：$$Gain(S,A) = Entropy(S) - \\sum_{v \\in Values(A)}{\\frac{|S_v|}{|S|}Entropy(S_v)}$$，其中S为训练样例集，A为某个属性，Sv为属性A取值为v的样例集 Horn子句及其类型 原子公式以及其否定被称为文字，前者为正文字，后者为负文字；一条子句包含若干正文字和若干负文字；因此可将字句的一般形式表示为：\n至多含有一个正文字（即箭头左侧至多只有一个子句）的子句被称为Horn子句，一共有三种Horn子句的形式：\n可以使用Horn子句进行推理的归结，由此衍生出了Prolog语言\n基本问题 人工智能的主要内容有哪些？ 机器学习：让机器从数据中学习并不断优化自己 自然语言处理：让机器能够理解、分析、生成自然语言 计算机视觉：让机器能够感知、理解和识别图像和视频信息 机器人学：让机器能够感知环境并且执行任务，包括物理机器人和虚拟机器人 智能决策：通关算法和数据分析让机器能够作出可靠的决策 人工智能伦理：讨论人工智能应用过程中的伦理问题和社会影响 什么是A算法和A*算法 不管是A算法还是A*算法，都使用了相似的算法思路，即：根据启发函数的值来选择下一步搜索的目标\nA算法：\n估值函数如下：$$估值函数f(x) = 代价函数g(x) + 启发函数h(x)$$\nA*算法：\n在A算法的基础上，对启发函数做了进一步的限制：对所有的结点x均有h(x) \u003c= h(x)*，其中h*(x)是从结点x到目标结点的实际的最小代价\n显然，如果我们始终让h(x)=0，那么一定能够满足h(x) \u003c= h*(x)，然而这样做效率会大大降低，不符合A*算法的初衷，因此在实际应用中，定义的h(x)应当尽可能大，使其接近h*(x)\n全局择优搜索、局部择优搜索 全局择优搜索：\n每当需要扩展结点的时候，总是从Open表中的所有结点选取一个估值函数最小的结点进行扩展\n局部择优搜索：\n每当需要扩展结点的时候，总是从刚生成的子结点中选择一个估值函数最小的结点进行扩展\n替换与合一的含义 替换： 一个替换是形如{t1/x1, t2/x2 … , tn/xn}的有限集合，其中ti是项，称为替换的分子；xi是互不相同的个体变元，称为替换的分母 ti和xi不同，xi不循环出现在tj中 ti/xi表示用ti替换xi 若其中ti是不含变元的项，则该替换为基替换 没有元素的替换称为空替换 合一： 设有一个公式集F={F1,F2,F3 … FN}，若存在一个替换Ω，使得F1Ω=F2Ω= … = FNΩ，则称Ω为F的一个合一，称F为可合一的 简述正向推理和反向推理的过程 正向推理： 把用户提供的初始证据放入综合数据库 检查综合数据库中是否包含问题的解，若已包含，则求解结束，并成功退出；否则进入下一步 检查知识库中是否有可用的知识，若有，则形成当前可用的知识集，执行下一步；否则转第5步 按照某种冲突消解策略，从当前可用知识集中选出一条规则进行推理，并将推出的新事实加入综合数据库中，然后转2 询问用户是否可以进一步补充新的事实，若可以补充，则将补充的新事实加入综合数据库，然后转3；否则表示无解，失败退出 简单来说就是（证据 -\u003e 结论）的流程\n反向推理： 将要求证的目标（称为假设）构成一个假设集 从假设集中选出一个假设，检查该假设是否在综合数据库中，若在，则该假设成立，此时，若假设集为空，则成功退出，否则仍执行第2步；若该假设不在数据库中，则执行下一步 检查该假设是否可以由知识库的某个知识导出，若不能，则询问用户该假设是否为可由用户证实的原始事实，若是，假设成立，将其放入综合数据库，再重新寻找新的假设，若不是，则转5；若能由某个知识导出，则执行下一步 将知识库中可以导出该假设的所有知识构成一个可用知识集 检查可用知识集是否为空，若是，则失败退出；否则执行下一步 按冲突消解策略从可用知识集中取出一个知识，继续 将该知识的前提中的每个子条件都作为新的假设放入假设集，然后转2 Agent的基本特征 自主性、反应性、协调性、社会性、推理性、个性、移动性 机器学习（形式定义） 让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力 图灵测试、中文屋子 图灵测试： 一位测试主持+两位被测对象 被测对象：人、机器 隔离：通过计算机终端通信 被测对象回答具有智能性的问题 如果主持人分辨出人和机器的概率小于50%（30%），则通过图灵测试 中文屋子（模拟图灵测试）： 一个人（扮演计算机的CPU）在一个封闭的房子里，有输入和输出与外部相通 输入的问题是中文的，但此人不懂中文；而屋子里有一本英语的指令手册（相当于程序），从中可以找到对应的规则 他按照规则办事，并且将结果写成中文进行输出，看上去就好像他懂中文一样 中文屋子是用来反驳图灵测试对于强人工智能的定义的\n基于词和基于字的分词方法 汉语自动分词方法\n基于字的分词方法：\n将分词转化为给字贴标签，形式化为机器学习中的序列标记问题\n根据字在词中的位置一般有四个标记：词首B、词中M、词尾E、独立成词S\n例如下列句子：\n自然语言处理是人工智能的分支学科\n在每一个字后面都加上标记后的序列如下：\n自/B 然/M 语/M 言/M 处/M 理/E 是/S 人/B 工/M 智/M 能/E 的/S 分/B 支/E 学/B 科/E\n对每一句句子加完标签后重新扫描，就可以获得词的序列了\n基于词的分词方法：\n采用正向最大匹配法：遍历词典中有的词，并且去长度最大的进行分割\n其他方法论 求最一般合一（MGU） 可信度方法（C-F模型） 公式如下：\n其中MB表示信任增长度，MD表示不信任增长度，两者的绝对值相等\n其中由于CF值会有复数个前提条件，因此对于重复结论的CF值的计算如下：\n主观Bayes方法 在很多时候同一个事件的结果对应的前提条件是没有可复制性的，此时P（A｜B）就是一个不必要的概率，在主观bayes方法中将其解释为：在证据B的基础上，假设A的似然性\n几率函数：$$O(x) = \\frac{P(x)}{1 - P(x)}$$\n反过来也可以用已知的几率推出似然性：$$P(x) = \\frac{O(x)}{1 + O(x)}$$\nLS（充分性量度）：\nE为真时，对结论H的支持程度，定义为：$$LS = \\frac{P(E|H)}{P(E|¬H)}$$\nLN（必要性量度）：\n¬E为真时，对结论H的支持程度，定义为：$$LN = \\frac{P(¬E|H)}{P(¬E|¬H)} = \\frac{1 - P(E|H)}{1 - P(E|¬H)}$$\nLS和LN一般由专家给出\n主观Bayes方法推理的任务就是根据证据E得概率P（E）以及LS、LN，将H的先验概率更新为后验概率，即P(E) -\u003e P(E|H)或者P(E|¬H)\n不确定性的传播与计算：\n由此可以推出EH公式（背就完事了）：\n在Prospector中引进了可信度的概念，让用户在-5到5这11个可信度中选取一个作为初始可信度C(E|S)，于是在一系列的公式推导之后得出了以下三组公式：\n这三组公式视情况使用\n传教士与野人过河问题 启发函数为$$h(x) = M + C - K * B$$，其中M为传教士人数、C为野人人数，K为船载人数，B为船只数量（这里为1）\n一元线性回归 这里使用最小二乘法 $$ L(w,b) = \\sum_{i = 1}^{n}{(y_i - \\widehat{y_i})^2} = \\sum_{i = 1}^{n}{(y_i - wx_i - b)^2} $$\n分别对w和b求偏导，并且让他们等于零，即可算出w和b的值 ","wordCount":"286","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-11-09T00:00:00Z","dateModified":"2023-11-09T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/notes/artificial_intelligence/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">人工智能期末复习</h1><div class=post-meta><span title='2023-11-09 00:00:00 +0000 UTC'>November 9, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;286 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=基本概念>基本概念</a><ul><li><a href=#%e8%af%ad%e4%b9%89%e8%a7%92%e8%89%b2 aria-label=语义角色>语义角色</a></li><li><a href=#%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0 aria-label=机器学习>机器学习</a></li><li><a href=#%e5%90%af%e5%8f%91%e5%87%bd%e6%95%b0%e4%bc%b0%e5%80%bc%e5%87%bd%e6%95%b0 aria-label=启发函数&amp;amp;估值函数>启发函数&估值函数</a></li><li><a href=#%e8%af%ad%e4%b9%89%e6%a0%87%e6%b3%a8 aria-label=语义标注>语义标注</a></li><li><a href=#%e5%8d%9a%e5%bc%88%e6%a0%91 aria-label=博弈树>博弈树</a></li><li><a href=#%e4%b8%93%e5%ae%b6%e7%b3%bb%e7%bb%9f aria-label=专家系统>专家系统</a></li><li><a href=#%e5%b8%8c%e6%9c%9b%e6%a0%91 aria-label=希望树>希望树</a></li><li><a href=#agent aria-label=Agent>Agent</a></li><li><a href=#%e5%86%b3%e7%ad%96%e6%a0%91 aria-label=决策树>决策树</a></li><li><a href=#horn%e5%ad%90%e5%8f%a5%e5%8f%8a%e5%85%b6%e7%b1%bb%e5%9e%8b aria-label=Horn子句及其类型>Horn子句及其类型</a></li></ul></li><li><a href=#%e5%9f%ba%e6%9c%ac%e9%97%ae%e9%a2%98 aria-label=基本问题>基本问题</a><ul><li><a href=#%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e7%9a%84%e4%b8%bb%e8%a6%81%e5%86%85%e5%ae%b9%e6%9c%89%e5%93%aa%e4%ba%9b aria-label=人工智能的主要内容有哪些？>人工智能的主要内容有哪些？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afa%e7%ae%97%e6%b3%95%e5%92%8ca%e7%ae%97%e6%b3%95 aria-label=什么是A算法和A*算法>什么是A算法和A*算法</a></li><li><a href=#%e5%85%a8%e5%b1%80%e6%8b%a9%e4%bc%98%e6%90%9c%e7%b4%a2%e5%b1%80%e9%83%a8%e6%8b%a9%e4%bc%98%e6%90%9c%e7%b4%a2 aria-label=全局择优搜索、局部择优搜索>全局择优搜索、局部择优搜索</a></li><li><a href=#%e6%9b%bf%e6%8d%a2%e4%b8%8e%e5%90%88%e4%b8%80%e7%9a%84%e5%90%ab%e4%b9%89 aria-label=替换与合一的含义>替换与合一的含义</a></li><li><a href=#%e7%ae%80%e8%bf%b0%e6%ad%a3%e5%90%91%e6%8e%a8%e7%90%86%e5%92%8c%e5%8f%8d%e5%90%91%e6%8e%a8%e7%90%86%e7%9a%84%e8%bf%87%e7%a8%8b aria-label=简述正向推理和反向推理的过程>简述正向推理和反向推理的过程</a></li><li><a href=#agent%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%89%b9%e5%be%81 aria-label=Agent的基本特征>Agent的基本特征</a></li><li><a href=#%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e5%bd%a2%e5%bc%8f%e5%ae%9a%e4%b9%89 aria-label=机器学习（形式定义）>机器学习（形式定义）</a></li><li><a href=#%e5%9b%be%e7%81%b5%e6%b5%8b%e8%af%95%e4%b8%ad%e6%96%87%e5%b1%8b%e5%ad%90 aria-label=图灵测试、中文屋子>图灵测试、中文屋子</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e8%af%8d%e5%92%8c%e5%9f%ba%e4%ba%8e%e5%ad%97%e7%9a%84%e5%88%86%e8%af%8d%e6%96%b9%e6%b3%95 aria-label=基于词和基于字的分词方法>基于词和基于字的分词方法</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95%e8%ae%ba aria-label=其他方法论>其他方法论</a><ul><li><a href=#%e6%b1%82%e6%9c%80%e4%b8%80%e8%88%ac%e5%90%88%e4%b8%80mgu aria-label=求最一般合一（MGU）>求最一般合一（MGU）</a></li><li><a href=#%e5%8f%af%e4%bf%a1%e5%ba%a6%e6%96%b9%e6%b3%95c-f%e6%a8%a1%e5%9e%8b aria-label=可信度方法（C-F模型）>可信度方法（C-F模型）</a></li><li><a href=#%e4%b8%bb%e8%a7%82bayes%e6%96%b9%e6%b3%95 aria-label=主观Bayes方法>主观Bayes方法</a></li><li><a href=#%e4%bc%a0%e6%95%99%e5%a3%ab%e4%b8%8e%e9%87%8e%e4%ba%ba%e8%bf%87%e6%b2%b3%e9%97%ae%e9%a2%98 aria-label=传教士与野人过河问题>传教士与野人过河问题</a></li><li><a href=#%e4%b8%80%e5%85%83%e7%ba%bf%e6%80%a7%e5%9b%9e%e5%bd%92 aria-label=一元线性回归>一元线性回归</a><ul><ul><ul><ul><li><a href=#%e5%88%86%e5%88%ab%e5%af%b9w%e5%92%8cb%e6%b1%82%e5%81%8f%e5%af%bc%e5%b9%b6%e4%b8%94%e8%ae%a9%e4%bb%96%e4%bb%ac%e7%ad%89%e4%ba%8e%e9%9b%b6%e5%8d%b3%e5%8f%af%e7%ae%97%e5%87%baw%e5%92%8cb%e7%9a%84%e5%80%bc aria-label=分别对w和b求偏导，并且让他们等于零，即可算出w和b的值>分别对w和b求偏导，并且让他们等于零，即可算出w和b的值</a></li></ul></li></ul></ul></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h1><h2 id=语义角色>语义角色<a hidden class=anchor aria-hidden=true href=#语义角色>#</a></h2><ul><li><p>指有关语言成分在语句所表达的事件中所扮演的参与者角色</p></li><li><p>在自然语言处理中对自然语言进行划分处理称为各个语义角色，其中每个语义角色相互依赖，相互关联</p><ul><li>常见的语义角色类型有：施事、受事、与事、工具、方式、时间、处所、结果、目的、原因等</li></ul><blockquote><p>例如对于语句：小明昨天晚上在公园遇到了小红</p><p>就可以分为Agent、Time、Location、Predicate、Patient等角色</p></blockquote></li><li><p>语义角色从一开始的6个扩充到了现在的13个，依据是美国语言学家查理斯·费尔莫尔提出的“格语法”</p></li></ul><h2 id=机器学习>机器学习<a hidden class=anchor aria-hidden=true href=#机器学习>#</a></h2><ul><li>让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力</li></ul><h2 id=启发函数估值函数>启发函数&估值函数<a hidden class=anchor aria-hidden=true href=#启发函数估值函数>#</a></h2><ul><li><p>启发函数：对当前结点到大目标结点未来可能需要付出的代价的估计</p><p>对于同一个问题，可能有不同的启发函数，不同的启发函数带来的效果良莠不齐，而各个节点的代价函数是统一确定的，因此选择和优化启发函数是至关重要的</p></li><li><p>估值函数：为了防止在单独利用启发函数的时候误入歧途，会将启发函数和代价函数结合生成估值函数；即初始结点到达结点x处已经付出的<strong>代价</strong>与结点x到达目标结点的<strong>接近程度估计值</strong>的总和</p></li></ul><h2 id=语义标注>语义标注<a hidden class=anchor aria-hidden=true href=#语义标注>#</a></h2><ul><li><p>在NLP领域中对于自然语言进行分割，并且对每个部分都判断是什么类型的语义角色</p></li><li><p>语义角色标注是一种浅层的语义分析技术，它只标注谓词（谓语动词、名词、形容词）的语义角色</p><blockquote><p>例如：</p><p>昨天张三在家吃苹果。</p><p>谓语动词“吃”的语义角色有：施事-张三，受事-苹果，时间-昨天，处所-家</p></blockquote></li></ul><h2 id=博弈树>博弈树<a hidden class=anchor aria-hidden=true href=#博弈树>#</a></h2><p>将双人完备的信息博弈过程用图表示出来，能得到一颗与或树，称为博弈树</p><ul><li>在博弈树中，下一步该MAX走步的结点称为MAX结点；下一步该MIN走步的结点称为MIN结点</li><li>博弈树特点：<ul><li>初始状态为初始结点</li><li>博弈树中的或结点和与结点是逐层交替出现的</li><li>整个博弈过程都是站在某一方的立场上，所有能使自己获胜的都是本源问题，相应的结点都是可解结点；所有会使对方获胜的结点都是不可解结点</li></ul></li></ul><p>博弈树采用变对子结点进行估值函数计算，再扩展结点的方法，使用的是极大极小化分析，因此引申出了阿尔法-贝塔剪枝</p><ul><li>阿尔法-贝塔剪枝：<ul><li>阿尔法剪枝：<ul><li>对于一个MIN结点，如果能够推导出其上确界b，并且b不大于MIN结点的父节点下确界a（即a >= b），则不必再扩展MIN结点的其他子结点了，剪枝即可</li></ul></li><li>贝塔剪枝：<ul><li>对于一个MAX结点，如果能够推导出其下确界a，并且a不小于MAX结点的父节点上确界b（即a >= b），则不必再扩展MAX结点的其他子结点了，剪枝即可</li></ul></li></ul></li></ul><h2 id=专家系统>专家系统<a hidden class=anchor aria-hidden=true href=#专家系统>#</a></h2><ul><li><p>专家系统的概念：</p><p>专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题</p></li><li><p>专家系统的组成：</p><p>专家&mdash;-知识库&mdash;-推理机&mdash;-系统用户</p></li><li><p>专家系统的特点：</p><p>有专家水平的专业知识、能进行有效的推理、启发性、灵活性、透明性、交互性</p><p>知识库与推理机分离、具有解释功能</p></li><li><p>专家系统的类型：</p><ul><li>按照解决类型划分：解释、诊断、预测、设计、规划、控制&mldr;&mldr;</li><li>按照应用类型划分：化学、电子学、地质学&mldr;&mldr;</li><li>按照系统体系结构划分：集中式、分布式、云计算</li><li>按照知识表示形式划分：基于规则、基于一阶谓词、基于框架、基于语义网</li><li>按照采用技术划分：符号推断、神经网络</li></ul></li><li><p>专家系统实例：</p><ul><li>医学专家系统——MYCIN<ul><li>系统使用INTER LISP语言编写</li><li>推理策略：反向推理、深度优先的搜索</li></ul></li><li>地质勘探专家系统——PROSPECTOR<ul><li>推理方式：似然推理、逻辑推理、上下文推理</li></ul></li></ul></li></ul><h2 id=希望树>希望树<a hidden class=anchor aria-hidden=true href=#希望树>#</a></h2><p>在启发式搜索与或树的过程中，有希望成为最优解树的部分结点所组成的树</p><ul><li><p>定义如下：</p><ul><li>初始结点S0一定在希望树中</li><li>如果结点x在希望树中，则一定有：<ul><li>如果x是具有子结点的<strong>或结点</strong>，则其<strong>具有最小代价</strong>的子结点一定在希望树中</li><li>如果x是具有子结点的<strong>与结点</strong>，则其<strong>全部子结点</strong>都在希望树中</li></ul></li></ul></li><li><p>与或树的有序搜索过程本质上是寻找希望树的过程，因此随着搜索深度的增加，希望树也会随之变化</p></li></ul><h2 id=agent>Agent<a hidden class=anchor aria-hidden=true href=#agent>#</a></h2><ul><li><p>Agent的概念：</p><p>一种能够在一定环境中自主运行和自主交互，以满足其设计目标的计算实体</p></li><li><p>按照属性区分Agent：</p><ul><li>反应Agent：Agent中包含了感知内外部状态变化的感知器、一组对相关事件作出反应的过程,和一个依据感知器激活某过程执行的控制系统,Agent的活动是由于受到内外部某种"刺激"而发生的</li><li>认知Agent：Agent中包含了显式表示的世界符号模型,Agent的决策是通过基于模板匹配和符号操作的逻辑(或准逻辑)推理作出的,如同人们通过"深思熟虑"后作出决定一样</li><li>混合Agent：Agent中包含了认知式和反应式两个子系统,通常这两个子系统是分层次的,前者建立在后者的基础之上</li></ul></li><li><p>按照存储方式区分多Agent系统：</p><ul><li>反应式多Agent系统：系统由反应式Agent构成，其行为以对环境的感知为基础</li><li>黑板模式多Agent系统：系统中的信息均存储在一个称为黑板的存储区内</li><li>分布式存储多Agent系统：系统中的Agent通过数据封装拥有自己的私有信息，并且利用消息通信实现不同Agent之间信息交换、知识共享和协作求解</li></ul></li><li><p>Agent通信：</p><p>指多Agent系统中不同Agent之间的信息交换，其基本问题包括</p><ol><li><p>通信方式</p><p>常用的有<strong>消息传送</strong>和<strong>黑板系统</strong></p></li><li><p>通信语言</p><p>常用语言有<strong>知识查询</strong>和<strong>操纵语言KQML</strong></p></li><li><p>对话管理</p></li><li><p>通信协议：</p><p>包括底层和高层的协议。底层的有TCP、HTTP、FTP等；高层的有有限状态自动机和Petri网等</p></li></ol></li><li><p>移动Agent：</p><p>一种可以从网络上一个结点自主移动到另一个结点，实现分布式问题处理的特殊Agent，由移动Agent和移动Agent环境两部分组成</p></li></ul><h2 id=决策树>决策树<a hidden class=anchor aria-hidden=true href=#决策树>#</a></h2><p>一种由结点和边构成的用来描述分类过程的层次数据结构</p><p>一般可以通过：信息增益、增益率、基尼系数等属性来划分</p><ul><li>ID3决策树以<strong>信息增益</strong>来选择划分属性：<ul><li>熵：$$Entropy(S) = \sum_{i = 1}^{c}{-p_ilog_2p_i}$$，其中S为训练样例集，c为标记值的总数，pi为第i个标记值的样例子集占的比例</li><li>如果p=0，则总体为0</li><li>信息增益：$$Gain(S,A) = Entropy(S) - \sum_{v \in Values(A)}{\frac{|S_v|}{|S|}Entropy(S_v)}$$，其中S为训练样例集，A为某个属性，Sv为属性A取值为v的样例集</li></ul></li></ul><h2 id=horn子句及其类型>Horn子句及其类型<a hidden class=anchor aria-hidden=true href=#horn子句及其类型>#</a></h2><ul><li><p>原子公式以及其否定被称为文字，前者为正文字，后者为负文字；一条子句包含若干正文字和若干负文字；因此可将字句的一般形式表示为：</p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/19I3qRwDYQCVupf.png alt=image-20240119083050174></p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/79Wv4z6bYyHU1hx.png alt=image-20240119083119733></p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/Rw9yQ3kipLB8TJt.png alt=image-20240119083131956></p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/P1uifkrHQjvdUel.png alt=image-20240119083217777></p></li><li><p>至多含有一个正文字（即箭头左侧至多只有一个子句）的子句被称为Horn子句，一共有三种Horn子句的形式：</p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/UMTmWG6oqJsk7RD.png alt=image-20240119083349657></p></li><li><p>可以使用Horn子句进行推理的归结，由此衍生出了Prolog语言</p></li></ul><h1 id=基本问题>基本问题<a hidden class=anchor aria-hidden=true href=#基本问题>#</a></h1><h2 id=人工智能的主要内容有哪些>人工智能的主要内容有哪些？<a hidden class=anchor aria-hidden=true href=#人工智能的主要内容有哪些>#</a></h2><ul><li>机器学习：让机器从数据中学习并不断优化自己</li><li>自然语言处理：让机器能够理解、分析、生成自然语言</li><li>计算机视觉：让机器能够感知、理解和识别图像和视频信息</li><li>机器人学：让机器能够感知环境并且执行任务，包括物理机器人和虚拟机器人</li><li>智能决策：通关算法和数据分析让机器能够作出可靠的决策</li><li>人工智能伦理：讨论人工智能应用过程中的伦理问题和社会影响</li></ul><h2 id=什么是a算法和a算法>什么是A算法和A*算法<a hidden class=anchor aria-hidden=true href=#什么是a算法和a算法>#</a></h2><p>不管是A算法还是A*算法，都使用了相似的算法思路，即：根据启发函数的值来选择下一步搜索的目标</p><ul><li><p>A算法：</p><p>估值函数如下：$$估值函数f(x) = 代价函数g(x) + 启发函数h(x)$$</p></li><li><p>A*算法：</p><p>在A算法的基础上，对启发函数做了进一步的限制：<em><em>对所有的结点x均有h(x) &lt;= h</em>(x)</em>*，其中h*(x)是从结点x到目标结点的实际的最小代价</p><blockquote><p>显然，如果我们始终让h(x)=0，那么一定能够满足h(x) &lt;= h*(x)，然而这样做效率会大大降低，不符合A*算法的初衷，因此在实际应用中，定义的h(x)应当尽可能大，使其接近h*(x)</p></blockquote></li></ul><h2 id=全局择优搜索局部择优搜索>全局择优搜索、局部择优搜索<a hidden class=anchor aria-hidden=true href=#全局择优搜索局部择优搜索>#</a></h2><ul><li><p>全局择优搜索：</p><p>每当需要扩展结点的时候，总是从Open表中的所有结点选取一个估值函数最小的结点进行扩展</p></li><li><p>局部择优搜索：</p><p>每当需要扩展结点的时候，总是从刚生成的子结点中选择一个估值函数最小的结点进行扩展</p></li></ul><h2 id=替换与合一的含义>替换与合一的含义<a hidden class=anchor aria-hidden=true href=#替换与合一的含义>#</a></h2><ul><li>替换：<ul><li>一个替换是形如{t1/x1, t2/x2 &mldr; , tn/xn}的有限集合，其中ti是项，称为替换的分子；xi是互不相同的个体变元，称为替换的分母</li><li>ti和xi不同，xi不循环出现在tj中</li><li>ti/xi表示用ti替换xi</li><li>若其中ti是不含变元的项，则该替换为基替换</li><li>没有元素的替换称为空替换</li></ul></li><li>合一：<ul><li>设有一个公式集F={F1,F2,F3 &mldr; FN}，若存在一个替换Ω，使得F1Ω=F2Ω= &mldr; = FNΩ，则称Ω为F的一个合一，称F为可合一的</li></ul></li></ul><h2 id=简述正向推理和反向推理的过程>简述正向推理和反向推理的过程<a hidden class=anchor aria-hidden=true href=#简述正向推理和反向推理的过程>#</a></h2><ul><li>正向推理：<ol><li>把用户提供的初始证据放入综合数据库</li><li>检查综合数据库中是否包含问题的解，若已包含，则求解结束，并成功退出；否则进入下一步</li><li>检查知识库中是否有可用的知识，若有，则形成当前可用的知识集，执行下一步；否则转第5步</li><li>按照某种冲突消解策略，从当前可用知识集中选出一条规则进行推理，并将推出的新事实加入综合数据库中，然后转2</li><li>询问用户是否可以进一步补充新的事实，若可以补充，则将补充的新事实加入综合数据库，然后转3；否则表示无解，失败退出</li></ol></li></ul><p>简单来说就是（证据 -> 结论）的流程</p><ul><li>反向推理：<ol><li>将要求证的目标（称为假设）构成一个假设集</li><li>从假设集中选出一个假设，检查该假设是否在综合数据库中，若在，则该假设成立，此时，若假设集为空，则成功退出，否则仍执行第2步；若该假设不在数据库中，则执行下一步</li><li>检查该假设是否可以由知识库的某个知识导出，若不能，则询问用户该假设是否为可由用户证实的原始事实，若是，假设成立，将其放入综合数据库，再重新寻找新的假设，若不是，则转5；若能由某个知识导出，则执行下一步</li><li>将知识库中可以导出该假设的所有知识构成一个可用知识集</li><li>检查可用知识集是否为空，若是，则失败退出；否则执行下一步</li><li>按冲突消解策略从可用知识集中取出一个知识，继续</li><li>将该知识的前提中的每个子条件都作为新的假设放入假设集，然后转2</li></ol></li></ul><h2 id=agent的基本特征>Agent的基本特征<a hidden class=anchor aria-hidden=true href=#agent的基本特征>#</a></h2><ul><li>自主性、反应性、协调性、社会性、推理性、个性、移动性</li></ul><h2 id=机器学习形式定义>机器学习（形式定义）<a hidden class=anchor aria-hidden=true href=#机器学习形式定义>#</a></h2><ul><li>让计算机能够像人一样自动获取新知识，并且在实践中不断完善自我和增强能力</li></ul><h2 id=图灵测试中文屋子>图灵测试、中文屋子<a hidden class=anchor aria-hidden=true href=#图灵测试中文屋子>#</a></h2><ul><li>图灵测试：<ul><li>一位测试主持+两位被测对象</li><li>被测对象：人、机器</li><li>隔离：通过计算机终端通信</li><li>被测对象回答具有智能性的问题</li><li>如果主持人分辨出人和机器的概率小于50%（30%），则通过图灵测试</li></ul></li><li>中文屋子（模拟图灵测试）：<ul><li>一个人（扮演计算机的CPU）在一个封闭的房子里，有输入和输出与外部相通</li><li>输入的问题是中文的，但此人不懂中文；而屋子里有一本英语的指令手册（相当于程序），从中可以找到对应的规则</li><li>他按照规则办事，并且将结果写成中文进行输出，看上去就好像他懂中文一样</li></ul></li></ul><p>中文屋子是用来反驳图灵测试对于强人工智能的定义的</p><h2 id=基于词和基于字的分词方法>基于词和基于字的分词方法<a hidden class=anchor aria-hidden=true href=#基于词和基于字的分词方法>#</a></h2><p>汉语自动分词方法</p><ul><li><p>基于字的分词方法：</p><ul><li><p>将分词转化为给字贴标签，形式化为机器学习中的序列标记问题</p></li><li><p>根据字在词中的位置一般有四个标记：词首B、词中M、词尾E、独立成词S</p><blockquote><p>例如下列句子：</p><p>自然语言处理是人工智能的分支学科</p><p>在每一个字后面都加上标记后的序列如下：</p><p>自/B 然/M 语/M 言/M 处/M 理/E 是/S 人/B 工/M 智/M 能/E 的/S 分/B 支/E 学/B 科/E</p></blockquote><p>对每一句句子加完标签后重新扫描，就可以获得词的序列了</p></li></ul></li><li><p>基于词的分词方法：</p><p>采用正向最大匹配法：遍历词典中有的词，并且去长度最大的进行分割</p></li></ul><h1 id=其他方法论>其他方法论<a hidden class=anchor aria-hidden=true href=#其他方法论>#</a></h1><h2 id=求最一般合一mgu>求最一般合一（MGU）<a hidden class=anchor aria-hidden=true href=#求最一般合一mgu>#</a></h2><p><img loading=lazy src=https://s2.loli.net/2024/01/22/buYHd1aegvhnRFM.png alt=image-20240118210309351></p><h2 id=可信度方法c-f模型>可信度方法（C-F模型）<a hidden class=anchor aria-hidden=true href=#可信度方法c-f模型>#</a></h2><ul><li><p>公式如下：</p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/WIp9y53QiRkXaEN.png alt=image-20240119091737182></p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/J7h1cBiQXP5nsHS.png alt=image-20240119091839753></p><p>其中MB表示信任增长度，MD表示不信任增长度，两者的绝对值相等</p></li><li><p>其中由于CF值会有复数个前提条件，因此对于重复结论的CF值的计算如下：</p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/uqtkRyMU2pIslco.png alt=image-20240119150249967></p></li></ul><h2 id=主观bayes方法>主观Bayes方法<a hidden class=anchor aria-hidden=true href=#主观bayes方法>#</a></h2><p>在很多时候同一个事件的结果对应的前提条件是没有可复制性的，此时P（A｜B）就是一个不必要的概率，在主观bayes方法中将其解释为：在证据B的基础上，假设A的似然性</p><ul><li><p>几率函数：$$O(x) = \frac{P(x)}{1 - P(x)}$$</p><p>反过来也可以用已知的几率推出似然性：$$P(x) = \frac{O(x)}{1 + O(x)}$$</p></li><li><p>LS（充分性量度）：</p><p>E为真时，对结论H的支持程度，定义为：$$LS = \frac{P(E|H)}{P(E|¬H)}$$</p><p>LN（必要性量度）：</p><p>¬E为真时，对结论H的支持程度，定义为：$$LN = \frac{P(¬E|H)}{P(¬E|¬H)} = \frac{1 - P(E|H)}{1 - P(E|¬H)}$$</p><p>LS和LN一般由专家给出</p></li></ul><p>主观Bayes方法推理的任务就是根据证据E得概率P（E）以及LS、LN，将H的先验概率更新为后验概率，即P(E) -> P(E|H)或者P(E|¬H)</p><ul><li><p>不确定性的传播与计算：</p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/xtwbvjK7Lf8CEYd.png alt=image-20240119153609099></p><p>由此可以推出EH公式（背就完事了）：</p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/cuAVyUjRFOETKnw.png alt=image-20240119154530621></p><p>在Prospector中引进了可信度的概念，让用户在-5到5这11个可信度中选取一个作为初始可信度C(E|S)，于是在一系列的公式推导之后得出了以下三组公式：</p><p><img loading=lazy src=https://s2.loli.net/2024/01/22/b3BY9RCS6HwaNVy.png alt=image-20240119161341612></p><p>这三组公式视情况使用</p></li></ul><h2 id=传教士与野人过河问题>传教士与野人过河问题<a hidden class=anchor aria-hidden=true href=#传教士与野人过河问题>#</a></h2><p>启发函数为$$h(x) = M + C - K * B$$，其中M为传教士人数、C为野人人数，K为船载人数，B为船只数量（这里为1）</p><h2 id=一元线性回归>一元线性回归<a hidden class=anchor aria-hidden=true href=#一元线性回归>#</a></h2><p>这里使用最小二乘法
$$
L(w,b) = \sum_{i = 1}^{n}{(y_i - \widehat{y_i})^2} = \sum_{i = 1}^{n}{(y_i - wx_i - b)^2}
$$</p><h6 id=分别对w和b求偏导并且让他们等于零即可算出w和b的值>分别对w和b求偏导，并且让他们等于零，即可算出w和b的值<a hidden class=anchor aria-hidden=true href=#分别对w和b求偏导并且让他们等于零即可算出w和b的值>#</a></h6></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/ai/>AI</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/dev/dev-coursesystem/><span class=title>« Prev</span><br><span>第一次全栈开发记录</span>
</a><a class=next href=https://sirius1y.top/posts/notes/notes/operating_system/><span class=title>Next »</span><br><span>操作系统学习笔记</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>