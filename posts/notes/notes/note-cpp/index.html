<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CPP学习笔记 | Sirius' Blog</title>
<meta name=keywords content="cpp"><meta name=description content='C++学习笔记 现在主流的编译型语言包括C、C++、Go、Rust等，它们的编译过程中需要将代码转换成机器语言，因此可以获得更高的执行效率和更好的性能。
而主流的解释型语言包括Python、Ruby、JavaScript等，这些语言需要解释器将代码转换成机器语言并运行，因此相对于编译型语言，它们的执行效率和性能可能会稍低，但是它们通常具有更高的开发效率和更强的灵活性，因为它们可以在运行时动态修改代码。
另外，还有一些语言是即时编译型语言（JIT），例如Java、C#和LuaJIT等，这些语言的编译器会在运行时将代码编译成机器语言，因此它们的执行效率和性能通常比解释型语言要高一些，但比编译型语言略低一些。
函数的声明和定义中，
不能重复定义一个参数的值；
带有默认值的形式参数必须放在参数列表的最右侧;
一、cin 函数的用法 使用cin从标准输入读取数据时，通常用到的方法有cin&#187;，cin.get，cin.getline。
1.1 cin&#187;的用法 （1）cin&#187;等价于cin.operator&#187;()，即调用成员函数operator&#187;()进行读取数据。 （2）当cin&#187;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&#187;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&#187;不做处理。 （3）不想略过空白字符，那就使用 noskipws 流控制。比如cin&#187;noskipws&#187;input;
1.2 cin.get的用法 1.2.1 cin.get读取一个字符 读取一个字符，可以使用cin.get或者cin.get(var)，示例代码如下：
#include <iostream> using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout<<a<<b<<endl; system("pause"); return 0; } 输入：e[回车]，输出： 注意： （1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时打印两次。
（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。
1.2.2 cin.get读取一行 读取一行可以使用istream& get ( char* s, streamsize n )或者istream& get ( char* s, size_t n, streamsize delim )。二者的区别是前者默认以换行符结束，后者可指定结束符。n表示目标空间的大小。示例代码如下：
#include <iostream> using namespace std; int main() { char a; char array[20]={NULL}; cin.'><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/notes/note-cpp/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/notes/note-cpp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="CPP学习笔记"><meta property="og:description" content='C++学习笔记 现在主流的编译型语言包括C、C++、Go、Rust等，它们的编译过程中需要将代码转换成机器语言，因此可以获得更高的执行效率和更好的性能。
而主流的解释型语言包括Python、Ruby、JavaScript等，这些语言需要解释器将代码转换成机器语言并运行，因此相对于编译型语言，它们的执行效率和性能可能会稍低，但是它们通常具有更高的开发效率和更强的灵活性，因为它们可以在运行时动态修改代码。
另外，还有一些语言是即时编译型语言（JIT），例如Java、C#和LuaJIT等，这些语言的编译器会在运行时将代码编译成机器语言，因此它们的执行效率和性能通常比解释型语言要高一些，但比编译型语言略低一些。
函数的声明和定义中，
不能重复定义一个参数的值；
带有默认值的形式参数必须放在参数列表的最右侧;
一、cin 函数的用法 使用cin从标准输入读取数据时，通常用到的方法有cin&#187;，cin.get，cin.getline。
1.1 cin&#187;的用法 （1）cin&#187;等价于cin.operator&#187;()，即调用成员函数operator&#187;()进行读取数据。 （2）当cin&#187;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&#187;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&#187;不做处理。 （3）不想略过空白字符，那就使用 noskipws 流控制。比如cin&#187;noskipws&#187;input;
1.2 cin.get的用法 1.2.1 cin.get读取一个字符 读取一个字符，可以使用cin.get或者cin.get(var)，示例代码如下：
#include <iostream> using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout<<a<<b<<endl; system("pause"); return 0; } 输入：e[回车]，输出： 注意： （1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时打印两次。
（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。
1.2.2 cin.get读取一行 读取一行可以使用istream& get ( char* s, streamsize n )或者istream& get ( char* s, size_t n, streamsize delim )。二者的区别是前者默认以换行符结束，后者可指定结束符。n表示目标空间的大小。示例代码如下：
#include <iostream> using namespace std; int main() { char a; char array[20]={NULL}; cin.'><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/notes/note-cpp/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-19T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-19T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="CPP学习笔记"><meta name=twitter:description content='C++学习笔记 现在主流的编译型语言包括C、C++、Go、Rust等，它们的编译过程中需要将代码转换成机器语言，因此可以获得更高的执行效率和更好的性能。
而主流的解释型语言包括Python、Ruby、JavaScript等，这些语言需要解释器将代码转换成机器语言并运行，因此相对于编译型语言，它们的执行效率和性能可能会稍低，但是它们通常具有更高的开发效率和更强的灵活性，因为它们可以在运行时动态修改代码。
另外，还有一些语言是即时编译型语言（JIT），例如Java、C#和LuaJIT等，这些语言的编译器会在运行时将代码编译成机器语言，因此它们的执行效率和性能通常比解释型语言要高一些，但比编译型语言略低一些。
函数的声明和定义中，
不能重复定义一个参数的值；
带有默认值的形式参数必须放在参数列表的最右侧;
一、cin 函数的用法 使用cin从标准输入读取数据时，通常用到的方法有cin&#187;，cin.get，cin.getline。
1.1 cin&#187;的用法 （1）cin&#187;等价于cin.operator&#187;()，即调用成员函数operator&#187;()进行读取数据。 （2）当cin&#187;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&#187;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&#187;不做处理。 （3）不想略过空白字符，那就使用 noskipws 流控制。比如cin&#187;noskipws&#187;input;
1.2 cin.get的用法 1.2.1 cin.get读取一个字符 读取一个字符，可以使用cin.get或者cin.get(var)，示例代码如下：
#include <iostream> using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout<<a<<b<<endl; system("pause"); return 0; } 输入：e[回车]，输出： 注意： （1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时打印两次。
（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。
1.2.2 cin.get读取一行 读取一行可以使用istream& get ( char* s, streamsize n )或者istream& get ( char* s, size_t n, streamsize delim )。二者的区别是前者默认以换行符结束，后者可指定结束符。n表示目标空间的大小。示例代码如下：
#include <iostream> using namespace std; int main() { char a; char array[20]={NULL}; cin.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"CPP学习笔记","item":"https://sirius1y.top/posts/notes/notes/note-cpp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CPP学习笔记","name":"CPP学习笔记","description":"C++学习笔记 现在主流的编译型语言包括C、C++、Go、Rust等，它们的编译过程中需要将代码转换成机器语言，因此可以获得更高的执行效率和更好的性能。\n而主流的解释型语言包括Python、Ruby、JavaScript等，这些语言需要解释器将代码转换成机器语言并运行，因此相对于编译型语言，它们的执行效率和性能可能会稍低，但是它们通常具有更高的开发效率和更强的灵活性，因为它们可以在运行时动态修改代码。\n另外，还有一些语言是即时编译型语言（JIT），例如Java、C#和LuaJIT等，这些语言的编译器会在运行时将代码编译成机器语言，因此它们的执行效率和性能通常比解释型语言要高一些，但比编译型语言略低一些。\n函数的声明和定义中，\n不能重复定义一个参数的值；\n带有默认值的形式参数必须放在参数列表的最右侧;\n一、cin 函数的用法 使用cin从标准输入读取数据时，通常用到的方法有cin\u0026raquo;，cin.get，cin.getline。\n1.1 cin\u0026raquo;的用法 （1）cin\u0026raquo;等价于cin.operator\u0026raquo;()，即调用成员函数operator\u0026raquo;()进行读取数据。 （2）当cin\u0026raquo;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin\u0026raquo;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin\u0026raquo;不做处理。 （3）不想略过空白字符，那就使用 noskipws 流控制。比如cin\u0026raquo;noskipws\u0026raquo;input;\n1.2 cin.get的用法 1.2.1 cin.get读取一个字符 读取一个字符，可以使用cin.get或者cin.get(var)，示例代码如下：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); return 0; } 输入：e[回车]，输出： 注意： （1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时打印两次。\n（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。\n1.2.2 cin.get读取一行 读取一行可以使用istream\u0026amp; get ( char* s, streamsize n )或者istream\u0026amp; get ( char* s, size_t n, streamsize delim )。二者的区别是前者默认以换行符结束，后者可指定结束符。n表示目标空间的大小。示例代码如下：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a; char array[20]={NULL}; cin.","keywords":["cpp"],"articleBody":"C++学习笔记 现在主流的编译型语言包括C、C++、Go、Rust等，它们的编译过程中需要将代码转换成机器语言，因此可以获得更高的执行效率和更好的性能。\n而主流的解释型语言包括Python、Ruby、JavaScript等，这些语言需要解释器将代码转换成机器语言并运行，因此相对于编译型语言，它们的执行效率和性能可能会稍低，但是它们通常具有更高的开发效率和更强的灵活性，因为它们可以在运行时动态修改代码。\n另外，还有一些语言是即时编译型语言（JIT），例如Java、C#和LuaJIT等，这些语言的编译器会在运行时将代码编译成机器语言，因此它们的执行效率和性能通常比解释型语言要高一些，但比编译型语言略低一些。\n函数的声明和定义中，\n不能重复定义一个参数的值；\n带有默认值的形式参数必须放在参数列表的最右侧;\n一、cin 函数的用法 使用cin从标准输入读取数据时，通常用到的方法有cin»，cin.get，cin.getline。\n1.1 cin»的用法 （1）cin»等价于cin.operator»()，即调用成员函数operator»()进行读取数据。 （2）当cin»从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin»会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin»不做处理。 （3）不想略过空白字符，那就使用 noskipws 流控制。比如cin»noskipws»input;\n1.2 cin.get的用法 1.2.1 cin.get读取一个字符 读取一个字符，可以使用cin.get或者cin.get(var)，示例代码如下：\n#include using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout\u003c\u003ca\u003c\u003cb\u003c\u003cendl; system(\"pause\"); return 0; } 输入：e[回车]，输出： 注意： （1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时打印两次。\n（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。\n1.2.2 cin.get读取一行 读取一行可以使用istream\u0026 get ( char* s, streamsize n )或者istream\u0026 get ( char* s, size_t n, streamsize delim )。二者的区别是前者默认以换行符结束，后者可指定结束符。n表示目标空间的大小。示例代码如下：\n#include using namespace std; int main() { char a; char array[20]={NULL}; cin.get(array,20); cin.get(a); cout\u003c\u003carray\u003c\u003c\" \"\u003c\u003c(int)a\u003c\u003cendl; system(\"pause\"); return 0; } 输入：123456789[回车]，输出： 注意： （1）从结果可以看出，cin.get(array,20);读取一行时，遇到换行符时结束读取，但是不对换行符进行处理，换行符仍然残留在输入缓冲区。第二次由cin.get()将换行符读入变量b，打印输入换行符的ASCII码值为10。这也是cin.get()读取一行与使用getline读取一行的区别所在。getline读取一行字符时，默认遇到’\\n’时终止，并且将’\\n’直接从输入缓冲区中删除掉，不会影响下面的输入处理。\n（2）cin.get(str,size);读取一行时，只能将字符串读入C风格的字符串中，即char*，但是C++的getline函数可以将字符串读入C++风格的字符串中，即string类型。鉴于getline较cin.get()的这两种优点，建议使用getline进行行的读取。关于getline的用法，下文将进行详述。\n1.3 cin.getline读取一行 函数作用：从标准输入设备键盘读取一串字符串，并以指定的结束符结束。 函数原型有两个：\nistream\u0026 getline(char* s, streamsize count); //默认以换行符结束 istream\u0026 getline(char* s, streamsize count, char delim); 使用示例：\n#include using namespace std; int main() { char array[20]={NULL}; cin.getline(array,20); //或者指定结束符，使用下面一行 //cin.getline(array,20,'\\n'); cout\u003c\u003carray\u003c\u003cendl; system(\"pause\"); return 0; } 注意，cin.getline与cin.get的区别是，cin.getline不会将结束符或者换行符残留在输入缓冲区中。\n*我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。*\nvoid Swap1(int* a, int* b); void Swap2(float* a, float* b); void Swap3(char* a, char* b); void Swap4(double* a, double* b); *我们可以看出这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。*\n二、cout函数用法 1、cout\u003c\u003c uppercase \u003c\u003c hex\u003c","wordCount":"1375","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-03-19T00:00:00Z","dateModified":"2022-03-19T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/notes/note-cpp/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">CPP学习笔记</h1><div class=post-meta><span title='2022-03-19 00:00:00 +0000 UTC'>March 19, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1375 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0 aria-label=C++学习笔记>C++学习笔记</a></li><li><a href=#%e4%b8%80cin-%e5%87%bd%e6%95%b0%e7%9a%84%e7%94%a8%e6%b3%95 aria-label="一、cin 函数的用法">一、cin 函数的用法</a><ul><li><a href=#11-cin%e7%9a%84%e7%94%a8%e6%b3%95 aria-label="1.1 cin&amp;raquo;的用法">1.1 cin&#187;的用法</a></li><li><a href=#12-cinget%e7%9a%84%e7%94%a8%e6%b3%95 aria-label="1.2 cin.get的用法">1.2 cin.get的用法</a><ul><li><a href=#121-cinget%e8%af%bb%e5%8f%96%e4%b8%80%e4%b8%aa%e5%ad%97%e7%ac%a6 aria-label="1.2.1 cin.get读取一个字符">1.2.1 cin.get读取一个字符</a></li><li><a href=#122-cinget%e8%af%bb%e5%8f%96%e4%b8%80%e8%a1%8c aria-label="1.2.2 cin.get读取一行">1.2.2 cin.get读取一行</a></li></ul></li><li><a href=#13-cingetline%e8%af%bb%e5%8f%96%e4%b8%80%e8%a1%8c aria-label="1.3 cin.getline读取一行">1.3 cin.getline读取一行</a></li></ul></li><li><a href=#%e4%ba%8ccout%e5%87%bd%e6%95%b0%e7%94%a8%e6%b3%95 aria-label=二、cout函数用法>二、cout函数用法</a></li><li><a href=#%e4%b8%89%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd aria-label=三、函数重载>三、函数重载</a><ul><ul><li><a href=#1%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e5%ae%9a%e4%b9%89 aria-label=1、函数重载定义>1、函数重载定义</a></li><li><a href=#2%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=2、函数重载的作用：>2、函数重载的作用：</a></li></ul></ul></li><li><a href=#%e5%9b%9bconst%e4%bf%ae%e9%a5%b0%e7%ac%a6%e7%ac%94%e8%ae%b0 aria-label=四、const修饰符笔记>四、const修饰符笔记</a><ul><li><a href=#1const-int--a----------%e6%8c%87%e5%90%91%e5%b8%b8%e9%87%8f%e7%9a%84%e6%8c%87%e9%92%88 aria-label="1、const int * a 指向常量的指针">1、<strong>const int * a</strong> 指向常量的指针</a></li><li><a href=#2int-const-a-----------%e5%b8%b8%e6%8c%87%e9%92%88 aria-label="2、*int const a 常指针">2、*<em>int <em>const a</em></em> 常指针</a></li><li><a href=#3%e5%85%b3%e4%ba%8econst%e7%9a%84%e7%82%b9%e6%bb%b4%e8%a1%a5%e5%85%85 aria-label=3、关于const的点滴补充:>3、关于const的点滴补充:</a></li></ul></li><li><a href=#%e5%85%ad%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0 aria-label=六、内联函数>六、内联函数</a><ul><li><a href=#1%e5%ae%9a%e4%b9%89 aria-label=1.定义>1.定义</a></li><li><a href=#2%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95 aria-label=2.使用方法>2.使用方法</a></li><li><a href=#3%e7%90%86%e8%a7%a3 aria-label=3.理解>3.理解</a></li><li><a href=#4%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0 aria-label=4.何时使用内联函数？>4.何时使用内联函数？</a></li></ul></li><li><a href=#%e4%b8%83%e9%80%97%e5%8f%b7%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=七、逗号表达式>七、逗号表达式</a></li><li><a href=#%e5%85%abx64%e5%92%8cx86 aria-label=八、x64和x86>八、x64和x86</a></li><li><a href=#%e4%b9%9d%e6%8c%87%e9%92%88 aria-label=九、指针>九、指针</a><ul><ul><li><a href=#1-char-a aria-label="1 char** a">1 char** a</a></li><li><a href=#2-char-a aria-label="2 char* a[]">2 char* a[]</a></li><li><a href=#3-%e4%b8%a4%e8%80%85%e5%8c%ba%e5%88%ab%e4%b8%8e%e8%81%94%e7%b3%bb aria-label="3 两者区别与联系">3 两者区别与联系</a><ul><li><a href=#31-%e8%b5%8b%e5%80%bc aria-label="3.1 赋值">3.1 赋值</a></li></ul></li></ul></ul></li><li><a href=#%e5%8d%81%e9%93%be%e8%a1%a8 aria-label=十、链表>十、链表</a><ul><li><a href=#1%e7%bb%93%e7%82%b9 aria-label=1.结点>1.结点</a></li><li><a href=#2%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%9b%e5%bb%ba aria-label=2.链表的创建>2.链表的创建</a></li></ul></li><li><a href=#%e5%8d%81%e4%b8%80%e7%b1%bb%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=十一、类的构造函数>十一、类的构造函数</a><ul><li><a href=#1%e9%bb%98%e8%ae%a4%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=1.默认构造函数>1.默认构造函数</a></li><li><a href=#2%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=2.初始化构造函数>2.初始化构造函数</a></li><li><a href=#3%e6%8b%b7%e8%b4%9d%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=3.拷贝构造函数>3.拷贝构造函数</a></li><li><a href=#4%e8%bd%ac%e6%8d%a2%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=4.转换构造函数>4.转换构造函数</a></li></ul></li><li><a href=#%e5%8d%81%e4%ba%8cnew%e7%9a%84%e7%94%a8%e6%b3%95 aria-label=十二、new的用法>十二、new的用法</a></li><li><a href=#%e5%8d%81%e4%b8%89stringcharchar%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label=十三、string、char*、char[]数据类型之间的转换>十三、string、char*、char[]数据类型之间的转换</a><ul><li><a href=#1%e5%86%99%e4%ba%86%e4%b8%80%e4%b8%aa%e6%a1%88%e4%be%8b%e8%af%95%e4%ba%86%e8%af%95 aria-label=1、写了一个案例试了试>1、写了一个案例试了试</a></li><li><a href=#2%e6%80%bb%e7%bb%93 aria-label=2.总结>2.总结</a><ul><li><a href=#string---char aria-label="string -&amp;gt; char[]">string -> char[]</a></li><li><a href=#char---char aria-label="char* -&amp;gt; char[]">char* -> char[]</a></li><li><a href=#string---char-1 aria-label="string -&amp;gt; char*">string -> char*</a></li><li><a href=#char---char-1 aria-label="char[] -&amp;gt; char*">char[] -> char*</a></li><li><a href=#char---string aria-label="char* -&amp;gt; string">char* -> string</a></li><li><a href=#char---string-1 aria-label="char[] -&amp;gt; string">char[] -> string</a></li></ul></li></ul></li><li><a href=#%e5%8d%81%e5%9b%9b%e9%a1%b9%e7%9b%ae%e8%b0%83%e8%af%95%e9%93%be%e8%a1%a8%e7%9a%84%e9%93%be%e8%a1%a8 aria-label=十四、【项目调试】：链表的链表>十四、【项目调试】：链表的链表</a><ul><li><a href=#1%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e7%9a%84%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92 aria-label=1、二维数组的参数传递>1、二维数组的参数传递</a></li><li><a href=#2%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0%e7%9a%84%e5%a3%b0%e6%98%8e aria-label=2、友元函数的声明>2、友元函数的声明</a></li><li><a href=#3%e6%a8%a1%e6%9d%bf%e5%87%bd%e6%95%b0%e7%9a%84%e5%a3%b0%e6%98%8e%e4%b8%8e%e5%ae%9a%e4%b9%89 aria-label=3、模板函数的声明与定义>3、模板函数的声明与定义</a></li><li><a href=#4%e5%9b%a2%e9%98%9f%e7%9a%84%e5%90%88%e4%bd%9c%e6%96%b9%e6%b3%95 aria-label=4、团队的合作方法>4、团队的合作方法</a></li></ul></li><li><a href=#%e5%8d%81%e4%ba%94%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label=十五、运算符重载>十五、运算符重载</a><ul><li><a href=#1%e8%bf%90%e7%ae%97%e7%ac%a6%e5%87%bd%e6%95%b0%e7%9a%84%e8%b0%83%e7%94%a8%e5%bd%a2%e5%bc%8f aria-label=1.运算符函数的调用形式>1.运算符函数的调用形式</a></li><li><a href=#2%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd%e5%87%bd%e6%95%b0%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0 aria-label=2.运算符重载函数：成员函数？友元函数？>2.运算符重载函数：成员函数？友元函数？</a></li><li><a href=#3%e5%af%b9%e4%ba%8e%e5%8d%95%e7%9b%ae%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e9%87%8d%e8%bd%bd aria-label=3.对于单目运算符的重载>3.对于单目运算符的重载</a></li><li><a href=#4%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0 aria-label=4.类型转换函数>4.类型转换函数</a></li></ul></li><li><a href=#%e5%8d%81%e5%85%ad%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b aria-label=十六、枚举类型>十六、枚举类型</a><ul><li><a href=#1enum%e5%92%8cenum-class%e5%8c%ba%e5%88%ab aria-label="1.enum和enum class区别">1.enum和enum class区别</a></li></ul></li><li><a href=#%e5%8d%81%e4%b8%83%e5%ba%93%e5%87%bd%e6%95%b0 aria-label=十七、库函数>十七、库函数</a><ul><li><a href=#1vector%e7%b1%bb aria-label=1、vector类>1、vector类</a><ul><ul><li><a href=#vector-%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label="vector 的创建和初始化"><strong>vector 的创建和初始化</strong></a></li><li><a href=#vector%e7%9a%84%e9%81%8d%e5%8e%86 aria-label=vector的遍历>vector的遍历</a></li><li><a href=#%e5%90%91vector%e6%b7%bb%e5%8a%a0%e5%85%83%e7%b4%a0 aria-label=向vector添加元素><strong>向vector添加元素</strong></a></li><li><a href=#%e4%bb%8evector%e7%a7%bb%e9%99%a4%e5%85%83%e7%b4%a0 aria-label=从vector移除元素><strong>从vector移除元素</strong></a></li><li><a href=#vector%e7%9b%b8%e7%ad%89%e5%88%a4%e6%96%ad%e4%b8%8e%e8%b5%8b%e5%80%bc aria-label=vector相等判断与赋值><strong>vector相等判断与赋值</strong></a></li></ul></li></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=c学习笔记>C++学习笔记<a hidden class=anchor aria-hidden=true href=#c学习笔记>#</a></h1><p>现在主流的编译型语言包括C、C++、Go、Rust等，它们的编译过程中需要将代码转换成机器语言，因此可以获得更高的执行效率和更好的性能。</p><p>而主流的解释型语言包括Python、Ruby、JavaScript等，这些语言需要解释器将代码转换成机器语言并运行，因此相对于编译型语言，它们的执行效率和性能可能会稍低，但是它们通常具有更高的开发效率和更强的灵活性，因为它们可以在运行时动态修改代码。</p><p>另外，还有一些语言是即时编译型语言（JIT），例如Java、C#和LuaJIT等，这些语言的编译器会在运行时将代码编译成机器语言，因此它们的执行效率和性能通常比解释型语言要高一些，但比编译型语言略低一些。</p><p>函数的声明和定义中，</p><p>不能重复定义一个参数的值；</p><p>带有默认值的形式参数必须放在参数列表的最右侧;</p><h1 id=一cin-函数的用法>一、cin 函数的用法<a hidden class=anchor aria-hidden=true href=#一cin-函数的用法>#</a></h1><p>使用cin从标准输入读取数据时，通常用到的方法有cin&#187;，cin.get，cin.getline。</p><h2 id=11-cin的用法>1.1 cin&#187;的用法<a hidden class=anchor aria-hidden=true href=#11-cin的用法>#</a></h2><p>（1）cin&#187;等价于cin.operator&#187;()，即调用成员函数operator&#187;()进行读取数据。
（2）当cin&#187;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&#187;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&#187;不做处理。
（3）不想略过空白字符，那就使用 noskipws 流控制。比如cin&#187;noskipws&#187;input;</p><h2 id=12-cinget的用法>1.2 cin.get的用法<a hidden class=anchor aria-hidden=true href=#12-cinget的用法>#</a></h2><h3 id=121-cinget读取一个字符>1.2.1 cin.get读取一个字符<a hidden class=anchor aria-hidden=true href=#121-cinget读取一个字符>#</a></h3><p>读取一个字符，可以使用cin.get或者cin.get(var)，示例代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>=</span><span class=n>cin</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>a</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输入：e[回车]，输出：
<img loading=lazy src=https://img-blog.csdn.net/20150904213700306 alt=这里写图片描述>
<strong>注意：</strong>
（1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时打印两次。</p><p>（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，<a href=http://lib.csdn.net/base/linux>Linux</a>为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。</p><h3 id=122-cinget读取一行>1.2.2 cin.get读取一行<a hidden class=anchor aria-hidden=true href=#122-cinget读取一行>#</a></h3><p>读取一行可以使用istream& get ( char* s, streamsize n )或者istream& get ( char* s, size_t n, streamsize delim )。二者的区别是前者默认以换行符结束，后者可指定结束符。n表示目标空间的大小。示例代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>array</span><span class=p>[</span><span class=mi>20</span><span class=p>]</span><span class=o>=</span><span class=p>{</span><span class=nb>NULL</span><span class=p>};</span> 
</span></span><span class=line><span class=cl>    <span class=n>cin</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>array</span><span class=p>,</span><span class=mi>20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>array</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>a</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输入：123456789[回车]，输出：
<img loading=lazy src=https://img-blog.csdn.net/20150904213736035 alt=这里写图片描述></p><p><strong>注意：</strong>
（1）从结果可以看出，cin.get(array,20);读取一行时，遇到换行符时结束读取，但是不对换行符进行处理，换行符仍然残留在输入缓冲区。第二次由cin.get()将换行符读入变量b，打印输入换行符的ASCII码值为10。这也是cin.get()读取一行与使用getline读取一行的区别所在。getline读取一行字符时，默认遇到’\n’时终止，并且将’\n’直接从输入缓冲区中删除掉，不会影响下面的输入处理。</p><p>（2）cin.get(str,size);读取一行时，只能将字符串读入C风格的字符串中，即char*，但是C++的getline函数可以将字符串读入C++风格的字符串中，即string类型。鉴于getline较cin.get()的这两种优点，建议使用getline进行行的读取。关于getline的用法，下文将进行详述。</p><h2 id=13-cingetline读取一行>1.3 cin.getline读取一行<a hidden class=anchor aria-hidden=true href=#13-cingetline读取一行>#</a></h2><p>函数作用：从标准输入设备键盘读取一串字符串，并以指定的结束符结束。
函数原型有两个：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>istream</span><span class=o>&amp;</span> <span class=n>getline</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>s</span><span class=p>,</span> <span class=n>streamsize</span> <span class=n>count</span><span class=p>);</span> <span class=c1>//默认以换行符结束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>getline</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>s</span><span class=p>,</span> <span class=n>streamsize</span> <span class=n>count</span><span class=p>,</span> <span class=kt>char</span> <span class=n>delim</span><span class=p>);</span>
</span></span></code></pre></div><p>使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>array</span><span class=p>[</span><span class=mi>20</span><span class=p>]</span><span class=o>=</span><span class=p>{</span><span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span><span class=p>.</span><span class=n>getline</span><span class=p>(</span><span class=n>array</span><span class=p>,</span><span class=mi>20</span><span class=p>);</span> <span class=c1>//或者指定结束符，使用下面一行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//cin.getline(array,20,&#39;\n&#39;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>array</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意，cin.getline与cin.get的区别是，<strong>cin.getline不会将结束符或者换行符残留在输入缓冲区中</strong>。</p><p><em><strong>*我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。*</strong></em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>void Swap1(int* a, int* b);
</span></span><span class=line><span class=cl>void Swap2(float* a, float* b);
</span></span><span class=line><span class=cl>void Swap3(char* a, char* b);
</span></span><span class=line><span class=cl>void Swap4(double* a, double* b);
</span></span></code></pre></div><p><em><strong>*我们可以看出这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。*</strong></em></p><h1 id=二cout函数用法>二、cout函数用法<a hidden class=anchor aria-hidden=true href=#二cout函数用法>#</a></h1><p>1、<code>cout&lt;&lt; uppercase &lt;&lt; hex&lt;&lt;n &lt;&lt;nouppercase&lt;&lt;" " &lt;&lt; uppercase &lt;&lt; n &lt;&lt; "(H) = "</code></p><p>最终第二个n还是用的uppercase大写方式输出。</p><ol start=2><li>头文件#include 中有setw()设置位数，setfill(&lsquo;0&rsquo;)用来设置输出格式</li></ol><h1 id=三函数重载>三、函数重载<a hidden class=anchor aria-hidden=true href=#三函数重载>#</a></h1><h3 id=1函数重载定义>1、函数重载定义<a hidden class=anchor aria-hidden=true href=#1函数重载定义>#</a></h3><p>**<em>*函数重载*<em>是一种特殊情况，C++允许在*<em>同一作用域中声明几个类似的同名函数*</em></em></em>，<strong>这些同名函数的形参列表（参数个数，类型，顺序）必须不同，常用来处理实现功能类似数据类型不同的问题。</strong></p><p><em><strong>*在C++中不仅函数可以重载，运算符也可以重载。例如：*</strong></em></p><p><em><strong>*运算符&#171;,&#187;。既可以做移位运算符，也可以做输出，输入运算符。*</strong></em></p><p><em><strong>*注意：重载函数的参数个数，参数类型或参数顺序三者中必须有一个不同*</strong></em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include&lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>#include&lt;iostream&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>float</span> <span class=n>a</span><span class=p>,</span> <span class=kt>float</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>Add</span><span class=p>(</span><span class=mf>3.5</span><span class=p>,</span> <span class=mf>4.5</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>Add</span><span class=p>(</span><span class=mf>2.22</span><span class=p>,</span> <span class=mf>3.33</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>我们可以看到定义了一个Add函数来求三个不同类型数的和，在调用过程中系统会自动根据其实参的类型不同来实现准确调用。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include&lt;iostream&gt;
</span></span></span><span class=line><span class=cl><span class=cp>#include&lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>max</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>max</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>max</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=n>a</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>max</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>从上边代码可以看出函数重载除了允许函数类型不同以外，换允许参数个数不同。</strong></p><p>**<em>*<strong>函数重载的规则：*</strong></em></p><ul><li><strong>函数名称必须相同。</strong></li><li><strong>参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。</strong></li><li><strong>函数的返回类型可以相同也可以不相同。</strong></li><li><strong>仅仅返回类型不同不足以成为函数的重载。</strong>**
**</li></ul><h3 id=2函数重载的作用>2、函数重载的作用：<a hidden class=anchor aria-hidden=true href=#2函数重载的作用>#</a></h3><p><strong>重载函数通常用来在同一个作用域内 用同一个函数名 命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。</strong></p><p><em><strong>*三、函数重载是一种静态多态：*</strong></em></p><p><strong>（1）多态：用同一个东西表示不同的形态；
（2）多态分为：
静态多态（编译时的多态）；
动态多态（运行时的多态）；
（3）函数重载是一种静态多态；</strong></p><p><em><strong>*四.面试题*</strong></em></p><p><em><strong>*1.C语言中为什么不能支持函数重载？*</strong></em></p><p><em><strong>*<img loading=lazy src="https://img-blog.csdn.net/20180619173607995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaWRhZGFfYmxvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=img>
*</strong></em></p><p><strong><em>*从上图可知****编译器在编译.c文件时****，**只会给函数进行简单的重命名；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错；**</em>*</strong></p><p><em><em><em>*</em>*2.C++中函数重载底层是如何处理的？**</em>*</em>*</p><p><em><em><em>*</em>*<img loading=lazy src="https://img-blog.csdn.net/20180619173625713?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaWRhZGFfYmxvZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=img>
**</em>*</em>*</p><p><em><strong>*在.cpp文件中，虽然两个函数的函数名一样，但是他们在符号表中生成的名称不一样。*</strong></em></p><p>**
*<em>**‘？’表示名称开始，‘？’后边是函数名“@@YA”表示参数表开始，后边的3个字符分别表示返回值类型，两个参数类型。“@Z”表示名称结束。**</em>*
*<em>由于在.cpp文件中，两个函数生成的符号表中的名称不一样，所以是可以编译通过的。*</em>**</p><p><em><strong>*3.C++中能否将一个函数按照C的风格来编译？*</strong></em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;Windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>using</span> <span class=n>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kt>int</span> <span class=nf>Add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>	
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=nf>Add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>可以按照C风格来编译，只需在函数名前加</strong> <strong>extern &ldquo;C&rdquo;</strong> <strong>就可以完成按照C风格来编译</strong></p><h1 id=四const修饰符笔记>四、const修饰符笔记<a hidden class=anchor aria-hidden=true href=#四const修饰符笔记>#</a></h1><h2 id=1const-int--a----------指向常量的指针>1、<strong>const int * a</strong> 指向常量的指针<a hidden class=anchor aria-hidden=true href=#1const-int--a----------指向常量的指针>#</a></h2><p><em>这里const 修饰的是int，而int定义的是一个整值
因此</em>a 所指向的对象 值 不能通过 *a 来修改，但是 可以重新给 a 来赋值，使其指向不同的对象
eg:
const int *a = 0;
const int b = 1;
int c = 1;
a = &amp;b //ok！ 额外：注意不能通过a 来修改 b值
a = &amp;c //ok！ 额外：虽然c本身不是一个常量
*a = 2 //Error！ 为题就在这里，不能修改通过 <em>a 所指向的对象值，最后赋值得对象是c，因此不能通过</em>a 来修改c值。</p><h2 id=2int-const-a-----------常指针>2、*<em>int <em>const a</em></em> 常指针<a hidden class=anchor aria-hidden=true href=#2int-const-a-----------常指针>#</a></h2><p>这里const修饰的是 a ，a代表的是一个指针地址
因此不能赋给a其他的地址值，但可以修改a指向的值
这有点和cont int *a相反的意味，例子就不说了</p><p>3、至于int const *a 和 const int *a 的意义是相同的 他们两个的作用等价</p><p>补充：
4、const int * const a
这个代表a所指向的对象的值以及它的地址本身都不能被改变</p><h2 id=3关于const的点滴补充>3、关于const的点滴补充:<a hidden class=anchor aria-hidden=true href=#3关于const的点滴补充>#</a></h2><p>1、<strong>const 对象的地址只能赋值给指向const 对象的指针</strong></p><p>例如 字符串常量 只能赋值给 const char*, 而不能赋值给char*</p><p>2、指向const 对象的指针可以 被赋 以 一个非const 对象的地址
3、指向const 得指针常被用作函数的形式参数，保证被传递给函数的实际对象在函数得实际对象在函数中不会被修改
4、常量在定义后就不能被修改,所以它必须被初始化。未初始化的常量定义将导致编译错误（上面都是在说明const的问题，所以没有赋值，实际语句中要赋值的）</p><p>const指针既可以指向变量，也可以指向常量；</p><p>而非const指针只能指向非const的值；</p><p>【const对象的地址只能赋值给指向const的指针】</p><h1 id=六内联函数>六、内联函数<a hidden class=anchor aria-hidden=true href=#六内联函数>#</a></h1><h2 id=1定义>1.定义<a hidden class=anchor aria-hidden=true href=#1定义>#</a></h2><p>C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。**这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。</p><h2 id=2使用方法>2.使用方法<a hidden class=anchor aria-hidden=true href=#2使用方法>#</a></h2><p>内联函数在函数定义处编写关键词inline，而并非是在函数声明处，在函数声明处写的inline会被编译器忽略掉。</p><p>因为一般写成内联函数的函数体都很短小，故就直接忽略函数的声明，直接定义函数。</p><h2 id=3理解>3.理解<a hidden class=anchor aria-hidden=true href=#3理解>#</a></h2><p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p><p>如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。</p><p>所以，使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，<strong>所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。</strong></p><h2 id=4何时使用内联函数>4.何时使用内联函数？<a hidden class=anchor aria-hidden=true href=#4何时使用内联函数>#</a></h2><p>内联不是万灵丹，它以代码膨胀（拷贝）为代价，仅仅省区了函数调用的开销，从而提高程序的执行效率。（<strong>开销</strong>指的是参数的压栈、跳转、退栈和返回操作）。</p><ul><li>一方面，如果执行函数体内代码的时间比函数调用的开销大得多，那么inline效率收益会很小。</li><li>另一方面，每一处内联函数的调用都要拷贝代码，使程序的总代码量增大，消耗更多的内存空间。</li></ul><p>以下情况不宜使用内联：</p><ul><li>如果函数体内代码比较长，使用内联将导致可执行代码膨胀过大。</li><li>如果函数体内出现<strong>循环或者其他复杂的控制结构</strong>，那么执行函数体内代码的时间将比函数调用的开销大得多。</li></ul><h1 id=七逗号表达式>七、逗号表达式<a hidden class=anchor aria-hidden=true href=#七逗号表达式>#</a></h1><p>逗号表达式的求解过程是：<strong>先求解表达式1，再求解表达式2。整个逗号表达式的值是表达式2的值</strong></p><p>又如，逗号表达式a=3 * 5，a*4，对此表达式的求解，<a href="https://so.csdn.net/so/search?q=%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1001.2101.3001.7020">赋值运算符</a>的优先级别高于逗号运算符，因此应先求解a=3 * 5，经计算和赋值后得到a的值为15，然后求解a * 4，得60，整个逗号表达式的值为60（a仍为15）。</p><p>逗号表达式无非是把若干个表达式“串联”起来。<strong>即逗号表达式纯粹就是为了在只能写一条表达式的地方写多条表达式而设计的</strong></p><h1 id=八x64和x86>八、x64和x86<a hidden class=anchor aria-hidden=true href=#八x64和x86>#</a></h1><p>x64即是64位编译器，x86是32位编译器</p><p>x86是CPU的架构类型，64是位数，x64：x86-64，x32：x86-32，通俗叫法。</p><p><strong>32位编译器</strong>
char ：1个字节
<em><em>char</em>（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）</em>*
short int : 2个字节
int： 4个字节
unsigned int : 4个字节
float: 4个字节
double: 8个字节
<strong>long: 4个字节</strong>
long long: 8个字节
unsigned long: 4个字节</p><p><strong>64位编译器</strong></p><p>char ：1个字节
<em><em>char</em>(即指针变量): 8个字节</em>*
short int : 2个字节
int： 4个字节
unsigned int : 4个字节
float: 4个字节
double: 8个字节
<strong>long: 8个字节</strong>
long long: 8个字节
unsigned long: 8个字节</p><h1 id=九指针>九、指针<a hidden class=anchor aria-hidden=true href=#九指针>#</a></h1><h3 id=1-char-a>1 char** a<a hidden class=anchor aria-hidden=true href=#1-char-a>#</a></h3><p>在 char** a 语句中，a 是一个指针，这个指针（即指针 a）指向一块内存地址，该内存地址中存储的是 char* 类型的数据。指针的加减运算在这里的体现为：a + 1 表示地址加 8 字节（在 32 位系统中，地址加 4 字节）。</p><p>char* 也是一个指针，用 *a 表示，这个指针（即指针 *a）指向一块内存地址，该内存地址中存储的是 char 类型的数据。指针的加减运算在这里的体现为：(*a) + 1 表示地址加 1 字节。</p><p>说明：</p><ul><li>在 32 位系统中，一个<strong>指针</strong>占用 4 字节（32 位）内存空间；在 64 位系统中，一个<strong>指针</strong>占用 8 字节（64 位）内存空间；</li><li>由于 a 指向一个指针类型（char*），故 a + 1 操作就是对指针类型的地址进行操作，所以 a + 1 表示地址加 8 字节；*a指向一个 char 类型，char 类型占用 1 个字节，故 *a + 1 操作就是对 char 类型的地址进行操作，所以 *a + 1 表示地址加 1 字节。</li></ul><h3 id=2-char-a>2 char* a[]<a hidden class=anchor aria-hidden=true href=#2-char-a>#</a></h3><p>在 char* a[] 中，a 是<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">数组</a>，数组中的元素是指针，这些指针指向 char 类型的数据。</p><p>说明：</p><ul><li>数组里面所有的元素，在内存中都是是连续存放的；</li><li>数组名在 C 语言中做了特殊处理，数组名使用数组所占用的（连续）内存区域的第一个字节的内存地址替代了。例如，数组占用的内存区域是 0x7fff5da3f550 到 0x7fff5da3f5a0，那么数组名 a 就会被替换成首地址 0x7fff5da3f550；</li><li>a+1 表示数组 a 的第二个元素的内存地址，所以 a + 1 是地址加 8 字节（再次说明，因为数组 a 的元素是指针（char*），指针类型占用 8 字节）；</li><li>char* a[10] 表示限定这个数组最多可以存放 10 个指针（char*）元素，也就是说这个数组会占用 10 * 8 = 80 个字节。</li></ul><h3 id=3-两者区别与联系>3 两者区别与联系<a hidden class=anchor aria-hidden=true href=#3-两者区别与联系>#</a></h3><h4 id=31-赋值>3.1 赋值<a hidden class=anchor aria-hidden=true href=#31-赋值>#</a></h4><p>可以使用 char* a[] 给 char** 赋值，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>a</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;hello world&#34;</span><span class=p>,</span> <span class=s>&#34;liitdar&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>**</span> <span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span></code></pre></div><p>但不能使用 char** 给 char* a[] 赋值，因为在 char* a[] 中，a作为数组名，是一个常量，我们不能给常量赋值。</p><h1 id=十链表>十、链表<a hidden class=anchor aria-hidden=true href=#十链表>#</a></h1><h2 id=1结点>1.结点<a hidden class=anchor aria-hidden=true href=#1结点>#</a></h2><p>struct Node
{
int data; // 数据域(虽然这里仅有一个数据，但还是用数据datum的复数形式)
Node *next; // 指针域
};</p><h2 id=2链表的创建>2.链表的创建<a hidden class=anchor aria-hidden=true href=#2链表的创建>#</a></h2><pre tabindex=0><code>Node*&amp; Create(Node* &amp;head, int n, int* array) {
	if (head == NULL)head = new Node{};  //这句语句让我花费了两个小时来调试，栓Q 55555`
	Node* p = head;                    //用一个新的指针p指向head，接下来都对p进行操作，从而保证head始终指向的是链表头`
	for (int i = 1;i &lt; n;i++) {
		if(1==i)p-&gt;data = array[0];
		 Node* pNewNode = new Node;     //创建一个新的结点，之后对其赋值并连接在链表上`
		pNewNode-&gt;data = array[i];     //赋值`
		pNewNode-&gt;next = NULL;         //使新的结点next指向NULL，保证最后一个结点也是指向NULL的`
		p-&gt;next = pNewNode;            //使上一个结点的next指向当前指针pNewHead`
		p = pNewNode;                  //更新上一个结点p`
	}
	return head;
}
</code></pre><h1 id=十一类的构造函数>十一、类的构造函数<a hidden class=anchor aria-hidden=true href=#十一类的构造函数>#</a></h1><pre tabindex=0><code>对于class test{
public:

private:

int a;
int b }来说
</code></pre><h2 id=1默认构造函数>1.默认构造函数<a hidden class=anchor aria-hidden=true href=#1默认构造函数>#</a></h2><p><code>test( ){a=1;b=0;}</code></p><p>在函数调用的时候，就可以直接定义一个test对象，例如 <code>test test_a;</code>即是创建了一个test类的对象test_a</p><h2 id=2初始化构造函数>2.初始化构造函数<a hidden class=anchor aria-hidden=true href=#2初始化构造函数>#</a></h2><p><code>test(int x.int y){a=x;y=b;}</code></p><p>在函数调用的时候可以用括号去给对象赋初值，进行初始化的操作。例如 <code>test test_b(20,,30);</code></p><h2 id=3拷贝构造函数>3.拷贝构造函数<a hidden class=anchor aria-hidden=true href=#3拷贝构造函数>#</a></h2><p>拷贝构造函数就是用已经存在的该类的另外一个对象去创建一个新的对象，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>test</span> <span class=p>(</span><span class=k>const</span> <span class=n>test</span> <span class=o>&amp;</span> <span class=n>test_a</span> <span class=p>){</span><span class=err>`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=p>.</span><span class=n>a</span><span class=o>=</span><span class=n>test__a</span><span class=p>.</span><span class=n>a</span><span class=p>;</span><span class=err>`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=p>.</span><span class=n>b</span><span class=o>=</span><span class=n>test_a</span><span class=p>.</span><span class=n>b</span><span class=p>;}</span>
</span></span></code></pre></div><p>使用的时候就可以，<code>test test_c(test_a);</code></p><h2 id=4转换构造函数>4.转换构造函数<a hidden class=anchor aria-hidden=true href=#4转换构造函数>#</a></h2><p>转换构造函数即是给编译器提供了一个转换数据类型的方法，比如说是复数 类的数据和一个int型的数据相加，转换构造函数就可以将int型数据转换为复数类的对象，再根据定义的函数体进行对应的操作。</p><p>转换构造函数只有一个参数列表</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>test</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>使用的时候 <code>test test_d(2.00);</code></p><h1 id=十二new的用法>十二、new的用法<a hidden class=anchor aria-hidden=true href=#十二new的用法>#</a></h1><p>new的后面写指针所指向的数据类型，告诉计算机要开辟多大的空间</p><pre tabindex=0><code>#include &lt;iostream&gt;
using namespace std;

int example1()
{
  //可以在new后面直接赋值
  int *p = new int(3);
  //也可以单独赋值
  //*p = 3;

  //如果不想使用指针，可以定义一个变量，在new之前用“*”表示new出来的内容
  int q = *new int;
  q = 1;
  cout &lt;&lt; q &lt;&lt; endl;

  return *p;
}

int* example2()
{
  //当new一个数组时，同样用一个指针接住数组的首地址
  int *q = new int[3];
  for(int i=0; i&lt;3; i++)
    q[i] = i;

  return q;
}

struct student
{
  string name;
  int score;
};


student* example3()
{
  //这里是用一个结构体指针接住结构体数组的首地址
  //对于结构体指针，个人认为目前这种赋值方法比较方便
  student *stlist = new student[3]{{&#34;abc&#34;, 90}, {&#34;bac&#34;, 78}, {&#34;ccd&#34;, 93}};

  return stlist;
}

 

int main()
{
  int e1 = example1();
  cout &lt;&lt;&#34;e1: &#34;&lt;&lt; e1 &lt;&lt; endl;

  int *e2 = example2();
  for(int i=0; i&lt;3; i++)
    cout &lt;&lt; e2[i] &lt;&lt; &#34; &#34;;
  cout &lt;&lt; endl;


  student *st1 = example3();

  for(int i=0; i&lt;3; i++)
    cout &lt;&lt; st1[i].name &lt;&lt; &#34; &#34; &lt;&lt; st1[i].score &lt;&lt; endl;

 

  return 0;
}
</code></pre><h1 id=十三stringcharchar数据类型之间的转换>十三、string、char*、char[]数据类型之间的转换<a hidden class=anchor aria-hidden=true href=#十三stringcharchar数据类型之间的转换>#</a></h1><h2 id=1写了一个案例试了试>1、写了一个案例试了试<a hidden class=anchor aria-hidden=true href=#1写了一个案例试了试>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include&lt;iostream&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>string</span> <span class=n>a_str</span> <span class=o>=</span> <span class=s>&#34;我是string类型数据&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>string</span> <span class=n>b_str</span><span class=p>(</span><span class=s>&#34;cdf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>c_star</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>c_star</span> <span class=o>=</span> <span class=s>&#34;我是char*类型数据&#34;</span><span class=p>;</span><span class=c1>//怎么把指针开辟空间和赋值写成一条语句呢？
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>char</span> <span class=n>d_array</span><span class=p>[</span><span class=mi>20</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;我是array类型数据&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>string</span> <span class=n>test_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>test_star</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>test_array</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>string</span> <span class=n>test_string2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>test_star2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>test_array2</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//char* -&gt; string
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_string</span> <span class=o>=</span> <span class=n>c_star</span><span class=p>;</span><span class=c1>//直接赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//char[] -&gt; string
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_string2</span> <span class=o>=</span> <span class=n>d_array</span><span class=p>;</span><span class=c1>//直接赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//string -&gt; char*
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//test_star = a_str;//错误，string到char*不能直接赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_star</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>a_str</span><span class=p>.</span><span class=n>data</span><span class=p>();</span><span class=c1>//由string像char*转换要先强制转换类型为char*，由.data()方法出来的是const char*类型的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_star</span> <span class=o>=</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>a_str</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span><span class=c1>//.c_str()方法用法和.data()方法一样
</span></span></span><span class=line><span class=cl><span class=c1></span>	
</span></span><span class=line><span class=cl>	<span class=c1>//char[] -&gt; char*
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_star2</span> <span class=o>=</span> <span class=n>d_array</span><span class=p>;</span><span class=c1>//直接赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//string -&gt; char[]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//test_array = a_str;//错误，数组类型的数据不能作为左值直接被赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>strcpy</span><span class=p>(</span><span class=n>test_array</span><span class=p>,</span> <span class=n>a_str</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//char* -&gt; char[]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>strcpy</span><span class=p>(</span><span class=n>test_array2</span><span class=p>,</span> <span class=n>c_star</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;string -&gt; char[] array:&#34;</span><span class=o>&lt;&lt;</span><span class=n>test_array</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;char* -&gt; char[] array:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>test_array2</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;string -&gt; char* star:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>test_star</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;char[] -&gt; char* star:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>test_star2</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;char* -&gt; string string:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>test_string</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;char[] -&gt; string string:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>test_string2</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>string -&gt; char[] array:我是string类型数据
char* -&gt; char[] array:我是char*类型数据
string -&gt; char* star:我是string类型数据
char[] -&gt; char* star:我是array类型数据
char* -&gt; string string:我是char*类型数据
char[] -&gt; string string:我是array类型数据
</code></pre><h2 id=2总结>2.总结<a hidden class=anchor aria-hidden=true href=#2总结>#</a></h2><h3 id=string---char>string -> char[]<a hidden class=anchor aria-hidden=true href=#string---char>#</a></h3><p>通过函数strcpy拷贝实现，string部分通过.data()的方法</p><h3 id=char---char>char* -> char[]<a hidden class=anchor aria-hidden=true href=#char---char>#</a></h3><p>也是通过strcpy实现</p><h3 id=string---char-1>string -> char*<a hidden class=anchor aria-hidden=true href=#string---char-1>#</a></h3><p>通过.data()或者.c_str()实现，记得要强制转换为char*</p><h3 id=char---char-1>char[] -> char*<a hidden class=anchor aria-hidden=true href=#char---char-1>#</a></h3><p>直接赋值</p><h3 id=char---string>char* -> string<a hidden class=anchor aria-hidden=true href=#char---string>#</a></h3><p>直接赋值</p><h3 id=char---string-1>char[] -> string<a hidden class=anchor aria-hidden=true href=#char---string-1>#</a></h3><p>直接赋值</p><h1 id=十四项目调试链表的链表>十四、【项目调试】：链表的链表<a hidden class=anchor aria-hidden=true href=#十四项目调试链表的链表>#</a></h1><h2 id=1二维数组的参数传递>1、二维数组的参数传递<a hidden class=anchor aria-hidden=true href=#1二维数组的参数传递>#</a></h2><p>对于二维数组或者更高维数组的参数传递，只能省略一维的大小。</p><p>如二维数组的参数传递应该为：int a[ ][10], 而不应该是int** a</p><p>特别是在模板函数匹配的过程中，二维数组是无法转换成二维数组的，即使强制转换类型之后，在后续的函数操作调用时，也会出现其他无法访问的错误。</p><h2 id=2友元函数的声明>2、友元函数的声明<a hidden class=anchor aria-hidden=true href=#2友元函数的声明>#</a></h2><p>对于在类中声明友元函数的时候，一定要在该类之前，提前声明你的友元函数或者友元类，不然编译器找不到它的&mldr;</p><h2 id=3模板函数的声明与定义>3、模板函数的声明与定义<a hidden class=anchor aria-hidden=true href=#3模板函数的声明与定义>#</a></h2><p>对于函数模板或者类模板中定义的成员函数，一定要把函数的声明和实现的描述放在头文件中！</p><p>如果只在头文件中声明了函数模板原型，在一个CPP文件中描述函数模板实现，当你在另外一个CPP文件中调用该函数模板时候，编译器会出现无法解析外部指令的报错。原因如下：</p><p>CPP采用的是分离式编译，即是说在各个编译单元编译好文件之后，再通过链接器把他们链接为一个整体。当你在一个CPP文件中调用了模板函数并且对他实例化，编译器就会在你所引用的头文件和当前编译单元中去寻找函数是如何实现的，并将它编译。如果没有找到函数的定义，但是声明是对的，会通过编译，等待在下一步链接的时候，期待在其他编译单元中的定义链接过来就可以运行。另一方面，对于函数模板定义所在的CPP文件，因为其所在的编译单元中无人调用该模板，所以并不会实例化，也不会生成相应的在另外一个CPP中需要的模板函数实例化后的函数代码。所以在程序运行调试之后，会报出链接失败的错误提示。</p><p>所以说呢，最好就是把模板函数的声明和定义都放在头文件里面。</p><p>在我调试这个项目的时候，当时没有把模板函数的定义放在头文件里面，所以编译器报出了无法解析外部指令的错误，然后我当时是修改了在模板函数中的定义，把模板去掉，直接就是定义了一个实例化之后的函数：</p><pre tabindex=0><code>Node&lt;int&gt;* LinkList&lt;int&gt;::SearchNode(int date) {
	Node&lt;int&gt;* p = head;
	while (p-&gt;data != date)p = p-&gt;next;
	return p;
}
</code></pre><p>像这样，然后通过了运行</p><p>但是我觉得最好还是把模板函数和模板类中成员函数的声明和定义一起放在头文件里面</p><h2 id=4团队的合作方法>4、团队的合作方法<a hidden class=anchor aria-hidden=true href=#4团队的合作方法>#</a></h2><p>这一次小组合作因为使劲很紧迫，在午饭之后开了个会，从具体的实现功能开始，设计函数功能，设计函数原型，最后大家一起开了个屏幕共享给写完了头文件，就散会了。下午大家根据头文件完成各个函数的定义，最后晚上九点一起联合调试。联合调试的时候写测试函数，下一次应该早点写好测试函数。这次因为数据不知道应该怎么传进去debug了好久，浪费了很多时间，下次也应该把测试函数的编写提上议程。</p><h1 id=十五运算符重载>十五、运算符重载<a hidden class=anchor aria-hidden=true href=#十五运算符重载>#</a></h1><h2 id=1运算符函数的调用形式>1.运算符函数的调用形式<a hidden class=anchor aria-hidden=true href=#1运算符函数的调用形式>#</a></h2><table><thead><tr><th>习惯调用形式</th><th>友元运算符重载函数调用形式</th><th>成员运算符重载函数调用形式</th></tr></thead><tbody><tr><td>a+b</td><td>operator+(a,b)</td><td>a.operator+(b)</td></tr><tr><td>-a</td><td>operator-(a)</td><td>a.operator-()</td></tr><tr><td>a++</td><td>operator++(a,0)</td><td>a.operator++(0)</td></tr></tbody></table><h2 id=2运算符重载函数成员函数友元函数>2.运算符重载函数：成员函数？友元函数？<a hidden class=anchor aria-hidden=true href=#2运算符重载函数成员函数友元函数>#</a></h2><p>一般而言，对于双目运算符，将它重载为友元运算符比重载为成员运算符便于使用。对于单目运算符，则选择成员运算符较好。如果运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则运算符重载必须用友元函数。以下的经验可供参考：</p><ul><li><p>对于<strong>单目运算符</strong>，建议选择<strong>成员函数</strong>。</p></li><li><p>对于运算符“<strong>=</strong>、()、[ ]、->” 只能作为<strong>成员函数</strong>。</p></li><li><p>对于运算符“+=、-=、/=、*=、&=、!=、~=、%=、&#171;=、&#187;=”，建议重载为<strong>成员函数</strong>。</p></li><li><p>对于其他运算符，建议重载为<strong>友元函数</strong>(比如+、 -、* 、 / 、 &#187; 、 &#171;)</p></li></ul><p><strong>小结：单目运算符++、++和 = 和迭代运算符重载为成员函数</strong></p><p><strong>加减乘除插入抽取 重载为友元函数</strong></p><h2 id=3对于单目运算符的重载>3.对于单目运算符的重载<a hidden class=anchor aria-hidden=true href=#3对于单目运算符的重载>#</a></h2><p>对于++，&ndash;（后置）：应该是进行自加或者自减的操作，但是返回的是原来的值。</p><p>对于++，&ndash;（前置）：是直接返回自加或者自减之后的值</p><p>他们都是设计成成员函数进行操作。</p><p>由于前置和后置的运算符的重载在形式上（函数名）都是一样的，所以会在参数列表上有所区别。++或者&ndash;作为后置的时候，会有形式上的参数（int），但是没有具体的形式参数名称。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Time</span> <span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span><span class=c1>//表示后置++
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Time</span> <span class=n>temp</span> <span class=o>=</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span><span class=c1>//++（后置）操作是先进行其他运算后，才会自加，所以先备份然后值返回备份，原来的数据自加就行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>this</span><span class=o>-&gt;</span><span class=n>sec</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>temp</span><span class=p>;</span><span class=c1>//值返回自增前的备份，不能使用引用返回，要是引用返回的话，temp在退出这个函数的时候会释放掉，所以应该采取值返回
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Time</span> <span class=k>operator</span><span class=o>++</span><span class=p>()</span> <span class=p>{</span><span class=c1>//表示前置++
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>sec</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>  <span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Time</span> <span class=k>operator</span><span class=o>--</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>//表示后置--
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Time</span> <span class=n>temp</span> <span class=o>=</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>sec</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>temp</span><span class=p>;</span><span class=c1>// 不能采取引用返回，因为temp的生命周期到这里就结束了
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Time</span> <span class=k>operator</span><span class=o>--</span><span class=p>()</span> <span class=p>{</span>      <span class=c1>//前置--
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>sec</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=4类型转换函数>4.类型转换函数<a hidden class=anchor aria-hidden=true href=#4类型转换函数>#</a></h2><p>函数名称：operator 类型名( ){ 具体转换的实现代码; }</p><p>函数作用：类的对象转换为其他类型的数据</p><p>与转换构造函数的联系：转换构造函数就是把别的数据类型转换为类的对象，而类型转换函数将类的对象转换为其他的数据类型</p><p>在函数名前面不能指定函数类型，函数没有参数。其返回值的类型是由函数名中指定的类型名来确定的。类型转换函数只能作为成员函数，因为转换的主体是本类的对象。不能作为友元函数或普通函数。</p><p>从函数形式可以看到，它与运算符重载函数相似，都是用关键字operator开头，只是被重载的是类型名。double类型经过重载后，除了原有的含义外，还获得新的含义(将一个Complex类对象转换为double类型数据，并指定了转换方法)。这样，编译系统不仅能识别原有的double型数据，而且还会把Complex类对象作为double型数据处理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>RMB</span><span class=o>::</span><span class=k>operator</span> <span class=kt>double</span><span class=p>()</span>		<span class=c1>// 类型转换函数定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>yuan</span> <span class=o>+</span> <span class=n>jiao</span> <span class=o>/</span> <span class=mf>10.0</span> <span class=o>+</span> <span class=n>fen</span> <span class=o>/</span> <span class=mf>100.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=十六枚举类型>十六、枚举类型<a hidden class=anchor aria-hidden=true href=#十六枚举类型>#</a></h1><h2 id=1enum和enum-class区别>1.enum和enum class区别<a hidden class=anchor aria-hidden=true href=#1enum和enum-class区别>#</a></h2><p>enum和enum class最大的区别就是作用域的不同。enum的作用域在一整个文件中都存在，而enum class的作用域尽在花括号之内。这个特性就决定了enum class可以在不同的枚举类中定义相同的枚举常量，而若在enum中这样做会出现编译错误。</p><p>enum中定义的枚举常量，在其之后的代码中可以直接使用，而在enum class中定义则需要加上enum class的类名和作用域限定符。</p><p>关于枚举的一些注意：</p><ol><li>枚举中每个成员(标识符)结束符是“,”而不是”;” 最后一个成员可省略”,”</li><li>初始化时可以赋负数，以后的标识符仍依次加1。</li><li>枚举变量只能取枚举说明结构中的某个标识符常量。</li><li>在外部可以对枚举变量进行赋值，但需要进行类型转换。</li><li>枚举常数可以隐式转换为int，但是int不可以隐式转换为枚举值。</li><li>为枚举中的每个名称分配一个整数值，该值与其在枚举中的顺序相对应。默认情况下，第一个值分配0，下一个值分配1，依次类推，但也可以显示设置枚举名称的值。</li><li>枚举值可以用来作判断比较。</li></ol><h1 id=十七库函数>十七、库函数<a hidden class=anchor aria-hidden=true href=#十七库函数>#</a></h1><h2 id=1vector类>1、vector类<a hidden class=anchor aria-hidden=true href=#1vector类>#</a></h2><p><strong>vector是标准库中常见的一种容器，使用起来非常方便，可以用来代替c++原本的数组。</strong></p><h4 id=vector-的创建和初始化><strong>vector 的创建和初始化</strong><a hidden class=anchor aria-hidden=true href=#vector-的创建和初始化>#</a></h4><p>vector作为存放一串数据的容器，在创建和初始化的时候就要考虑数据类型、数据的个数以及数据的值，并且针对这几个属性就可以有几种不同的初始化方式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>vec2</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>vec3</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=sc>&#39;a&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>vec4</span><span class=p>(</span><span class=n>vec3</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=vector的遍历>vector的遍历<a hidden class=anchor aria-hidden=true href=#vector的遍历>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>vec1</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>vec1</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>循环终止条件是i&lt; vec.size()，这里的size（）会返回vector的大小</p><h4 id=向vector添加元素><strong>向vector添加元素</strong><a hidden class=anchor aria-hidden=true href=#向vector添加元素>#</a></h4><p>empty（）可以判断vector是否为空，而push_back（）每次会添加一个元素到vector的末尾</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vec1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>vec1</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=从vector移除元素><strong>从vector移除元素</strong><a hidden class=anchor aria-hidden=true href=#从vector移除元素>#</a></h4><p>pop_back（）和push_back（）一样，都是<strong>从vector末尾进行尾行操作</strong>。</p><p>pop_back()每次都会移除一个元素。</p><p>需要注意的是，如果vector为空，使用pop_back()将会产生异常结果，因此需要empty（）来确定vector不为空。</p><h4 id=vector相等判断与赋值><strong>vector相等判断与赋值</strong><a hidden class=anchor aria-hidden=true href=#vector相等判断与赋值>#</a></h4><p>vector的赋值会把一个vector所有的元素赋值到另一个vector中，并替代所有元素；</p><p>而vector的相等也是需要逐个元素依次比较并全部相等才算相等。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/notes/data_structure/><span class=title>« Prev</span><br><span>数据结构学习笔记</span>
</a><a class=next href=https://sirius1y.top/posts/notes/network/note-network/><span class=title>Next »</span><br><span>学长的计算机网络笔记</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>