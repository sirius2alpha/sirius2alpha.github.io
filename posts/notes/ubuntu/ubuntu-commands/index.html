<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ubuntu服务器命令小记 | Sirius' Blog</title>
<meta name=keywords content="ubuntu"><meta name=description content="记录ubuntu用作服务器时候的一些常用命令"><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/ubuntu/ubuntu-commands/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/ubuntu/ubuntu-commands/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Ubuntu服务器命令小记"><meta property="og:description" content="记录ubuntu用作服务器时候的一些常用命令"><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/ubuntu/ubuntu-commands/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-20T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Ubuntu服务器命令小记"><meta name=twitter:description content="记录ubuntu用作服务器时候的一些常用命令"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"Ubuntu服务器命令小记","item":"https://sirius1y.top/posts/notes/ubuntu/ubuntu-commands/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ubuntu服务器命令小记","name":"Ubuntu服务器命令小记","description":"记录ubuntu用作服务器时候的一些常用命令","keywords":["ubuntu"],"articleBody":"创建用户 # 新建用户 sudo adduser newuser # 添加到用户组 sudo usermod -aG sudo newuser # 这里-aG选项表示将用户添加到指定组中。sudo是Ubuntu中默认的超级用户组。 查看系统信息 查看CPU信息:\nlscpu: 显示CPU架构信息，如型号、核心数、线程数等。 top 或 htop（需要安装）: 实时显示CPU使用率及其它系统信息。 不得不说htop比top好用太多！\n查看GPU信息 (如果安装了NVIDIA GPU):\nnvidia-smi: 显示NVIDIA GPU的状态，包括使用率、温度、显存使用等。 查看内存信息:\nfree -m: 显示内存使用情况，包括总量、使用中、空闲等，单位为MB。 vmstat: 显示内存统计信息及系统进程、交换、IO等信息。 查看网络信息:\nifconfig（在某些系统中可能需要安装net-tools）: 显示网络接口配置信息。 ip addr: 显示网络接口的IP地址。 netstat（可能需要安装）: 显示网络连接、路由表、接口统计等信息。 nload 或 iftop（需要安装）: 实时监控网络流量和带宽使用。 关闭桌面 如果您的Ubuntu服务器当前运行着GNOME或任何其他图形界面，并且您想要关闭这个图形界面（也就是说，让服务器运行在纯命令行模式），您可以按照以下步骤操作：\n关闭GNOME或图形界面 停止图形界面服务:\n对于使用systemd的系统（如最新版的Ubuntu），您可以使用以下命令停止gdm（GNOME Display Manager）或类似的服务： sudo systemctl stop gdm3 如果您不确定是哪个显示管理器（比如可能是lightdm, sddm等），可以先检查当前运行的显示管理器： systemctl list-units --type=service | grep -E 'gdm|sddm|lightdm|x11' 禁用自动启动:\n如果您不想在每次启动时自动进入图形界面，可以禁用对应的服务： sudo systemctl disable gdm3 再次启用GNOME或图形界面 当您需要再次启用GNOME或其他图形界面时，您可以使用以下命令：\n启动图形界面服务:\n使用以下命令启动显示管理器（这里以gdm3为例）： sudo systemctl start gdm3 启用自动启动:\n如果您希望在下次启动时自动进入图形界面，可以重新启用服务： sudo systemctl enable gdm3 注意事项 停止或禁用图形界面会导致系统仅通过命令行界面可用，确保您熟悉命令行操作。 根据您的具体系统配置和使用的显示管理器，命令可能略有不同。例如，如果您使用的是LightDM，您应该使用lightdm替换命令中的gdm3。 如果您在操作过程中遇到任何问题，请确保能够访问物理服务器或远程管理控制台，以便进行故障排除。 压缩和解压 .tar 文件 # 仅打包，并非压缩 tar -xvf FileName.tar # 解包 tar -cvf FileName.tar DirName # 将DirName和其下所有文件（夹）打包 .gz文件 # .gz gunzip FileName.gz # 解压1 gzip -d FileName.gz # 解压2 gzip FileName # 压缩，只能压缩文件 .tar.gz文件、 .tgz文件 # .tar.gz 和 .tgz tar -zxvf FileName.tar.gz # 解压 tar -zcvf FileName.tar.gz DirName # 将DirName和其下所有文件（夹）压缩 tar -C DesDirName -zxvf FileName.tar.gz # 解压到目标路径 .zip文件 # 感觉.zip占用空间比.tar.gz大 unzip FileName.zip # 解压 zip FileName.zip DirName # 将DirName本身压缩 zip -r FileName.zip DirName # 压缩，递归处理，将指定目录下的所有文件和子目录一并压缩 .rar文件 # mac和linux并没有自带rar，需要去下载 rar x FileName.rar # 解压 rar a FileName.rar DirName # 压缩 对Windows的NTFS硬盘进行写入挂载 执行\nsudo ntfsfix /dev/nvme1n1p4 重新挂载硬盘 就可以进行写入操作了。\n验证：\nmount | grep -i \"on /media/sirius/File\" 是rw就是可以写入，or是只读。\necho 对于echo 单引号变量，就直接进行标准输出；\n对于双引号变量，会对其中的变量进行引用，再标准输出。\n# 对于单引号变量，不对其中的变量进行解释，直接标准输出 yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ abc='hello world' yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ echo $abc hello world yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ def='hello $abc' yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ echo $def hello $abc # 对于双引号变量，会对其中的变量进行引用，再标准输出 yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ def=\"hello $abc\" yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ echo $def hello hello world dpkg 对于包更新 sudo dpkg -i .deb 包卸载 sudo dpkg -r package_name 查询特定包的信息 dpkg -l | grep package_name grep grep 是一个用于在文本文件中搜索指定模式（字符串）的命令行工具。它的名称来自于 “Global Regular Expression Print” 的缩写，这是它最初的主要功能之一，即在文本中查找匹配正则表达式的行并打印出来。grep 在 Unix 和类 Unix 操作系统中广泛使用。\ngrep 的基本用法如下：\ngrep [选项] 模式 [文件] [选项]：用于指定搜索行为的选项，例如 -i（不区分大小写）、-v（反向匹配）、-r（递归搜索目录）、-l（仅显示匹配文件名）等。 模式：要搜索的文本模式或正则表达式。 [文件]：要搜索的文件名列表，如果未提供文件名，则 grep 会从标准输入中读取数据。 例如，要在一个文件 example.txt 中查找包含字符串 “apple” 的所有行，你可以使用以下命令：\ngrep \"apple\" example.txt grep 将输出所有包含 “apple” 的行。\n以下是一些常见的 grep 选项：\n-i：忽略大小写。 -v：反向匹配，只显示不包含模式的行。 在小红书的笔试题中就有用cat和grep输出不包含空行的文本，用到了正则表达式的’^$‘和grep -v\n-r：递归搜索目录中的文件。 -l：仅显示包含模式的文件名，而不显示匹配的行。 grep 是一个非常强大和灵活的文本搜索工具，可以用于各种情况，包括日志分析、数据提取、代码搜索等。它支持正则表达式，因此可以进行高级的模式匹配和搜索操作。\nVim ☆ 命令模式下我们能做什么 ① 移动光标 ② 复制 粘贴 ③ 剪切 粘贴 删除 ④ 撤销与恢复\n命令模式 移动光标到首行或末行（!） 移动光标到首行 =\u003e gg\n移动光标到末行 =\u003e G\n☆ 翻屏 向上 翻屏，按键：ctrl + b （before） 或 PgUp\n向下 翻屏，按键：ctrl + f （after） 或 PgDn\n向上翻半屏，按键：ctrl + u （up）\n向下翻半屏，按键：ctrl + d （down）\n☆ 快速定位光标到指定行（!） 行号 + G，如150G代表快速移动光标到第150行。\n复制/粘贴（!） ① 复制当前行（光标所在那一行）\n按键：yy\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\n② 从当前行开始复制指定的行数，如复制5行，5yy\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\n剪切/删除（!） 在VIM编辑器中，剪切与删除都是dd\n如果剪切了文件，但是没有使用p进行粘贴，就是删除操作\n如果剪切了文件，然后使用p进行粘贴，这就是剪切操作\n① 剪切/删除当前光标所在行\n按键：dd （删除之后下一行上移）\n粘贴：p\n注意：dd 严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。\n② 剪切/删除多行（从当前光标所在行开始计算）\n按键：数字dd\n粘贴：p\n特殊用法：\n③ 剪切/删除光标所在的当前行（光标所在位置）之后的内容，但是删除之后下一行不上移\n按键：D （删除之后当前行会变成空白行）\n撤销/恢复（!） 撤销：u（undo）\n恢复：ctrl + r 恢复（取消）之前的撤销操作【重做，redo】\n末行模式 ☆ 末行模式下我们能做什么\n文件保存、退出、查找与替换、显示行号、paste模式等等\n保存/退出（!） :w =\u003e 代表对当前文件进行保存操作，但是其保存完成后，并没有退出这个文件\n:q =\u003e 代表退出当前正在编辑的文件，但是一定要注意，文件必须先保存，然后才能退出\n:wq =\u003e 代表文件先保存后退出（保存并退出）\n如果一个文件在编辑时没有名字，则可以使用:wq 文件名称，代表把当前正在编辑的文件保存到指定的名称中，然后退出\n:q! =\u003e 代表强制退出但是文件未保存（不建议使用）\n查找/搜索（!） 切换到命令模式，然后输入斜杠/（也是进入末行模式的方式之一）\n进入到末行模式后，输入要查找或搜索的关键词，然后回车\n如果在一个文件中，存在多个满足条件的结果。在搜索结果中切换上/下一个结果：N/n （大写N代表上一个结果，小写n代表next）\n如果需要取消高亮，则需要在末行模式中输入:noh【no highlight】\n文件内容的替换（!） 第一步：首先要进入末行模式（在命令模式下输入冒号:）\n第二步：根据需求替换内容\n① 只替换光标所在这一行的第一个满足条件的结果（只能替换1次）\n:s/要替换的关键词/替换后的关键词 + 回车\n案例：把hello rhel中的 rhel替换为 rhel8\n切换光标到hello rhel这一行\n:s/rhel/rhel8 ② 替换光标所在这一行中的所有满足条件的结果（替换多次，只能替换一行）\n:s/要替换的关键词/替换后的关键词/g\tg=global全局替换\n案例：把hello rhel中的所有rhel都替换为rhel8\n切换光标到hello rhel这一行\n:s/rhel/rhel8/g ③ 针对整个文档中的所有行进行替换，只替换每一行中满足条件的第一个结果\n:%s/要替换的关键词/替换后的关键词\n案例：把每一行中的第一个hello关键词都替换为hi\n:%s/hello/hi ④ 针对整个文档中的所有关键词进行替换（只要满足条件就进行替换操作）\n:%s/要替换的关键词/替换后的关键词/g\n案例：替换整个文档中的hello关键词为hi\n:%s/hello/hi/g 显示行号 基本语法：\n:set nu 【nu = number】，行号 可视化模式 1）如何进入到可视化模式 在命令模式中，直接按ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ← →方向键来选中需要复制的区块，按下y 键进行复制（不要按下yy），最后按下p 键粘贴\n退出可视模式按下Esc\n2）可视化模式复制操作 第一步：在命令模式下，直接按小v，进入可视化模式\n第二步：使用方向键↑ ↓ ← →选择要复制的内容，然后按y键\n第三步：移动光标，停在需要粘贴的位置，按p键进行粘贴操作\n3）为配置文件添加#多行注释（!） 第一步：按Esc退出到命令模式，按gg切换到第1行\n第二步：然后按Ctrl+v进入到可视化区块模式（列模式）\n第三步：在行首使用上下键选择需要注释的多行\n第四步：按下键盘（大写）“I”键，进入插入模式（Shift + i）\n第五步：输入#号注释符\n第六步：输入完成后，连续按两次Esc即可完成添加多行注释的过程\n4）为配置文件去除#多行注释（!） 第一步：按Esc退出到命令模式，按gg切换到第1行\n第二步：然后按Ctrl+v进入可视化区块模式（列模式）\n第三步：使用键盘上的方向键的上下选中需要移除的#号注释\n第四步：直接按Delete键即可完成删除注释的操作\nstrace 通过strace命令可以看见某条指令发起了哪些系统调用。\nstrace -o hello.log ./hello strace -o hello.py.log python3 ./hello.py strace是一个Linux命令，用于跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。\nstrace命令的语法如下：\nstrace [选项] 命令 [参数] 选项说明：\n-a：跟踪所有系统调用，包括不常用的系统调用。 -c：统计每一系统调用的所执行的时间,次数和出错的次数等。 -d：输出strace关于标准错误的调试信息。 -e：指定要跟踪的系统调用。 -f：跟踪由fork调用所产生的子进程。 -o：将输出保存到指定文件中。 -p：跟踪指定PID的进程。 -s：指定输出的行宽。 -t：输出时间戳。 -tt：输出毫秒级别的时间戳。 -T：输出每个系统调用所花费的时间。 -u：跟踪用户空间的地址空间。 -v：输出更详细的信息。 示例：\n跟踪ls命令的系统调用： strace ls 跟踪ls命令的系统调用，包括不常用的系统调用： strace -a ls 跟踪ls命令的系统调用，统计每个系统调用的所执行的时间、次数和出错的次数等： strace -c ls 跟踪ls命令的系统调用，输出到指定文件中： strace -o trace.log ls 跟踪指定PID为100的进程的系统调用： strace -p 100 跟踪用户空间的地址空间： strace -u strace是一个非常强大的工具，可以用于诊断、调试和教学。通过使用strace，可以了解进程是如何与内核进行交互的，从而帮助解决各种问题。\nman man指令是Linux和类Unix操作系统中内置的命令，用于显示命令、实用程序和函数的参考页面。它是一个非常有用的工具，可用于学习和使用这些系统上可用的大量工具。\n要使用man，只需键入man后跟您要了解的命令、实用程序或函数的名称。例如，要了解ls命令，您将键入man ls。\n每个命令的man页面分为几个部分，包括：\nNAME: 命令的名称和简短描述。 SYNOPSIS: 使用命令的语法。 DESCRIPTION: 命令的详细描述，包括其选项和参数。 EXAMPLES: 如何使用命令的示例。 FILES: 命令使用的文件列表。 SEE ALSO: 其他相关命令列表。 sar sar -P all 1 sar是Linux系统上用于收集系统性能数据的命令。它可以收集CPU、内存、磁盘、网络等方面的数据。sar命令的输出可以用于监控系统性能、诊断系统问题、进行性能分析等。\nsar命令的语法如下：\nsar [选项] [间隔] [持续时间] 选项说明：\n-a： 收集所有可用的数据。 -b： 收集块设备的数据。 -c： 收集CPU的数据。 -d： 收集磁盘设备的数据。 -e： 收集内存的数据。 -f： 从指定文件中读取数据。 -i： 收集网络设备的数据。 -n： 指定收集的数据项。 -r： 收集实时数据。 -u： 收集用户空间的数据。 -v： 输出更详细的信息。 -P： 可以加上ALL ，列出各个CPU上的情况 间隔说明：\n间隔以秒为单位，默认为1秒。 持续时间说明：\n持续时间以秒为单位，默认为无限长。 示例：\n收集所有可用的数据，间隔为1秒，持续时间为10秒： sar -a 1 10 收集CPU的数据，间隔为5秒，持续时间为1分钟： sar -c 5 60 收集内存的数据，间隔为1分钟，持续时间为1小时： sar -e 1 3600 收集网络设备的数据，间隔为1小时，持续时间为24小时： sar -i 1 86400 sar命令的输出格式：\nsar命令的输出格式如下：\n时间戳 数据项 值 时间戳以秒为单位，数据项表示收集的数据类型，值表示数据的值。\nsar命令的常用用法：\n监控系统性能：使用sar命令可以监控系统的CPU、内存、磁盘、网络等方面的性能。 诊断系统问题：使用sar命令可以帮助诊断系统性能问题。 进行性能分析：使用sar命令可以进行性能分析，以了解系统的瓶颈。 以下是一些sar命令的常用用法：\n监控CPU使用率： sar -c 监控内存使用率： sar -e 监控磁盘读写速度： sar -d 监控网络流量： sar -i 监控系统负载： sar -u readelf readelf -h /bin/sleep readelf命令是Linux系统上用于显示ELF文件信息的命令。它可以显示ELF文件的文件头、程序头、节头、符号表、重定位表等信息。readelf命令可以用于调试程序、学习ELF文件格式等。\nreadelf命令的语法如下：\nreadelf [选项] 文件 选项说明：\n-a： 显示所有信息。 -h： 显示文件头信息。 -l： 显示程序头信息。 -S： 显示节头信息。 -s： 显示符号表信息。 -r： 显示重定位表信息。 -d： 显示动态链接信息。 -e： 显示所有头信息。 -x： 显示只读数据段。 -z： 显示字符串表。 示例：\n显示可执行文件ls的所有信息： readelf -a ls 显示可执行文件ls的文件头信息： readelf -h ls 显示可执行文件ls的程序头信息： readelf -l ls 显示可执行文件ls的节头信息： readelf -S ls 显示可执行文件ls的符号表信息： readelf -s ls 显示可执行文件ls的重定位表信息： readelf -r ls 显示可执行文件ls的动态链接信息： readelf -d ls readelf命令的输出格式：\nreadelf命令的输出格式取决于指定的选项。\nreadelf命令的常用用法：\n调试程序：使用readelf命令可以查看程序的符号表和重定位表信息，这对于调试程序很有帮助。 学习ELF文件格式：使用readelf命令可以查看ELF文件的所有信息，这对于学习ELF文件格式很有帮助。 以下是一些readelf命令的常用用法：\n查看可执行文件的所有信息： readelf -a 文件 查看可执行文件的文件头信息： readelf -h 文件 查看可执行文件的程序头信息： readelf -l 文件 查看可执行文件的节头信息： readelf -S 文件 查看可执行文件的符号表信息： readelf -s 文件 查看可执行文件的重定位表信息： readelf -r 文件 查看可执行文件的动态链接信息： readelf -d 文件 ps ps命令是Linux系统上用于显示当前系统进程信息的命令。它可以显示进程的PID、进程名称、进程状态、用户、CPU使用率、内存使用率等信息。ps命令可以用于监控系统进程、诊断系统问题、进行性能分析等。\nps命令的语法如下：\nps [选项] 选项说明：\n-a： 显示所有进程。 -u： 显示用户进程。 -x： 显示所有进程，包括守护进程。 -l： 显示详细信息。 -e： 此参数的效果和指定\"A\"参数相同。 -f： 显示完整的命令行。 -o： 指定显示的列。 -pid： 指定进程的PID。 -ppid： 指定进程的父进程的PID。 -sid： 指定进程的会话ID。 -tty： 指定进程的终端。 示例：\n显示所有进程： ps -a 显示用户进程： ps -u 显示所有进程，包括守护进程： ps -x 显示详细信息： ps -l 显示完整的命令行： ps -f 指定显示的列： ps -o pid,ppid,comm,state,pcpu,mem 指定进程的PID： ps -p 1234 指定进程的父进程的PID： ps -ppid 1234 指定进程的会话ID： ps -sid 1234 指定进程的终端： ps -tty /dev/tty1 ps命令的输出格式：\nps命令的输出格式取决于指定的选项。\nps命令的常用用法：\n监控系统进程：使用ps命令可以监控系统进程的状态，以了解系统的运行情况。 诊断系统问题：使用ps命令可以帮助诊断系统问题，例如进程卡死、内存泄漏等。 进行性能分析：使用ps命令可以进行性能分析，以了解系统的瓶颈。 以下是一些ps命令的常用用法：\n查看所有进程： ps -a 查看用户进程： ps -u 查看所有进程，包括守护进程： ps -x 查看详细信息： ps -l 查看完整的命令行： ps -f 查看指定进程的信息： ps -p 1234 查看指定进程的父进程的信息： ps -ppid 1234 查看指定进程的会话ID： ps -sid 1234 查看指定进程的终端： ps -tty /dev/tty1 taskset taskset命令是Linux系统上用于设置进程亲和力的命令。亲和力是指进程运行在哪些CPU上。taskset命令可以用于提高进程的性能或稳定性。\ntaskset命令的语法如下：\ntaskset [选项] 进程ID [CPU列表] 选项说明：\n-c： 指定CPU列表。 # 查看逻辑cpu个数 grep -c processor /proc/cpuinfo -p： 指定进程ID。 -a： 指定所有进程。 示例：\n将进程ID为1234的进程绑定到CPU 0： taskset -c 0 1234 将所有进程绑定到CPU 0： taskset -c 0 -a 将进程ID为1234的进程绑定到CPU 0 和 1： taskset -c 0,1 1234 taskset命令的输出格式：\ntaskset命令没有输出格式。\ntaskset命令的常用用法：\n提高进程的性能：将进程绑定到特定的CPU可以提高进程的性能，因为进程不需要在多个CPU之间切换。 提高进程的稳定性：将进程绑定到特定的CPU可以提高进程的稳定性，因为进程不会与其他进程竞争CPU资源。 以下是一些taskset命令的常用用法：\n将计算密集型进程绑定到特定的CPU： taskset -c 0,1,2,3 ./my_computation_intensive_program 将IO密集型进程绑定到特定的CPU： taskset -c 4,5,6,7 ./my_io_intensive_program 将需要实时响应的进程绑定到特定的CPU： taskset -c 0 ./my_real_time_program 网络命令 ipconfig, ifconfig, ip ipconfig是windows中的命令，linux上是ifconfig，但ip命令比ifconfig更强大，旨在取代ifconfig命令。\nping ping命令是DOS命令，一般用于检测网络是否通畅以及网络连接速度，结果只越大，说明速度越慢。它使用网络层的ICMP协议。\nping [参数选项] [主机名或IP地址] linux\n参数 含义 -c 设置完成要求回应的次数 -i 指定收发信息的间隔时间 -s 设置数据包的大小 -w 在设定的秒后退出 windows\n参数 含义 -t 连续对IP地址执行ping命令，直到用户以键强制中断 -l 指定ping命令的数据长度 -n 执行特定次数的ping命令 netstat netstat 用来查看当前操作系统的网络连接状态、路由表、接口统计等信息，来自于 net-tools 工具包，ss 是 netstat 的升级版。\n参数 含义 -a 显示主机中所有活动的网络连接信息 (包括监听、非监听状态的服务端口) -n 以数字的形式显示相关的主机地址、端口等信息 -p 显示与网络连接相关联的进程号、进程名称信息 (该选项需要 root 权限) -l 显示处于监听 (Listen) 状态的网络连接及端口信息 -t 查看 TCP (Transmission Control Protocol，传输控制协议) 相关的信息 -u 显示 UDP (User Datagram Protocol，用户数据报协议) 协议相关的信息 -r 显示路由表信息 -i 显示网卡列表 -g 显示组播组的关系 -s 显示网络统计信息 常用命令选项：\nnetstat [-anpt] [-anpu] [-anptu] [-anpltu] [-ntlp] ss ss 命令来自于 iproute 包，是 netstat 的升级版本。netstat 通过遍历 /proc 来获取 socket 信息，ss 使用 netlink 与内核 tcp_diag 模块通信获取 socket 信息。 格式：\nss [OPTION]... [FILTER] 参数 含义 -a 显示主机中所有活动的网络连接信息 (包括监听、非监听状态的服务端口) -n 以数字的形式显示相关的主机地址、端口等信息 -p 显示与网络连接相关联的进程号、进程名称信息 (该选项需要 root 权限) -l 显示处于监听 (Listen) 状态的网络连接及端口信息 -t 查看 TCP (Transmission Control Protocol，传输控制协议) 相关的信息 -u 显示 UDP (User Datagram Protocol，用户数据报协议) 协议相关的信息 -x unix sock 相关 -w 裸套接字相关 -e 扩展的信息 -m 内存用量 -o 计时器信息 #显示本地打开的所有端口 ss -l #列出当前 socket 详细信息 ss -s #显示每个进程具体打开的 socket ss -pl #显示所有 tcp socket ss -at #显示所有的 udp socket ss -au #显示所有已建立的 ssh 连接 ss -o state established '( dport = :ssh or sport = :ssh )' #显示所有已建立的HTTP连接 ss -o state established '( dport = :http or sport = :http )' traceroute traceroute 命令可以用于测试从当前主机到目的主机之间经过了哪些网络结点，并显示各个中间结点的连接状态（响应时间）。对于无法响应的结点，连接状态将显示为 “*”，预设数据包大小是 40Bytes，用户可另行设置。如果没有 traceroute 命令可执行 yum -y install traceroute 安装。\n格式：\ntraceroute [参数] [主机|IP] 参数：\n参数 含义 -d 使用 Socket 层级的排错功能 -f 设置第一个检测数据包的存活数值 TTL 的大小 -F 设置勿离断位 -g 设置来源路由网关，最多可设置 8 个 -i 使用指定的网络界面送出数据包 -l I 使用 ICMP 回应取代 UDP 资料信息 -m 设置检测数据包的最大存活数值 TTL 的大小 -n 直接使用 IP 地址而非主机名称 -p 设置 UDP 传输协议的通信端口 -r 忽略普通的 Routing Table，直接将数据包送到远端主机上 -s 设置本地主机送出数据包的 IP 地址 -t 设置检测数据包的 TOS 数值 -v 详细显示指令的执行过程 -w 设置等待远端主机回报的时间 -x 开启或关闭数据包的正确性检验 [root@c7-1 ~]#traceroute 20.0.0.25 traceroute to 20.0.0.25 (20.0.0.25), 30 hops max, 60 byte packets 1 20.0.0.25 (20.0.0.25) 0.942 ms 0.782 ms 0.647 ms #可以看到这两台机器之间没有经过路由，是直连或连着交换机的状态 [root@c7-1 ~]#traceroute www.baidu.com traceroute to www.baidu.com (112.80.248.75), 30 hops max, 60 byte packets 1 gateway (20.0.0.2) 5.900 ms 5.817 ms 5.758 ms 2 * * * 3 * * * 4 * * * ...... nslookup nslookup是一个用于查询域名系统（DNS）以获取有关域名、IP地址和其他DNS记录信息的网络管理命令行工具。\nnslookup 域名 示例：\n[root@c7-1 ~]#nslookup www.baidu.com Server:\t20.0.0.2 Address:\t20.0.0.2#53 Non-authoritative answer: www.baidu.com\tcanonical name = www.a.shifen.com. Name:\twww.a.shifen.com Address: 112.80.248.75 Name:\twww.a.shifen.com Address: 112.80.248.76 [root@c7-1 ~]#nslookup www.google.com Server:\t20.0.0.2 Address:\t20.0.0.2#53 Non-authoritative answer: Name:\twww.google.com Address: 104.244.46.208 Name:\twww.google.com Address: 2001::1f0d:5211 [root@c7-1 ~]#cat /etc/resolv.conf\t#域名解析配置文件 # Generated by NetworkManager # 一行一个 DNS，最多配置三个 DNS，优先使用第一个 DNS 服务器 nameserver 20.0.0.2 [root@c7-1 ~]#cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 112.80.248.75 www.baidu.com #/etc/hosts 文件中记录着一份主机名与 IP 地址的映射关系表，一般用来保存经常需要访问的主机的信息。当访问一个未知的域名时，先查找该文件中是否有相应的映射记录，如果找不到再去向 DNS 服务器查询。 ARP ARP（Address Resolution Protocol，地址解析协议）缓冲区是在计算机或网络设备上维护的一个表格，用于存储 IP 地址与MAC 地址之间的映射关系。ARP 协议用于将目标主机的 IP 地址解析成其对应的 MAC 地址，从而实现数据在网络上的正确传输。\n在一个局域网中，当计算机 A 需要与计算机 B 进行通信时，A 需要知道 B 的 MAC 地址才能正确发送数据包。这时，A 发送一个 ARP 请求广播，询问网络中是否有拥有特定 IP 地址的设备，并且请求对应设备的 MAC 地址。设备 B 收到请求后，会回复一个 ARP 响应，包含其自己的 MAC 地址。一旦 A 收到了 B 的 MAC 地址，它就可以将数据包正确地发送给 B。\nARP 缓冲区（或称为 ARP 表格、ARP 缓存）在这个过程中起到了重要作用。当设备 A 解析了设备 B 的 IP 地址并获取到 B 的 MAC 地址后，它将这个映射关系存储在 ARP 缓冲区中。这样，以后 A 需要与 B 通信时，就无需再次发送 ARP 请求，而是直接从 ARP 缓冲区中获取 B 的 MAC 地址，从而加速通信过程。\narp 命令用于操作主机的 arp 缓冲区，可以用来显示 arp 缓冲区中的所有条目、删除指定的条目或者添加静态的 ip 地址与 MAC 地址对应关系。\n格式：\narp [-vn] [] [-i \u003cif\u003e] [-a] [] \u003c-Display ARP cache arp [-v] [-i \u003cif\u003e] -d [pub] \u003c-Delete ARP entry arp [-vnD] [] [-i \u003cif\u003e] -f [] \u003c-Add entry from file arp [-v] [] [-i \u003cif\u003e] -s [temp] \u003c-Add entry arp [-v] [] [-i \u003cif\u003e] -Ds \u003cif\u003e [netmask ] pub \u003c-''- 参数：\n-a\u003c主机\u003e：\t显示 arp 缓冲区的所有条目 -H\u003c地址类型\u003e：\t指定 arp 指令使用的地址类型 -d\u003c主机\u003e：\t从 arp 缓冲区中删除指定主机的 arp 条目 -D：\t使用指定接口的硬件地址 -e：\t以 Linux 的显示风格显示 arp 缓冲区中的条目 -i\u003c接口\u003e：\t指定要操作 arp 缓冲区的网络接口 -s\u003c主机\u003e：设置指定的主机的 IP 地址与 MAC 地址的静态映射 -n：\t以数字方式显示 arp 缓冲区中的条目 -v：\t显示详细的 arp 缓冲区条目，包括缓冲区条目的统计信息 -f\u003c文件\u003e：\t设置主机的 IP 地址与 MAC 地址的静态映射\n示例：\n#显示 ARP 表 arp -n\t或\tip neigh #ARP 静态绑定 MAC 地址可以防止 ARP 欺骗 arp -s 10.0.0.6 00:0c:29:32:80:38 #删除 arp 缓存条目 arp -d 10.0.0.6 #指定回复的 MAC 地址 arp -i eth0 -Ds 10.0.0.2 eth1 pub FTP FTP（File Transfer Protocol）是一种用于在网络上传输文件的标准协议。你可以使用命令行界面或者专门的 FTP 客户端来测试和使用 FTP 命令。下面是一些基本的 FTP 命令以及如何进行测试：\n连接到 FTP 服务器： 使用以下命令连接到 FTP 服务器，其中 是服务器的地址（域名或 IP 地址）：\nftp 输入该命令后，你将会被要求输入用户名和密码来进行身份验证。\n浏览远程目录： 连接成功后，你可以使用 ls 命令列出远程服务器上的文件和目录。\n切换远程目录： 使用 cd 命令来切换远程服务器上的目录：\ncd 下载文件： 使用 get 命令来下载远程服务器上的文件到本地：\nget 上传文件： 使用 put 命令来上传本地文件到远程服务器：\nput 退出 FTP 会话： 使用 quit 或 bye 命令来退出 FTP 会话：\nquit 请注意，上述命令只是 FTP 命令的一小部分，而实际的 FTP 客户端可能提供更多功能和选项。如果你在终端或命令提示符中直接使用上述命令，确保你已经连接到一个可用的 FTP 服务器，并且你已经登录并有足够的权限进行操作。\nlsof 列出所有打开了的网络文件 [root@ecs-centos-7 ~]# lsof -i COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ntpd 567 ntp 18u IPv4 12657 0t0 UDP localhost:ntp ntpd 567 ntp 22u IPv6 16095 0t0 UDP ecs-centos-7.4-64bit-20200212:ntp dhclient 651 root 6u IPv4 14594 0t0 UDP *:bootpc master 960 root 13u IPv4 15791 0t0 TCP localhost:smtp (LISTEN) master 960 root 14u IPv6 15792 0t0 TCP localhost:smtp (LISTEN) mysqld 1053 mysql 13u IPv6 15147 0t0 TCP *:mysql (LISTEN) sshd 1348 root 3u IPv4 16698 0t0 TCP *:ssh (LISTEN) 列出所有 IPV4/6 网络文件 列出所有已经打开了的 ipv4 网络文件\n[root@ecs-centos-7 ~]# lsof -i 4 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ntpd 567 ntp 16u IPv4 12651 0t0 UDP *:ntp ntpd 567 ntp 18u IPv4 12657 0t0 UDP localhost:ntp ntpd 567 ntp 21u IPv4 16094 0t0 UDP ecs-centos-7.4-64bit-20200212:ntp dhclient 651 root 6u IPv4 14594 0t0 UDP *:bootpc master 960 root 13u IPv4 15791 0t0 TCP localhost:smtp (LISTEN) sshd 1348 root 3u IPv4 16698 0t0 TCP *:ssh (LISTEN) 所有已经打开了的 ipv6 网络文件\n[root@ecs-centos-7 ~]# lsof -i 6 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ntpd 567 ntp 17u IPv6 12652 0t0 UDP *:ntp ntpd 567 ntp 19u IPv6 12658 0t0 UDP localhost:ntp ntpd 567 ntp 22u IPv6 16095 0t0 UDP ecs-centos-7.4-64bit-20200212:ntp master 960 root 14u IPv6 15792 0t0 TCP localhost:smtp (LISTEN) mysqld 1053 mysql 13u IPv6 15147 0t0 TCP *:mysql (LISTEN) sshd 1348 root 4u IPv6 16700 0t0 TCP *:ssh (LISTEN) 列出在指定端口上打开的文件 使用 lsof -i:端口号 可以获得所有在指定端口号上打开的文件\n[root@ecs-centos-7 ~]# lsof -i:22 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME sshd 1348 root 3u IPv4 16698 0t0 TCP *:ssh (LISTEN) sshd 1348 root 4u IPv6 16700 0t0 TCP *:ssh (LISTEN) sshd 27741 root 3u IPv4 458958 0t0 TCP ecs-centos-7.4-64bit-20200212:ssh-\u003e113.118.121.220:42395 (ESTABLISHED) sshd 27819 root 3u IPv4 459250 0t0 TCP ecs-centos-7.4-64bit-20200212:ssh-\u003e113.118.121.220:19807 (ESTABLISHED) sshd 27895 root 3u IPv4 459828 0t0 TCP 上面例子列出了所有在22号端口上打开的文件\n在服务器开发中，经常会部署一个网关或者代理程序，用来和客户端通讯，网关或者代理程序需要开放一个固定的端口供客户端连接用\n如果客户端连接不上网关或者代理程序，我们可以用上述命令检查网关或代理程序的端口是否开启，来排除因为端口关闭了导致连接不上网关的情况\n列出使用了指定协议(TCP/UDP) 的文件 使用 lsof -i TCP/UDP 列出使用了TCP 或 UDP 协议的文件\n[root@cghost8 /home/cgyx]# lsof -i TCP | more COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME sshd 1704 root 3u IPv4 13593 0t0 TCP *:ssh (LISTEN) sshd 1704 root 4u IPv6 13595 0t0 TCP *:ssh (LISTEN) redis-serer 1725 root 4u IPv4 19773 0t0 TCP localhost:6380 (LISTEN) nc 2067 cgyx 4u IPv4 39167 0t0 TCP *:60600 (LISTEN) mysqld 3020 mysql 4u IPv6 5514608 0t0 TCP 192.168.70.10:mysql-\u003e192.168.70.10:37084 (ESTABLISHED) 使用 lsof -i TCP:3306 列出使用了TCP 协议并且端口为3306的文件\n[root@cghost8 /home/cgyx]# lsof -i TCP:3306 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME mysqld 3020 mysql 4u IPv6 5514608 0t0 TCP 192.168.70.10:mysql-\u003e192.168.70.10:37084 (ESTABLISHED) 使用 lsof -i TCP:1-1024 列出使用了TCP协议并且端口范围为 1 到 1024 的文件\n[root@cghost8 /home/cgyx]# lsof -i TCP:1-1024 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME sshd 1704 root 3u IPv4 13593 0t0 TCP *:ssh (LISTEN) sshd 1704 root 4u IPv6 13595 0t0 TCP *:ssh (LISTEN) cupsd 1709 root 12u IPv6 39148 0t0 TCP localhost:ipp (LISTEN) cupsd 1709 root 13u IPv4 39149 0t0 TCP localhost:ipp (LISTEN) smbd 1824 root 35u IPv6 17658 0t0 TCP *:microsoft-ds (LISTEN) smbd 1824 root 36u IPv6 17659 0t0 TCP *:netbios-ssn (LISTEN) smbd 1824 root 37u IPv4 17660 0t0 TCP *:microsoft-ds (LISTEN) smbd 1824 root 38u IPv4 17661 0t0 TCP *:netbios-ssn (LISTEN) 列出指定进程ID打开的文件 进程ID是操作系统进程的唯一标识，以下命令列出了进程ID为 1053 相关的文件, 从结果中可以知道这个进程ID对应的进程是MySQL\n[root@ecs-centos-7 ~]# lsof -p 1053 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME mysqld 1053 mysql cwd DIR 253,1 4096 1055765 /var/lib/mysql mysqld 1053 mysql rtd DIR 253,1 4096 2 / mysqld 1053 mysql txt REG 253,1 251841448 534935 /usr/sbin/mysqld mysqld 1053 mysql mem REG 253,1 209512 659436 /usr/lib64/mysql/plugin/validate_password.so mysqld 1053 mysql 1w REG 253,1 206658 924771 /var/log/mysqld.log mysqld 1053 mysql 2w REG 253,1 206658 924771 /var/log/mysqld.log 上述命令中，-p 选项后面可以指定多个进程ID，每个进程ID之间用逗号分隔，如果想排除掉某个进程打开的文件，可以在该进程ID前面加上 ^符号\nlsof -p 1,2,3,^4 上述命令会列出进程1，进程2，进程3打开的所有文件，同时忽略进程4打开的文件\n杀死指定用户的所有进程 前面介绍了列出指定用户所有打开的文件，我们可以组合 kill 命令一起使用，实现杀死指定用户的所有进程的功能，具体的命令如下\nkill -9 `lsof -t -u tt` 上述命令中，lsof -u tt 是列出tt用户所有打开的文件，加上 -t 选项之后表示结果只列出PID列，也就是进程ID列，其他列都忽略，前面的 kill -9 表示强制结束指定的进程ID\n","wordCount":"2198","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-20T00:00:00Z","dateModified":"2023-12-20T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/ubuntu/ubuntu-commands/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Ubuntu服务器命令小记</h1><div class=post-description>记录ubuntu用作服务器时候的一些常用命令</div><div class=post-meta><span title='2023-12-20 00:00:00 +0000 UTC'>December 20, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2198 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#%e5%88%9b%e5%bb%ba%e7%94%a8%e6%88%b7 aria-label=创建用户>创建用户</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e4%bf%a1%e6%81%af aria-label=查看系统信息>查看系统信息</a></li><li><a href=#%e5%85%b3%e9%97%ad%e6%a1%8c%e9%9d%a2 aria-label=关闭桌面>关闭桌面</a><ul><li><a href=#%e5%85%b3%e9%97%adgnome%e6%88%96%e5%9b%be%e5%bd%a2%e7%95%8c%e9%9d%a2 aria-label=关闭GNOME或图形界面>关闭GNOME或图形界面</a></li><li><a href=#%e5%86%8d%e6%ac%a1%e5%90%af%e7%94%a8gnome%e6%88%96%e5%9b%be%e5%bd%a2%e7%95%8c%e9%9d%a2 aria-label=再次启用GNOME或图形界面>再次启用GNOME或图形界面</a></li><li><a href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label=注意事项>注意事项</a></li></ul></li><li><a href=#%e5%8e%8b%e7%bc%a9%e5%92%8c%e8%a7%a3%e5%8e%8b aria-label=压缩和解压>压缩和解压</a><ul><li><a href=#tar-%e6%96%87%e4%bb%b6 aria-label=".tar 文件">.tar 文件</a></li><li><a href=#gz%e6%96%87%e4%bb%b6 aria-label=.gz文件>.gz文件</a></li><li><a href=#targz%e6%96%87%e4%bb%b6-tgz%e6%96%87%e4%bb%b6 aria-label=".tar.gz文件、 .tgz文件">.tar.gz文件、 .tgz文件</a></li><li><a href=#zip%e6%96%87%e4%bb%b6 aria-label=.zip文件>.zip文件</a></li><li><a href=#rar%e6%96%87%e4%bb%b6 aria-label=.rar文件>.rar文件</a></li></ul></li><li><a href=#%e5%af%b9windows%e7%9a%84ntfs%e7%a1%ac%e7%9b%98%e8%bf%9b%e8%a1%8c%e5%86%99%e5%85%a5%e6%8c%82%e8%bd%bd aria-label=对Windows的NTFS硬盘进行写入挂载>对Windows的NTFS硬盘进行写入挂载</a></li><li><a href=#echo aria-label=echo>echo</a></li><li><a href=#dpkg aria-label=dpkg>dpkg</a><ul><ul><li><a href=#%e5%af%b9%e4%ba%8e%e5%8c%85%e6%9b%b4%e6%96%b0 aria-label=对于包更新>对于包更新</a></li><li><a href=#%e5%8c%85%e5%8d%b8%e8%bd%bd aria-label=包卸载>包卸载</a></li><li><a href=#%e6%9f%a5%e8%af%a2%e7%89%b9%e5%ae%9a%e5%8c%85%e7%9a%84%e4%bf%a1%e6%81%af aria-label=查询特定包的信息>查询特定包的信息</a></li></ul></ul></li><li><a href=#grep aria-label=grep>grep</a></li><li><a href=#vim aria-label=Vim>Vim</a><ul><li><a href=#%e5%91%bd%e4%bb%a4%e6%a8%a1%e5%bc%8f aria-label=命令模式>命令模式</a><ul><li><a href=#%e7%a7%bb%e5%8a%a8%e5%85%89%e6%a0%87%e5%88%b0%e9%a6%96%e8%a1%8c%e6%88%96%e6%9c%ab%e8%a1%8c aria-label=移动光标到首行或末行（!）>移动光标到首行或末行（!）</a></li><li><a href=#%e5%a4%8d%e5%88%b6%e7%b2%98%e8%b4%b4 aria-label=复制/粘贴（!）>复制/粘贴（!）</a></li><li><a href=#%e5%89%aa%e5%88%87%e5%88%a0%e9%99%a4 aria-label=剪切/删除（!）>剪切/删除（!）</a></li><li><a href=#%e6%92%a4%e9%94%80%e6%81%a2%e5%a4%8d aria-label=撤销/恢复（!）>撤销/恢复（!）</a></li></ul></li><li><a href=#%e6%9c%ab%e8%a1%8c%e6%a8%a1%e5%bc%8f aria-label=末行模式>末行模式</a><ul><li><a href=#%e4%bf%9d%e5%ad%98%e9%80%80%e5%87%ba aria-label=保存/退出（!）>保存/退出（!）</a></li><li><a href=#%e6%9f%a5%e6%89%be%e6%90%9c%e7%b4%a2 aria-label=查找/搜索（!）>查找/搜索（!）</a></li><li><a href=#%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9%e7%9a%84%e6%9b%bf%e6%8d%a2 aria-label=文件内容的替换（!）>文件内容的替换（!）</a></li><li><a href=#%e6%98%be%e7%a4%ba%e8%a1%8c%e5%8f%b7 aria-label=显示行号>显示行号</a></li></ul></li><li><a href=#%e5%8f%af%e8%a7%86%e5%8c%96%e6%a8%a1%e5%bc%8f aria-label=可视化模式>可视化模式</a><ul><li><a href=#1%e5%a6%82%e4%bd%95%e8%bf%9b%e5%85%a5%e5%88%b0%e5%8f%af%e8%a7%86%e5%8c%96%e6%a8%a1%e5%bc%8f aria-label=1）如何进入到可视化模式>1）如何进入到可视化模式</a></li><li><a href=#2%e5%8f%af%e8%a7%86%e5%8c%96%e6%a8%a1%e5%bc%8f%e5%a4%8d%e5%88%b6%e6%93%8d%e4%bd%9c aria-label=2）可视化模式复制操作>2）可视化模式复制操作</a></li><li><a href=#3%e4%b8%ba%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e6%b7%bb%e5%8a%a0%e5%a4%9a%e8%a1%8c%e6%b3%a8%e9%87%8a aria-label=3）为配置文件添加#多行注释（!）>3）为配置文件添加#多行注释（!）</a></li><li><a href=#4%e4%b8%ba%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%8e%bb%e9%99%a4%e5%a4%9a%e8%a1%8c%e6%b3%a8%e9%87%8a aria-label=4）为配置文件去除#多行注释（!）>4）为配置文件去除#多行注释（!）</a></li></ul></li></ul></li><li><a href=#strace aria-label=strace>strace</a></li><li><a href=#man aria-label=man>man</a></li><li><a href=#sar aria-label=sar>sar</a></li><li><a href=#readelf aria-label=readelf>readelf</a></li><li><a href=#ps aria-label=ps>ps</a></li><li><a href=#taskset aria-label=taskset>taskset</a></li></ul><li><a href=#%e7%bd%91%e7%bb%9c%e5%91%bd%e4%bb%a4 aria-label=网络命令>网络命令</a><ul><li><a href=#ipconfig-ifconfig-ip aria-label="ipconfig, ifconfig, ip">ipconfig, ifconfig, ip</a></li><li><a href=#ping aria-label=ping>ping</a></li><li><a href=#netstat aria-label=netstat>netstat</a></li><li><a href=#ss aria-label=ss>ss</a></li><li><a href=#traceroute aria-label=traceroute>traceroute</a></li><li><a href=#nslookup aria-label=nslookup>nslookup</a></li><li><a href=#arp aria-label=ARP>ARP</a></li><li><a href=#ftp aria-label=FTP>FTP</a></li><li><a href=#lsof aria-label=lsof>lsof</a><ul><li><a href=#%e5%88%97%e5%87%ba%e6%89%80%e6%9c%89%e6%89%93%e5%bc%80%e4%ba%86%e7%9a%84%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6 aria-label=列出所有打开了的网络文件>列出所有打开了的网络文件</a><ul><li><a href=#%e5%88%97%e5%87%ba%e6%89%80%e6%9c%89-ipv46-%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6 aria-label="列出所有 IPV4/6 网络文件">列出所有 IPV4/6 网络文件</a></li><li><a href=#%e5%88%97%e5%87%ba%e5%9c%a8%e6%8c%87%e5%ae%9a%e7%ab%af%e5%8f%a3%e4%b8%8a%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6 aria-label=列出在指定端口上打开的文件>列出在指定端口上打开的文件</a></li><li><a href=#%e5%88%97%e5%87%ba%e4%bd%bf%e7%94%a8%e4%ba%86%e6%8c%87%e5%ae%9a%e5%8d%8f%e8%ae%aetcpudp-%e7%9a%84%e6%96%87%e4%bb%b6 aria-label="列出使用了指定协议(TCP/UDP) 的文件">列出使用了指定协议(TCP/UDP) 的文件</a></li></ul></li><li><a href=#%e5%88%97%e5%87%ba%e6%8c%87%e5%ae%9a%e8%bf%9b%e7%a8%8bid%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6 aria-label=列出指定进程ID打开的文件>列出指定进程ID打开的文件</a></li><li><a href=#%e6%9d%80%e6%ad%bb%e6%8c%87%e5%ae%9a%e7%94%a8%e6%88%b7%e7%9a%84%e6%89%80%e6%9c%89%e8%bf%9b%e7%a8%8b aria-label=杀死指定用户的所有进程>杀死指定用户的所有进程</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=创建用户>创建用户<a hidden class=anchor aria-hidden=true href=#创建用户>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 新建用户</span>
</span></span><span class=line><span class=cl>sudo adduser newuser
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 添加到用户组</span>
</span></span><span class=line><span class=cl>sudo usermod -aG sudo newuser
</span></span><span class=line><span class=cl><span class=c1># 这里-aG选项表示将用户添加到指定组中。sudo是Ubuntu中默认的超级用户组。</span>
</span></span></code></pre></div><h2 id=查看系统信息>查看系统信息<a hidden class=anchor aria-hidden=true href=#查看系统信息>#</a></h2><ul><li><p><strong>查看CPU信息</strong>:</p><ul><li><code>lscpu</code>: 显示CPU架构信息，如型号、核心数、线程数等。</li><li><code>top</code> 或 <code>htop</code>（需要安装）: 实时显示CPU使用率及其它系统信息。</li></ul><p><strong>不得不说htop比top好用太多！</strong></p></li><li><p><strong>查看GPU信息</strong> (如果安装了NVIDIA GPU):</p><ul><li><code>nvidia-smi</code>: 显示NVIDIA GPU的状态，包括使用率、温度、显存使用等。</li></ul></li><li><p><strong>查看内存信息</strong>:</p><ul><li><code>free -m</code>: 显示内存使用情况，包括总量、使用中、空闲等，单位为MB。</li><li><code>vmstat</code>: 显示内存统计信息及系统进程、交换、IO等信息。</li></ul></li><li><p><strong>查看网络信息</strong>:</p><ul><li><code>ifconfig</code>（在某些系统中可能需要安装<code>net-tools</code>）: 显示网络接口配置信息。</li><li><code>ip addr</code>: 显示网络接口的IP地址。</li><li><code>netstat</code>（可能需要安装）: 显示网络连接、路由表、接口统计等信息。</li><li><code>nload</code> 或 <code>iftop</code>（需要安装）: 实时监控网络流量和带宽使用。</li></ul></li></ul><h2 id=关闭桌面>关闭桌面<a hidden class=anchor aria-hidden=true href=#关闭桌面>#</a></h2><p>如果您的Ubuntu服务器当前运行着GNOME或任何其他图形界面，并且您想要关闭这个图形界面（也就是说，让服务器运行在纯命令行模式），您可以按照以下步骤操作：</p><h3 id=关闭gnome或图形界面>关闭GNOME或图形界面<a hidden class=anchor aria-hidden=true href=#关闭gnome或图形界面>#</a></h3><ol><li><p><strong>停止图形界面服务</strong>:</p><ul><li>对于使用<code>systemd</code>的系统（如最新版的Ubuntu），您可以使用以下命令停止<code>gdm</code>（GNOME Display Manager）或类似的服务：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl stop gdm3
</span></span></code></pre></div></li><li>如果您不确定是哪个显示管理器（比如可能是<code>lightdm</code>, <code>sddm</code>等），可以先检查当前运行的显示管理器：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemctl list-units --type<span class=o>=</span>service <span class=p>|</span> grep -E <span class=s1>&#39;gdm|sddm|lightdm|x11&#39;</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>禁用自动启动</strong>:</p><ul><li>如果您不想在每次启动时自动进入图形界面，可以禁用对应的服务：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl disable gdm3
</span></span></code></pre></div></li></ul></li></ol><h3 id=再次启用gnome或图形界面>再次启用GNOME或图形界面<a hidden class=anchor aria-hidden=true href=#再次启用gnome或图形界面>#</a></h3><p>当您需要再次启用GNOME或其他图形界面时，您可以使用以下命令：</p><ol><li><p><strong>启动图形界面服务</strong>:</p><ul><li>使用以下命令启动显示管理器（这里以<code>gdm3</code>为例）：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl start gdm3
</span></span></code></pre></div></li></ul></li><li><p><strong>启用自动启动</strong>:</p><ul><li>如果您希望在下次启动时自动进入图形界面，可以重新启用服务：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> gdm3
</span></span></code></pre></div></li></ul></li></ol><h3 id=注意事项>注意事项<a hidden class=anchor aria-hidden=true href=#注意事项>#</a></h3><ul><li>停止或禁用图形界面会导致系统仅通过命令行界面可用，确保您熟悉命令行操作。</li><li>根据您的具体系统配置和使用的显示管理器，命令可能略有不同。例如，如果您使用的是LightDM，您应该使用<code>lightdm</code>替换命令中的<code>gdm3</code>。</li><li>如果您在操作过程中遇到任何问题，请确保能够访问物理服务器或远程管理控制台，以便进行故障排除。</li></ul><h2 id=压缩和解压>压缩和解压<a hidden class=anchor aria-hidden=true href=#压缩和解压>#</a></h2><h3 id=tar-文件>.tar 文件<a hidden class=anchor aria-hidden=true href=#tar-文件>#</a></h3><pre tabindex=0><code># 仅打包，并非压缩

tar -xvf FileName.tar         # 解包
tar -cvf FileName.tar DirName # 将DirName和其下所有文件（夹）打包
</code></pre><h3 id=gz文件>.gz文件<a hidden class=anchor aria-hidden=true href=#gz文件>#</a></h3><pre tabindex=0><code># .gz
gunzip FileName.gz  # 解压1
gzip -d FileName.gz # 解压2
gzip FileName       # 压缩，只能压缩文件
</code></pre><h3 id=targz文件-tgz文件>.tar.gz文件、 .tgz文件<a hidden class=anchor aria-hidden=true href=#targz文件-tgz文件>#</a></h3><pre tabindex=0><code># .tar.gz 和 .tgz
tar -zxvf FileName.tar.gz               # 解压
tar -zcvf FileName.tar.gz DirName       # 将DirName和其下所有文件（夹）压缩
tar -C DesDirName -zxvf FileName.tar.gz # 解压到目标路径
</code></pre><h3 id=zip文件>.zip文件<a hidden class=anchor aria-hidden=true href=#zip文件>#</a></h3><pre tabindex=0><code># 感觉.zip占用空间比.tar.gz大
unzip FileName.zip          # 解压
zip FileName.zip DirName    # 将DirName本身压缩
zip -r FileName.zip DirName # 压缩，递归处理，将指定目录下的所有文件和子目录一并压缩
</code></pre><h3 id=rar文件>.rar文件<a hidden class=anchor aria-hidden=true href=#rar文件>#</a></h3><pre tabindex=0><code># mac和linux并没有自带rar，需要去下载
rar x FileName.rar      # 解压
rar a FileName.rar DirName # 压缩
</code></pre><h2 id=对windows的ntfs硬盘进行写入挂载>对Windows的NTFS硬盘进行写入挂载<a hidden class=anchor aria-hidden=true href=#对windows的ntfs硬盘进行写入挂载>#</a></h2><p>执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-SHELL data-lang=SHELL><span class=line><span class=cl>sudo ntfsfix /dev/nvme1n1p4
</span></span></code></pre></div><p>重新挂载硬盘
就可以进行写入操作了。</p><p>验证：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mount <span class=p>|</span> grep -i <span class=s2>&#34;on /media/sirius/File&#34;</span>
</span></span></code></pre></div><p>是rw就是可以写入，or是只读。</p><h2 id=echo>echo<a hidden class=anchor aria-hidden=true href=#echo>#</a></h2><p>对于echo 单引号变量，就直接进行标准输出；</p><p>对于双引号变量，会对其中的变量进行引用，再标准输出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 对于单引号变量，不对其中的变量进行解释，直接标准输出</span>
</span></span><span class=line><span class=cl>yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ <span class=nv>abc</span><span class=o>=</span><span class=s1>&#39;hello world&#39;</span>
</span></span><span class=line><span class=cl>yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ <span class=nb>echo</span> <span class=nv>$abc</span>
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ <span class=nv>def</span><span class=o>=</span><span class=s1>&#39;hello $abc&#39;</span>
</span></span><span class=line><span class=cl>yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ <span class=nb>echo</span> <span class=nv>$def</span>
</span></span><span class=line><span class=cl>hello <span class=nv>$abc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 对于双引号变量，会对其中的变量进行引用，再标准输出</span>
</span></span><span class=line><span class=cl>yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ <span class=nv>def</span><span class=o>=</span><span class=s2>&#34;hello </span><span class=nv>$abc</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>yoho@yoho-Lenovo-XiaoXinPro-16IHU-2021:~$ <span class=nb>echo</span> <span class=nv>$def</span>
</span></span><span class=line><span class=cl>hello hello world
</span></span></code></pre></div><h2 id=dpkg>dpkg<a hidden class=anchor aria-hidden=true href=#dpkg>#</a></h2><h4 id=对于包更新>对于包更新<a hidden class=anchor aria-hidden=true href=#对于包更新>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo dpkg -i &lt;package_name&gt;.deb
</span></span></code></pre></div><h4 id=包卸载>包卸载<a hidden class=anchor aria-hidden=true href=#包卸载>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo dpkg -r package_name
</span></span></code></pre></div><h4 id=查询特定包的信息>查询特定包的信息<a hidden class=anchor aria-hidden=true href=#查询特定包的信息>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>dpkg -l <span class=p>|</span> grep package_name
</span></span></code></pre></div><h2 id=grep>grep<a hidden class=anchor aria-hidden=true href=#grep>#</a></h2><p><code>grep</code> 是一个用于在文本文件中搜索指定模式（字符串）的命令行工具。它的名称来自于 &ldquo;Global Regular Expression Print&rdquo; 的缩写，这是它最初的主要功能之一，即在文本中查找匹配正则表达式的行并打印出来。<code>grep</code> 在 Unix 和类 Unix 操作系统中广泛使用。</p><p><code>grep</code> 的基本用法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>grep <span class=o>[</span>选项<span class=o>]</span> 模式 <span class=o>[</span>文件<span class=o>]</span>
</span></span></code></pre></div><ul><li><code>[选项]</code>：用于指定搜索行为的选项，例如 <code>-i</code>（不区分大小写）、<code>-v</code>（反向匹配）、<code>-r</code>（递归搜索目录）、<code>-l</code>（仅显示匹配文件名）等。</li><li><code>模式</code>：要搜索的文本模式或正则表达式。</li><li><code>[文件]</code>：要搜索的文件名列表，如果未提供文件名，则 <code>grep</code> 会从标准输入中读取数据。</li></ul><p>例如，要在一个文件 <code>example.txt</code> 中查找包含字符串 &ldquo;apple&rdquo; 的所有行，你可以使用以下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>grep <span class=s2>&#34;apple&#34;</span> example.txt
</span></span></code></pre></div><p><code>grep</code> 将输出所有包含 &ldquo;apple&rdquo; 的行。</p><p>以下是一些常见的 <code>grep</code> 选项：</p><ul><li><code>-i</code>：忽略大小写。</li><li><code>-v</code>：<strong>反向匹配</strong>，只显示不包含模式的行。</li></ul><blockquote><p>在小红书的笔试题中就有用cat和grep输出不包含空行的文本，用到了正则表达式的&rsquo;^$&lsquo;和grep -v</p></blockquote><ul><li><code>-r</code>：递归搜索目录中的文件。</li><li><code>-l</code>：仅显示包含模式的文件名，而不显示匹配的行。</li></ul><p><code>grep</code> 是一个非常强大和灵活的文本搜索工具，可以用于各种情况，包括日志分析、数据提取、代码搜索等。它支持正则表达式，因此可以进行高级的模式匹配和搜索操作。</p><h2 id=vim>Vim<a hidden class=anchor aria-hidden=true href=#vim>#</a></h2><p>☆ 命令模式下我们能做什么
<strong>① 移动光标 ② 复制 粘贴 ③ 剪切 粘贴 删除 ④ 撤销与恢复</strong></p><h3 id=命令模式>命令模式<a hidden class=anchor aria-hidden=true href=#命令模式>#</a></h3><h4 id=移动光标到首行或末行>移动光标到首行或末行（!）<a hidden class=anchor aria-hidden=true href=#移动光标到首行或末行>#</a></h4><p><strong>移动光标到首行 => gg</strong></p><p><strong>移动光标到末行 => G</strong></p><p>☆ 翻屏
向上 翻屏，按键：ctrl + b （before） 或 PgUp</p><p>向下 翻屏，按键：ctrl + f （after） 或 PgDn</p><p>向上翻半屏，按键：ctrl + u （up）</p><p>向下翻半屏，按键：ctrl + d （down）</p><p>☆ 快速定位光标到指定行（!）
行号 + G，如150G代表快速移动光标到第150行。</p><h4 id=复制粘贴>复制/粘贴（!）<a hidden class=anchor aria-hidden=true href=#复制粘贴>#</a></h4><p>① 复制当前行（光标所在那一行）</p><p><strong>按键：yy</strong></p><p>粘贴：在想要粘贴的地方<strong>按下p 键</strong>【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键</p><p>② 从当前行开始复制指定的行数，如复制5行，5yy</p><p>粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键</p><h4 id=剪切删除>剪切/删除（!）<a hidden class=anchor aria-hidden=true href=#剪切删除>#</a></h4><p>在VIM编辑器中，剪切与删除都是dd</p><p>如果剪切了文件，但是没有使用p进行粘贴，就是删除操作</p><p>如果剪切了文件，然后使用p进行粘贴，这就是剪切操作</p><p>① 剪切/删除当前光标所在行</p><p><strong>按键：dd （删除之后下一行上移）</strong></p><p><strong>粘贴：p</strong></p><p>注意：dd 严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。</p><p>② 剪切/删除多行（从当前光标所在行开始计算）</p><p>按键：数字dd</p><p>粘贴：p</p><p>特殊用法：</p><p>③ 剪切/删除光标所在的当前行（光标所在位置）之后的内容，但是删除之后下一行不上移</p><p>按键：D （删除之后当前行会变成空白行）</p><h4 id=撤销恢复>撤销/恢复（!）<a hidden class=anchor aria-hidden=true href=#撤销恢复>#</a></h4><p><strong>撤销：u（undo）</strong></p><p><strong>恢复：ctrl + r</strong> 恢复（取消）之前的撤销操作【重做，redo】</p><h3 id=末行模式>末行模式<a hidden class=anchor aria-hidden=true href=#末行模式>#</a></h3><p>☆ 末行模式下我们能做什么</p><p>文件保存、退出、查找与替换、显示行号、paste模式等等</p><h4 id=保存退出>保存/退出（!）<a hidden class=anchor aria-hidden=true href=#保存退出>#</a></h4><p>:w => 代表对当前文件进行保存操作，但是其保存完成后，并没有退出这个文件</p><p>:q => 代表退出当前正在编辑的文件，但是一定要注意，文件必须先保存，然后才能退出</p><p>:wq => 代表文件先保存后退出（保存并退出）</p><p>如果一个文件在编辑时没有名字，则可以使用:wq 文件名称，代表把当前正在编辑的文件保存到指定的名称中，然后退出</p><p>:q! => 代表强制退出但是文件未保存（不建议使用）</p><h4 id=查找搜索>查找/搜索（!）<a hidden class=anchor aria-hidden=true href=#查找搜索>#</a></h4><p>切换到命令模式，然后<strong>输入斜杠/（也是进入末行模式的方式之一）</strong></p><p><strong>进入到末行模式后，输入要查找或搜索的关键词，然后回车</strong></p><p>如果在一个文件中，存在多个满足条件的结果。<strong>在搜索结果中切换上/下一个结果：N/n （大写N代表上一个结果，小写n代表next）</strong></p><p>如果需要取消高亮，则需要在末行模式中输入:noh【no highlight】</p><h4 id=文件内容的替换>文件内容的替换（!）<a hidden class=anchor aria-hidden=true href=#文件内容的替换>#</a></h4><p>第一步：首先要进入末行模式（在命令模式下输入冒号:）</p><p>第二步：根据需求替换内容</p><p><strong>① 只替换光标所在这一行的第一个满足条件的结果（只能替换1次）</strong></p><p><strong>:s/要替换的关键词/替换后的关键词 + 回车</strong></p><p>案例：把hello rhel中的 rhel替换为 rhel8</p><p>切换光标到hello rhel这一行</p><pre tabindex=0><code>:s/rhel/rhel8
</code></pre><p><strong>② 替换光标所在这一行中的所有满足条件的结果（替换多次，只能替换一行）</strong></p><p><strong>:s/要替换的关键词/替换后的关键词/g</strong> g=global全局替换</p><p>案例：把hello rhel中的所有rhel都替换为rhel8</p><p>切换光标到hello rhel这一行</p><pre tabindex=0><code>:s/rhel/rhel8/g
</code></pre><p><strong>③ 针对整个文档中的所有行进行替换，只替换每一行中满足条件的第一个结果</strong></p><p><strong>:%s/要替换的关键词/替换后的关键词</strong></p><p>案例：把每一行中的第一个hello关键词都替换为hi</p><pre tabindex=0><code>:%s/hello/hi
</code></pre><p><strong>④ 针对整个文档中的所有关键词进行替换（只要满足条件就进行替换操作）</strong></p><p><strong>:%s/要替换的关键词/替换后的关键词/g</strong></p><p>案例：替换整个文档中的hello关键词为hi</p><pre tabindex=0><code>:%s/hello/hi/g
</code></pre><h4 id=显示行号>显示行号<a hidden class=anchor aria-hidden=true href=#显示行号>#</a></h4><p>基本语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=err>:</span><span class=nb>set </span><span class=n>nu</span>
</span></span><span class=line><span class=cl><span class=err>【</span><span class=n>nu</span> <span class=p>=</span> <span class=n>number</span><span class=err>】，</span><span class=n>行号</span>
</span></span></code></pre></div><h3 id=可视化模式>可视化模式<a hidden class=anchor aria-hidden=true href=#可视化模式>#</a></h3><h4 id=1如何进入到可视化模式>1）如何进入到可视化模式<a hidden class=anchor aria-hidden=true href=#1如何进入到可视化模式>#</a></h4><p>在命令模式中，直接按ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ← →方向键来选中需要复制的区块，<strong>按下y 键进行复制（不要按下yy），最后按下p 键粘贴</strong></p><p>退出可视模式按下Esc</p><h4 id=2可视化模式复制操作>2）可视化模式复制操作<a hidden class=anchor aria-hidden=true href=#2可视化模式复制操作>#</a></h4><p>第一步：在命令模式下，直接按小v，进入可视化模式</p><p>第二步：使用方向键↑ ↓ ← →选择要复制的内容，然后按y键</p><p>第三步：移动光标，停在需要粘贴的位置，按p键进行粘贴操作</p><h4 id=3为配置文件添加多行注释>3）为配置文件添加#多行注释（!）<a hidden class=anchor aria-hidden=true href=#3为配置文件添加多行注释>#</a></h4><p>第一步：按Esc退出到命令模式，按gg切换到第1行</p><p>第二步：然后按Ctrl+v进入到可视化区块模式（列模式）</p><p>第三步：在行首使用上下键选择需要注释的多行</p><p>第四步：按下键盘（大写）“I”键，进入插入模式（Shift + i）</p><p>第五步：输入#号注释符</p><p>第六步：输入完成后，连续按两次Esc即可完成添加多行注释的过程</p><h4 id=4为配置文件去除多行注释>4）为配置文件去除#多行注释（!）<a hidden class=anchor aria-hidden=true href=#4为配置文件去除多行注释>#</a></h4><p>第一步：按Esc退出到命令模式，按gg切换到第1行</p><p>第二步：然后按Ctrl+v进入可视化区块模式（列模式）</p><p>第三步：使用键盘上的方向键的上下选中需要移除的#号注释</p><p>第四步：直接按Delete键即可完成删除注释的操作</p><h2 id=strace>strace<a hidden class=anchor aria-hidden=true href=#strace>#</a></h2><p>通过strace命令可以看见某条指令发起了哪些系统调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>strace -o hello.log ./hello
</span></span><span class=line><span class=cl>strace -o hello.py.log python3 ./hello.py
</span></span></code></pre></div><p>strace是一个Linux命令，用于<strong>跟踪进程执行时的系统调用和所接收的信号</strong>。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><p>strace命令的语法如下：</p><pre tabindex=0><code>strace [选项] 命令 [参数]
</code></pre><p><strong>选项说明：</strong></p><ul><li>-a：跟踪所有系统调用，包括不常用的系统调用。</li><li>-c：统计每一系统调用的所执行的时间,次数和出错的次数等。</li><li>-d：输出strace关于标准错误的调试信息。</li><li>-e：指定要跟踪的系统调用。</li><li>-f：跟踪由fork调用所产生的子进程。</li><li>-o：将输出保存到指定文件中。</li><li>-p：跟踪指定PID的进程。</li><li>-s：指定输出的行宽。</li><li>-t：输出时间戳。</li><li>-tt：输出毫秒级别的时间戳。</li><li>-T：输出每个系统调用所花费的时间。</li><li>-u：跟踪用户空间的地址空间。</li><li>-v：输出更详细的信息。</li></ul><p><strong>示例：</strong></p><ul><li>跟踪ls命令的系统调用：</li></ul><pre tabindex=0><code>strace ls
</code></pre><ul><li>跟踪ls命令的系统调用，包括不常用的系统调用：</li></ul><pre tabindex=0><code>strace -a ls
</code></pre><ul><li>跟踪ls命令的系统调用，统计每个系统调用的所执行的时间、次数和出错的次数等：</li></ul><pre tabindex=0><code>strace -c ls
</code></pre><ul><li>跟踪ls命令的系统调用，输出到指定文件中：</li></ul><pre tabindex=0><code>strace -o trace.log ls
</code></pre><ul><li>跟踪指定PID为100的进程的系统调用：</li></ul><pre tabindex=0><code>strace -p 100
</code></pre><ul><li>跟踪用户空间的地址空间：</li></ul><pre tabindex=0><code>strace -u
</code></pre><p>strace是一个非常强大的工具，可以用于诊断、调试和教学。通过使用strace，可以了解进程是如何与内核进行交互的，从而帮助解决各种问题。</p><h2 id=man>man<a hidden class=anchor aria-hidden=true href=#man>#</a></h2><p>man指令是Linux和类Unix操作系统中内置的命令，用于显示命令、实用程序和函数的参考页面。它是一个非常有用的工具，可用于学习和使用这些系统上可用的大量工具。</p><p>要使用man，只需键入<code>man</code>后跟您要了解的命令、实用程序或函数的名称。例如，要了解<code>ls</code>命令，您将键入<code>man ls</code>。</p><p>每个命令的man页面分为几个部分，包括：</p><ul><li><strong>NAME:</strong> 命令的名称和简短描述。</li><li><strong>SYNOPSIS:</strong> 使用命令的语法。</li><li><strong>DESCRIPTION:</strong> 命令的详细描述，包括其选项和参数。</li><li><strong>EXAMPLES:</strong> 如何使用命令的示例。</li><li><strong>FILES:</strong> 命令使用的文件列表。</li><li><strong>SEE ALSO:</strong> 其他相关命令列表。</li></ul><h2 id=sar>sar<a hidden class=anchor aria-hidden=true href=#sar>#</a></h2><pre tabindex=0><code>sar -P all 1
</code></pre><p>sar是Linux系统上用于<strong>收集系统性能数据</strong>的命令。它可以收集CPU、内存、磁盘、网络等方面的数据。sar命令的输出可以用于监控系统性能、诊断系统问题、进行性能分析等。</p><p>sar命令的语法如下：</p><pre tabindex=0><code>sar [选项] [间隔] [持续时间]
</code></pre><p><strong>选项说明：</strong></p><ul><li><strong>-a：</strong> 收集所有可用的数据。</li><li><strong>-b：</strong> 收集块设备的数据。</li><li><strong>-c：</strong> 收集CPU的数据。</li><li><strong>-d：</strong> 收集磁盘设备的数据。</li><li><strong>-e：</strong> 收集内存的数据。</li><li><strong>-f：</strong> 从指定文件中读取数据。</li><li><strong>-i：</strong> 收集网络设备的数据。</li><li><strong>-n：</strong> 指定收集的数据项。</li><li><strong>-r：</strong> 收集实时数据。</li><li><strong>-u：</strong> 收集用户空间的数据。</li><li><strong>-v：</strong> 输出更详细的信息。</li><li>-P： 可以加上ALL ，列出各个CPU上的情况</li></ul><p><strong>间隔说明：</strong></p><ul><li>间隔以秒为单位，默认为1秒。</li></ul><p><strong>持续时间说明：</strong></p><ul><li>持续时间以秒为单位，默认为无限长。</li></ul><p><strong>示例：</strong></p><ul><li>收集所有可用的数据，间隔为1秒，持续时间为10秒：</li></ul><pre tabindex=0><code>sar -a 1 10
</code></pre><ul><li>收集CPU的数据，间隔为5秒，持续时间为1分钟：</li></ul><pre tabindex=0><code>sar -c 5 60
</code></pre><ul><li>收集内存的数据，间隔为1分钟，持续时间为1小时：</li></ul><pre tabindex=0><code>sar -e 1 3600
</code></pre><ul><li>收集网络设备的数据，间隔为1小时，持续时间为24小时：</li></ul><pre tabindex=0><code>sar -i 1 86400
</code></pre><p><strong>sar命令的输出格式：</strong></p><p>sar命令的输出格式如下：</p><pre tabindex=0><code>时间戳 数据项 值
</code></pre><p>时间戳以秒为单位，数据项表示收集的数据类型，值表示数据的值。</p><p><strong>sar命令的常用用法：</strong></p><ul><li>监控系统性能：使用sar命令可以监控系统的CPU、内存、磁盘、网络等方面的性能。</li><li>诊断系统问题：使用sar命令可以帮助诊断系统性能问题。</li><li>进行性能分析：使用sar命令可以进行性能分析，以了解系统的瓶颈。</li></ul><p>以下是一些sar命令的常用用法：</p><ul><li>监控CPU使用率：</li></ul><pre tabindex=0><code>sar -c
</code></pre><ul><li>监控内存使用率：</li></ul><pre tabindex=0><code>sar -e
</code></pre><ul><li>监控磁盘读写速度：</li></ul><pre tabindex=0><code>sar -d
</code></pre><ul><li>监控网络流量：</li></ul><pre tabindex=0><code>sar -i
</code></pre><ul><li>监控系统负载：</li></ul><pre tabindex=0><code>sar -u
</code></pre><h2 id=readelf>readelf<a hidden class=anchor aria-hidden=true href=#readelf>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>readelf -h /bin/sleep
</span></span></code></pre></div><p><img loading=lazy src=https://s2.loli.net/2024/06/23/mUZYcpO1AfhWkTV.png alt=image-20231006090246530></p><p>readelf命令是Linux系统上用于显示ELF文件信息的命令。它可以显示ELF文件的文件头、程序头、节头、符号表、重定位表等信息。readelf命令可以用于调试程序、学习ELF文件格式等。</p><p>readelf命令的语法如下：</p><pre tabindex=0><code>readelf [选项] 文件
</code></pre><p><strong>选项说明：</strong></p><ul><li><strong>-a：</strong> 显示所有信息。</li><li><strong>-h：</strong> 显示文件头信息。</li><li><strong>-l：</strong> 显示程序头信息。</li><li><strong>-S：</strong> 显示节头信息。</li><li><strong>-s：</strong> 显示符号表信息。</li><li><strong>-r：</strong> 显示重定位表信息。</li><li><strong>-d：</strong> 显示动态链接信息。</li><li><strong>-e：</strong> 显示所有头信息。</li><li><strong>-x：</strong> 显示只读数据段。</li><li><strong>-z：</strong> 显示字符串表。</li></ul><p><strong>示例：</strong></p><ul><li>显示可执行文件<code>ls</code>的所有信息：</li></ul><pre tabindex=0><code>readelf -a ls
</code></pre><ul><li>显示可执行文件<code>ls</code>的文件头信息：</li></ul><pre tabindex=0><code>readelf -h ls
</code></pre><ul><li>显示可执行文件<code>ls</code>的程序头信息：</li></ul><pre tabindex=0><code>readelf -l ls
</code></pre><ul><li>显示可执行文件<code>ls</code>的节头信息：</li></ul><pre tabindex=0><code>readelf -S ls
</code></pre><ul><li>显示可执行文件<code>ls</code>的符号表信息：</li></ul><pre tabindex=0><code>readelf -s ls
</code></pre><ul><li>显示可执行文件<code>ls</code>的重定位表信息：</li></ul><pre tabindex=0><code>readelf -r ls
</code></pre><ul><li>显示可执行文件<code>ls</code>的动态链接信息：</li></ul><pre tabindex=0><code>readelf -d ls
</code></pre><p><strong>readelf命令的输出格式：</strong></p><p>readelf命令的输出格式取决于指定的选项。</p><p><strong>readelf命令的常用用法：</strong></p><ul><li>调试程序：使用readelf命令可以查看程序的符号表和重定位表信息，这对于调试程序很有帮助。</li><li>学习ELF文件格式：使用readelf命令可以查看ELF文件的所有信息，这对于学习ELF文件格式很有帮助。</li></ul><p>以下是一些readelf命令的常用用法：</p><ul><li>查看可执行文件的所有信息：</li></ul><pre tabindex=0><code>readelf -a 文件
</code></pre><ul><li>查看可执行文件的文件头信息：</li></ul><pre tabindex=0><code>readelf -h 文件
</code></pre><ul><li>查看可执行文件的程序头信息：</li></ul><pre tabindex=0><code>readelf -l 文件
</code></pre><ul><li>查看可执行文件的节头信息：</li></ul><pre tabindex=0><code>readelf -S 文件
</code></pre><ul><li>查看可执行文件的符号表信息：</li></ul><pre tabindex=0><code>readelf -s 文件
</code></pre><ul><li>查看可执行文件的重定位表信息：</li></ul><pre tabindex=0><code>readelf -r 文件
</code></pre><ul><li>查看可执行文件的动态链接信息：</li></ul><pre tabindex=0><code>readelf -d 文件
</code></pre><h2 id=ps>ps<a hidden class=anchor aria-hidden=true href=#ps>#</a></h2><p>ps命令是Linux系统上用于<strong>显示当前系统进程信息的</strong>命令。它可以显示进程的PID、进程名称、进程状态、用户、CPU使用率、内存使用率等信息。ps命令可以用于监控系统进程、诊断系统问题、进行性能分析等。</p><p>ps命令的语法如下：</p><pre tabindex=0><code>ps [选项]
</code></pre><p><strong>选项说明：</strong></p><ul><li><strong>-a：</strong> 显示所有进程。</li><li><strong>-u：</strong> 显示用户进程。</li><li><strong>-x：</strong> 显示所有进程，包括守护进程。</li><li><strong>-l：</strong> 显示详细信息。</li><li><strong>-e：</strong> 此参数的效果和指定"A"参数相同。</li><li><strong>-f：</strong> 显示完整的命令行。</li><li><strong>-o：</strong> 指定显示的列。</li><li><strong>-pid：</strong> 指定进程的PID。</li><li><strong>-ppid：</strong> 指定进程的父进程的PID。</li><li><strong>-sid：</strong> 指定进程的会话ID。</li><li><strong>-tty：</strong> 指定进程的终端。</li></ul><p><strong>示例：</strong></p><ul><li>显示所有进程：</li></ul><pre tabindex=0><code>ps -a
</code></pre><ul><li>显示用户进程：</li></ul><pre tabindex=0><code>ps -u
</code></pre><ul><li>显示所有进程，包括守护进程：</li></ul><pre tabindex=0><code>ps -x
</code></pre><ul><li>显示详细信息：</li></ul><pre tabindex=0><code>ps -l
</code></pre><ul><li>显示完整的命令行：</li></ul><pre tabindex=0><code>ps -f
</code></pre><ul><li>指定显示的列：</li></ul><pre tabindex=0><code>ps -o pid,ppid,comm,state,pcpu,mem
</code></pre><ul><li>指定进程的PID：</li></ul><pre tabindex=0><code>ps -p 1234
</code></pre><ul><li>指定进程的父进程的PID：</li></ul><pre tabindex=0><code>ps -ppid 1234
</code></pre><ul><li>指定进程的会话ID：</li></ul><pre tabindex=0><code>ps -sid 1234
</code></pre><ul><li>指定进程的终端：</li></ul><pre tabindex=0><code>ps -tty /dev/tty1
</code></pre><p><strong>ps命令的输出格式：</strong></p><p>ps命令的输出格式取决于指定的选项。</p><p><strong>ps命令的常用用法：</strong></p><ul><li>监控系统进程：使用ps命令可以监控系统进程的状态，以了解系统的运行情况。</li><li>诊断系统问题：使用ps命令可以帮助诊断系统问题，例如进程卡死、内存泄漏等。</li><li>进行性能分析：使用ps命令可以进行性能分析，以了解系统的瓶颈。</li></ul><p>以下是一些ps命令的常用用法：</p><ul><li>查看所有进程：</li></ul><pre tabindex=0><code>ps -a
</code></pre><ul><li>查看用户进程：</li></ul><pre tabindex=0><code>ps -u
</code></pre><ul><li>查看所有进程，包括守护进程：</li></ul><pre tabindex=0><code>ps -x
</code></pre><ul><li>查看详细信息：</li></ul><pre tabindex=0><code>ps -l
</code></pre><ul><li>查看完整的命令行：</li></ul><pre tabindex=0><code>ps -f
</code></pre><ul><li>查看指定进程的信息：</li></ul><pre tabindex=0><code>ps -p 1234
</code></pre><ul><li>查看指定进程的父进程的信息：</li></ul><pre tabindex=0><code>ps -ppid 1234
</code></pre><ul><li>查看指定进程的会话ID：</li></ul><pre tabindex=0><code>ps -sid 1234
</code></pre><ul><li>查看指定进程的终端：</li></ul><pre tabindex=0><code>ps -tty /dev/tty1
</code></pre><h2 id=taskset>taskset<a hidden class=anchor aria-hidden=true href=#taskset>#</a></h2><p>taskset命令是Linux系统上用于设置进程亲和力的命令。亲和力是指进程运行在哪些CPU上。taskset命令可以用于提高进程的性能或稳定性。</p><p>taskset命令的语法如下：</p><pre tabindex=0><code>taskset [选项] 进程ID [CPU列表]
</code></pre><p><strong>选项说明：</strong></p><ul><li><strong>-c：</strong> 指定CPU列表。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看逻辑cpu个数</span>
</span></span><span class=line><span class=cl>grep -c processor /proc/cpuinfo
</span></span></code></pre></div><ul><li><strong>-p：</strong> 指定进程ID。</li><li><strong>-a：</strong> 指定所有进程。</li></ul><p><strong>示例：</strong></p><ul><li>将进程ID为1234的进程绑定到CPU 0：</li></ul><pre tabindex=0><code>taskset -c 0 1234
</code></pre><ul><li>将所有进程绑定到CPU 0：</li></ul><pre tabindex=0><code>taskset -c 0 -a
</code></pre><ul><li>将进程ID为1234的进程绑定到CPU 0 和 1：</li></ul><pre tabindex=0><code>taskset -c 0,1 1234
</code></pre><p><strong>taskset命令的输出格式：</strong></p><p>taskset命令没有输出格式。</p><p><strong>taskset命令的常用用法：</strong></p><ul><li>提高进程的性能：将进程绑定到特定的CPU可以提高进程的性能，因为进程不需要在多个CPU之间切换。</li><li>提高进程的稳定性：将进程绑定到特定的CPU可以提高进程的稳定性，因为进程不会与其他进程竞争CPU资源。</li></ul><p>以下是一些taskset命令的常用用法：</p><ul><li>将计算密集型进程绑定到特定的CPU：</li></ul><pre tabindex=0><code>taskset -c 0,1,2,3 ./my_computation_intensive_program
</code></pre><ul><li>将IO密集型进程绑定到特定的CPU：</li></ul><pre tabindex=0><code>taskset -c 4,5,6,7 ./my_io_intensive_program
</code></pre><ul><li>将需要实时响应的进程绑定到特定的CPU：</li></ul><pre tabindex=0><code>taskset -c 0 ./my_real_time_program
</code></pre><h1 id=网络命令>网络命令<a hidden class=anchor aria-hidden=true href=#网络命令>#</a></h1><h2 id=ipconfig-ifconfig-ip>ipconfig, ifconfig, ip<a hidden class=anchor aria-hidden=true href=#ipconfig-ifconfig-ip>#</a></h2><p>ipconfig是windows中的命令，linux上是ifconfig，但ip命令比ifconfig更强大，旨在取代ifconfig命令。</p><h2 id=ping>ping<a hidden class=anchor aria-hidden=true href=#ping>#</a></h2><p>ping命令是DOS命令，一般用于检测网络是否通畅以及网络连接速度，结果只越大，说明速度越慢。它使用网络层的ICMP协议。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ping <span class=o>[</span>参数选项<span class=o>]</span> <span class=o>[</span>主机名或IP地址<span class=o>]</span>
</span></span></code></pre></div><p><strong>linux</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>设置完成要求回应的次数</td></tr><tr><td>-i</td><td>指定收发信息的间隔时间</td></tr><tr><td>-s</td><td>设置数据包的大小</td></tr><tr><td>-w</td><td>在设定的秒后退出</td></tr></tbody></table><p><strong>windows</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-t</td><td>连续对IP地址执行ping命令，直到用户以&lt;control+c>键强制中断</td></tr><tr><td>-l</td><td>指定ping命令的数据长度</td></tr><tr><td>-n</td><td>执行特定次数的ping命令</td></tr></tbody></table><h2 id=netstat>netstat<a hidden class=anchor aria-hidden=true href=#netstat>#</a></h2><p>netstat 用来查看当前操作系统的网络连接状态、路由表、接口统计等信息，来自于 net-tools 工具包，ss 是 netstat 的升级版。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示主机中所有活动的网络连接信息 (包括监听、非监听状态的服务端口)</td></tr><tr><td>-n</td><td>以数字的形式显示相关的主机地址、端口等信息</td></tr><tr><td>-p</td><td>显示与网络连接相关联的进程号、进程名称信息 (该选项需要 root 权限)</td></tr><tr><td>-l</td><td>显示处于监听 (Listen) 状态的网络连接及端口信息</td></tr><tr><td>-t</td><td>查看 TCP (Transmission Control Protocol，传输控制协议) 相关的信息</td></tr><tr><td>-u</td><td>显示 UDP (User Datagram Protocol，用户数据报协议) 协议相关的信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr><tr><td>-i</td><td>显示网卡列表</td></tr><tr><td>-g</td><td>显示组播组的关系</td></tr><tr><td>-s</td><td>显示网络统计信息</td></tr></tbody></table><p>常用命令选项：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>netstat <span class=o>[</span>-anpt<span class=o>]</span> <span class=o>[</span>-anpu<span class=o>]</span> <span class=o>[</span>-anptu<span class=o>]</span> <span class=o>[</span>-anpltu<span class=o>]</span> <span class=o>[</span>-ntlp<span class=o>]</span>
</span></span></code></pre></div><h2 id=ss>ss<a hidden class=anchor aria-hidden=true href=#ss>#</a></h2><p>ss 命令来自于 iproute 包，是 netstat 的升级版本。netstat 通过遍历 /proc 来获取 socket 信息，ss 使用 netlink 与内核 tcp_diag 模块通信获取 socket 信息。
格式：</p><pre tabindex=0><code>ss [OPTION]... [FILTER]
</code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示主机中所有活动的网络连接信息 (包括监听、非监听状态的服务端口)</td></tr><tr><td>-n</td><td>以数字的形式显示相关的主机地址、端口等信息</td></tr><tr><td>-p</td><td>显示与网络连接相关联的进程号、进程名称信息 (该选项需要 root 权限)</td></tr><tr><td>-l</td><td>显示处于监听 (Listen) 状态的网络连接及端口信息</td></tr><tr><td>-t</td><td>查看 TCP (Transmission Control Protocol，传输控制协议) 相关的信息</td></tr><tr><td>-u</td><td>显示 UDP (User Datagram Protocol，用户数据报协议) 协议相关的信息</td></tr><tr><td>-x</td><td>unix sock 相关</td></tr><tr><td>-w</td><td>裸套接字相关</td></tr><tr><td>-e</td><td>扩展的信息</td></tr><tr><td>-m</td><td>内存用量</td></tr><tr><td>-o</td><td>计时器信息</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#显示本地打开的所有端口</span>
</span></span><span class=line><span class=cl>ss -l
</span></span><span class=line><span class=cl><span class=c1>#列出当前 socket 详细信息</span>
</span></span><span class=line><span class=cl>ss -s
</span></span><span class=line><span class=cl><span class=c1>#显示每个进程具体打开的 socket</span>
</span></span><span class=line><span class=cl>ss -pl
</span></span><span class=line><span class=cl><span class=c1>#显示所有 tcp socket</span>
</span></span><span class=line><span class=cl>ss -at
</span></span><span class=line><span class=cl><span class=c1>#显示所有的 udp socket</span>
</span></span><span class=line><span class=cl>ss -au
</span></span><span class=line><span class=cl><span class=c1>#显示所有已建立的 ssh 连接</span>
</span></span><span class=line><span class=cl>ss -o state established <span class=s1>&#39;( dport = :ssh or sport = :ssh )&#39;</span>
</span></span><span class=line><span class=cl><span class=c1>#显示所有已建立的HTTP连接</span>
</span></span><span class=line><span class=cl>ss -o state established <span class=s1>&#39;( dport = :http or sport = :http )&#39;</span>
</span></span></code></pre></div><h2 id=traceroute>traceroute<a hidden class=anchor aria-hidden=true href=#traceroute>#</a></h2><p>traceroute 命令可以用于测试从当前主机到目的主机之间经过了哪些网络结点，并显示各个中间结点的连接状态（响应时间）。对于无法响应的结点，连接状态将显示为 “*”，预设数据包大小是 40Bytes，用户可另行设置。如果没有 traceroute 命令可执行 yum -y install traceroute 安装。</p><p>格式：</p><pre tabindex=0><code>traceroute [参数] [主机|IP]
</code></pre><p>参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>使用 Socket 层级的排错功能</td></tr><tr><td>-f</td><td>设置第一个检测数据包的存活数值 TTL 的大小</td></tr><tr><td>-F</td><td>设置勿离断位</td></tr><tr><td>-g</td><td>设置来源路由网关，最多可设置 8 个</td></tr><tr><td>-i</td><td>使用指定的网络界面送出数据包</td></tr><tr><td>-l</td><td>I 使用 ICMP 回应取代 UDP 资料信息</td></tr><tr><td>-m</td><td>设置检测数据包的最大存活数值 TTL 的大小</td></tr><tr><td>-n</td><td>直接使用 IP 地址而非主机名称</td></tr><tr><td>-p</td><td>设置 UDP 传输协议的通信端口</td></tr><tr><td>-r</td><td>忽略普通的 Routing Table，直接将数据包送到远端主机上</td></tr><tr><td>-s</td><td>设置本地主机送出数据包的 IP 地址</td></tr><tr><td>-t</td><td>设置检测数据包的 TOS 数值</td></tr><tr><td>-v</td><td>详细显示指令的执行过程</td></tr><tr><td>-w</td><td>设置等待远端主机回报的时间</td></tr><tr><td>-x</td><td>开启或关闭数据包的正确性检验</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@c7-1 ~<span class=o>]</span><span class=c1>#traceroute 20.0.0.25</span>
</span></span><span class=line><span class=cl>traceroute to 20.0.0.25 <span class=o>(</span>20.0.0.25<span class=o>)</span>, <span class=m>30</span> hops max, <span class=m>60</span> byte packets
</span></span><span class=line><span class=cl> <span class=m>1</span>  20.0.0.25 <span class=o>(</span>20.0.0.25<span class=o>)</span>  0.942 ms  0.782 ms  0.647 ms
</span></span><span class=line><span class=cl><span class=c1>#可以看到这两台机器之间没有经过路由，是直连或连着交换机的状态</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@c7-1 ~<span class=o>]</span><span class=c1>#traceroute www.baidu.com</span>
</span></span><span class=line><span class=cl>traceroute to www.baidu.com <span class=o>(</span>112.80.248.75<span class=o>)</span>, <span class=m>30</span> hops max, <span class=m>60</span> byte packets
</span></span><span class=line><span class=cl> <span class=m>1</span>  gateway <span class=o>(</span>20.0.0.2<span class=o>)</span>  5.900 ms  5.817 ms  5.758 ms
</span></span><span class=line><span class=cl> <span class=m>2</span>  * * *
</span></span><span class=line><span class=cl> <span class=m>3</span>  * * *
</span></span><span class=line><span class=cl> <span class=m>4</span>  * * *
</span></span><span class=line><span class=cl>......
</span></span></code></pre></div><h2 id=nslookup>nslookup<a hidden class=anchor aria-hidden=true href=#nslookup>#</a></h2><p><code>nslookup</code>是一个用于查询域名系统（DNS）以获取有关域名、IP地址和其他DNS记录信息的网络管理命令行工具。</p><pre tabindex=0><code>nslookup 域名
</code></pre><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@c7-1 ~<span class=o>]</span><span class=c1>#nslookup www.baidu.com</span>
</span></span><span class=line><span class=cl>Server:		20.0.0.2
</span></span><span class=line><span class=cl>Address:	20.0.0.2#53
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Non-authoritative answer:
</span></span><span class=line><span class=cl>www.baidu.com	canonical <span class=nv>name</span> <span class=o>=</span> www.a.shifen.com.
</span></span><span class=line><span class=cl>Name:	www.a.shifen.com
</span></span><span class=line><span class=cl>Address: 112.80.248.75
</span></span><span class=line><span class=cl>Name:	www.a.shifen.com
</span></span><span class=line><span class=cl>Address: 112.80.248.76
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@c7-1 ~<span class=o>]</span><span class=c1>#nslookup www.google.com</span>
</span></span><span class=line><span class=cl>Server:		20.0.0.2
</span></span><span class=line><span class=cl>Address:	20.0.0.2#53
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Non-authoritative answer:
</span></span><span class=line><span class=cl>Name:	www.google.com
</span></span><span class=line><span class=cl>Address: 104.244.46.208
</span></span><span class=line><span class=cl>Name:	www.google.com
</span></span><span class=line><span class=cl>Address: 2001::1f0d:5211
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@c7-1 ~<span class=o>]</span><span class=c1>#cat /etc/resolv.conf	#域名解析配置文件</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Generated by NetworkManager</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 一行一个 DNS，最多配置三个 DNS，优先使用第一个 DNS 服务器</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nameserver 20.0.0.2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@c7-1 ~<span class=o>]</span><span class=c1>#cat /etc/hosts</span>
</span></span><span class=line><span class=cl>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
</span></span><span class=line><span class=cl>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
</span></span><span class=line><span class=cl>112.80.248.75 www.baidu.com
</span></span><span class=line><span class=cl><span class=c1>#/etc/hosts 文件中记录着一份主机名与 IP 地址的映射关系表，一般用来保存经常需要访问的主机的信息。当访问一个未知的域名时，先查找该文件中是否有相应的映射记录，如果找不到再去向 DNS 服务器查询。</span>
</span></span></code></pre></div><h2 id=arp>ARP<a hidden class=anchor aria-hidden=true href=#arp>#</a></h2><p>ARP（Address Resolution Protocol，地址解析协议）缓冲区是在计算机或网络设备上维护的一个表格，用于存储 IP 地址与MAC 地址之间的映射关系。ARP 协议用于将目标主机的 IP 地址解析成其对应的 MAC 地址，从而实现数据在网络上的正确传输。</p><p>在一个局域网中，当计算机 A 需要与计算机 B 进行通信时，A 需要知道 B 的 MAC 地址才能正确发送数据包。这时，A 发送一个 ARP 请求广播，询问网络中是否有拥有特定 IP 地址的设备，并且请求对应设备的 MAC 地址。设备 B 收到请求后，会回复一个 ARP 响应，包含其自己的 MAC 地址。一旦 A 收到了 B 的 MAC 地址，它就可以将数据包正确地发送给 B。</p><p>ARP 缓冲区（或称为 ARP 表格、ARP 缓存）在这个过程中起到了重要作用。当设备 A 解析了设备 B 的 IP 地址并获取到 B 的 MAC 地址后，它将这个映射关系存储在 ARP 缓冲区中。这样，以后 A 需要与 B 通信时，就无需再次发送 ARP 请求，而是直接从 ARP 缓冲区中获取 B 的 MAC 地址，从而加速通信过程。</p><p>arp 命令用于操作主机的 arp 缓冲区，可以用来显示 arp 缓冲区中的所有条目、删除指定的条目或者添加静态的 ip 地址与 MAC 地址对应关系。</p><p>格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>arp <span class=o>[</span>-vn<span class=o>]</span>  <span class=o>[</span>&lt;HW&gt;<span class=o>]</span> <span class=o>[</span>-i &lt;<span class=k>if</span>&gt;<span class=o>]</span> <span class=o>[</span>-a<span class=o>]</span> <span class=o>[</span>&lt;hostname&gt;<span class=o>]</span>             &lt;-Display ARP cache
</span></span><span class=line><span class=cl>arp <span class=o>[</span>-v<span class=o>]</span>          <span class=o>[</span>-i &lt;<span class=k>if</span>&gt;<span class=o>]</span> -d  &lt;host&gt; <span class=o>[</span>pub<span class=o>]</span>               &lt;-Delete ARP entry
</span></span><span class=line><span class=cl>arp <span class=o>[</span>-vnD<span class=o>]</span> <span class=o>[</span>&lt;HW&gt;<span class=o>]</span> <span class=o>[</span>-i &lt;<span class=k>if</span>&gt;<span class=o>]</span> -f  <span class=o>[</span>&lt;filename&gt;<span class=o>]</span>            &lt;-Add entry from file
</span></span><span class=line><span class=cl>arp <span class=o>[</span>-v<span class=o>]</span>   <span class=o>[</span>&lt;HW&gt;<span class=o>]</span> <span class=o>[</span>-i &lt;<span class=k>if</span>&gt;<span class=o>]</span> -s  &lt;host&gt; &lt;hwaddr&gt; <span class=o>[</span>temp<span class=o>]</span>            &lt;-Add entry
</span></span><span class=line><span class=cl>arp <span class=o>[</span>-v<span class=o>]</span>   <span class=o>[</span>&lt;HW&gt;<span class=o>]</span> <span class=o>[</span>-i &lt;<span class=k>if</span>&gt;<span class=o>]</span> -Ds &lt;host&gt; &lt;<span class=k>if</span>&gt; <span class=o>[</span>netmask &lt;nm&gt;<span class=o>]</span> pub          &lt;-<span class=s1>&#39;&#39;</span>-
</span></span></code></pre></div><p>参数：</p><p>-a&lt;主机>： 显示 arp 缓冲区的所有条目
-H&lt;地址类型>： 指定 arp 指令使用的地址类型
-d&lt;主机>： 从 arp 缓冲区中删除指定主机的 arp 条目
-D： 使用指定接口的硬件地址
-e： 以 Linux 的显示风格显示 arp 缓冲区中的条目
-i&lt;接口>： 指定要操作 arp 缓冲区的网络接口
-s&lt;主机>&lt;MAC地址>：设置指定的主机的 IP 地址与 MAC 地址的静态映射
-n： 以数字方式显示 arp 缓冲区中的条目
-v： 显示详细的 arp 缓冲区条目，包括缓冲区条目的统计信息
-f&lt;文件>： 设置主机的 IP 地址与 MAC 地址的静态映射</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#显示 ARP 表</span>
</span></span><span class=line><span class=cl>arp -n	或	ip neigh
</span></span><span class=line><span class=cl><span class=c1>#ARP 静态绑定 MAC 地址可以防止 ARP 欺骗</span>
</span></span><span class=line><span class=cl>arp -s 10.0.0.6 00:0c:29:32:80:38
</span></span><span class=line><span class=cl><span class=c1>#删除 arp 缓存条目</span>
</span></span><span class=line><span class=cl>arp -d 10.0.0.6
</span></span><span class=line><span class=cl><span class=c1>#指定回复的 MAC 地址</span>
</span></span><span class=line><span class=cl>arp -i eth0 -Ds 10.0.0.2 eth1 pub
</span></span></code></pre></div><h2 id=ftp>FTP<a hidden class=anchor aria-hidden=true href=#ftp>#</a></h2><p>FTP（File Transfer Protocol）是一种用于在网络上传输文件的标准协议。你可以使用命令行界面或者专门的 FTP 客户端来测试和使用 FTP 命令。下面是一些基本的 FTP 命令以及如何进行测试：</p><ol><li><p><strong>连接到 FTP 服务器</strong>： 使用以下命令连接到 FTP 服务器，其中 <code>&lt;server_address></code> 是服务器的地址（域名或 IP 地址）：</p><pre tabindex=0><code>ftp &lt;server_address&gt;
</code></pre><p>输入该命令后，你将会被要求输入用户名和密码来进行身份验证。</p></li><li><p><strong>浏览远程目录</strong>： 连接成功后，你可以使用 <code>ls</code> 命令列出远程服务器上的文件和目录。</p></li><li><p><strong>切换远程目录</strong>： 使用 <code>cd</code> 命令来切换远程服务器上的目录：</p><pre tabindex=0><code>cd &lt;directory_name&gt;
</code></pre></li><li><p><strong>下载文件</strong>： 使用 <code>get</code> 命令来下载远程服务器上的文件到本地：</p><pre tabindex=0><code>get &lt;remote_file_name&gt;
</code></pre></li><li><p><strong>上传文件</strong>： 使用 <code>put</code> 命令来上传本地文件到远程服务器：</p><pre tabindex=0><code>put &lt;local_file_name&gt;
</code></pre></li><li><p><strong>退出 FTP 会话</strong>： 使用 <code>quit</code> 或 <code>bye</code> 命令来退出 FTP 会话：</p><pre tabindex=0><code>quit
</code></pre></li></ol><p>请注意，上述命令只是 FTP 命令的一小部分，而实际的 FTP 客户端可能提供更多功能和选项。如果你在终端或命令提示符中直接使用上述命令，确保你已经连接到一个可用的 FTP 服务器，并且你已经登录并有足够的权限进行操作。</p><h2 id=lsof>lsof<a hidden class=anchor aria-hidden=true href=#lsof>#</a></h2><h3 id=列出所有打开了的网络文件>列出所有打开了的网络文件<a hidden class=anchor aria-hidden=true href=#列出所有打开了的网络文件>#</a></h3><pre tabindex=0><code class=language-x86asm data-lang=x86asm>[root@ecs-centos-7 ~]# lsof -i
COMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
ntpd       567   ntp   18u  IPv4  12657      0t0  UDP localhost:ntp
ntpd       567   ntp   22u  IPv6  16095      0t0  UDP ecs-centos-7.4-64bit-20200212:ntp 
dhclient   651  root    6u  IPv4  14594      0t0  UDP *:bootpc 
master     960  root   13u  IPv4  15791      0t0  TCP localhost:smtp (LISTEN)
master     960  root   14u  IPv6  15792      0t0  TCP localhost:smtp (LISTEN)
mysqld    1053 mysql   13u  IPv6  15147      0t0  TCP *:mysql (LISTEN)
sshd      1348  root    3u  IPv4  16698      0t0  TCP *:ssh (LISTEN)
</code></pre><h4 id=列出所有-ipv46-网络文件>列出所有 IPV4/6 网络文件<a hidden class=anchor aria-hidden=true href=#列出所有-ipv46-网络文件>#</a></h4><p>列出所有已经打开了的 ipv4 网络文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=o>[</span><span class=n>root</span><span class=vi>@ecs</span><span class=o>-</span><span class=n>centos</span><span class=o>-</span><span class=mi>7</span> <span class=o>~]</span><span class=c1># lsof -i 4</span>
</span></span><span class=line><span class=cl><span class=no>COMMAND</span>    <span class=no>PID</span> <span class=no>USER</span>   <span class=no>FD</span>   <span class=no>TYPE</span> <span class=no>DEVICE</span> <span class=no>SIZE</span><span class=o>/</span><span class=no>OFF</span> <span class=no>NODE</span> <span class=no>NAME</span>
</span></span><span class=line><span class=cl><span class=n>ntpd</span>       <span class=mi>567</span>  <span class=n>ntp</span>   <span class=mi>16</span><span class=n>u</span>  <span class=no>IPv4</span>  <span class=mi>12651</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>UDP</span> <span class=o>*</span><span class=ss>:ntp</span> 
</span></span><span class=line><span class=cl><span class=n>ntpd</span>       <span class=mi>567</span>  <span class=n>ntp</span>   <span class=mi>18</span><span class=n>u</span>  <span class=no>IPv4</span>  <span class=mi>12657</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>UDP</span> <span class=ss>localhost</span><span class=p>:</span><span class=n>ntp</span> 
</span></span><span class=line><span class=cl><span class=n>ntpd</span>       <span class=mi>567</span>  <span class=n>ntp</span>   <span class=mi>21</span><span class=n>u</span>  <span class=no>IPv4</span>  <span class=mi>16094</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>UDP</span> <span class=n>ecs</span><span class=o>-</span><span class=n>centos</span><span class=o>-</span><span class=mi>7</span><span class=o>.</span><span class=mi>4</span><span class=o>-</span><span class=mi>64</span><span class=n>bit</span><span class=o>-</span><span class=mi>20200212</span><span class=ss>:ntp</span> 
</span></span><span class=line><span class=cl><span class=n>dhclient</span>   <span class=mi>651</span> <span class=n>root</span>    <span class=mi>6</span><span class=n>u</span>  <span class=no>IPv4</span>  <span class=mi>14594</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>UDP</span> <span class=o>*</span><span class=ss>:bootpc</span> 
</span></span><span class=line><span class=cl><span class=n>master</span>     <span class=mi>960</span> <span class=n>root</span>   <span class=mi>13</span><span class=n>u</span>  <span class=no>IPv4</span>  <span class=mi>15791</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=ss>localhost</span><span class=p>:</span><span class=n>smtp</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>      <span class=mi>1348</span> <span class=n>root</span>    <span class=mi>3</span><span class=n>u</span>  <span class=no>IPv4</span>  <span class=mi>16698</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span></code></pre></div><p>所有已经打开了的 ipv6 网络文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=o>[</span><span class=n>root</span><span class=vi>@ecs</span><span class=o>-</span><span class=n>centos</span><span class=o>-</span><span class=mi>7</span> <span class=o>~]</span><span class=c1># lsof -i 6</span>
</span></span><span class=line><span class=cl><span class=no>COMMAND</span>  <span class=no>PID</span>  <span class=no>USER</span>   <span class=no>FD</span>   <span class=no>TYPE</span> <span class=no>DEVICE</span> <span class=no>SIZE</span><span class=o>/</span><span class=no>OFF</span> <span class=no>NODE</span> <span class=no>NAME</span>
</span></span><span class=line><span class=cl><span class=n>ntpd</span>     <span class=mi>567</span>   <span class=n>ntp</span>   <span class=mi>17</span><span class=n>u</span>  <span class=no>IPv6</span>  <span class=mi>12652</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>UDP</span> <span class=o>*</span><span class=ss>:ntp</span> 
</span></span><span class=line><span class=cl><span class=n>ntpd</span>     <span class=mi>567</span>   <span class=n>ntp</span>   <span class=mi>19</span><span class=n>u</span>  <span class=no>IPv6</span>  <span class=mi>12658</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>UDP</span> <span class=ss>localhost</span><span class=p>:</span><span class=n>ntp</span> 
</span></span><span class=line><span class=cl><span class=n>ntpd</span>     <span class=mi>567</span>   <span class=n>ntp</span>   <span class=mi>22</span><span class=n>u</span>  <span class=no>IPv6</span>  <span class=mi>16095</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>UDP</span> <span class=n>ecs</span><span class=o>-</span><span class=n>centos</span><span class=o>-</span><span class=mi>7</span><span class=o>.</span><span class=mi>4</span><span class=o>-</span><span class=mi>64</span><span class=n>bit</span><span class=o>-</span><span class=mi>20200212</span><span class=ss>:ntp</span> 
</span></span><span class=line><span class=cl><span class=n>master</span>   <span class=mi>960</span>  <span class=n>root</span>   <span class=mi>14</span><span class=n>u</span>  <span class=no>IPv6</span>  <span class=mi>15792</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=ss>localhost</span><span class=p>:</span><span class=n>smtp</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mysqld</span>  <span class=mi>1053</span> <span class=n>mysql</span>   <span class=mi>13</span><span class=n>u</span>  <span class=no>IPv6</span>  <span class=mi>15147</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:mysql</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>    <span class=mi>1348</span>  <span class=n>root</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv6</span>  <span class=mi>16700</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=列出在指定端口上打开的文件>列出在指定端口上打开的文件<a hidden class=anchor aria-hidden=true href=#列出在指定端口上打开的文件>#</a></h4><p>使用 <code>lsof -i:端口号</code> 可以获得所有在指定端口号上打开的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=o>[</span><span class=n>root</span><span class=vi>@ecs</span><span class=o>-</span><span class=n>centos</span><span class=o>-</span><span class=mi>7</span> <span class=o>~]</span><span class=c1># lsof -i:22</span>
</span></span><span class=line><span class=cl><span class=no>COMMAND</span>   <span class=no>PID</span> <span class=no>USER</span>   <span class=no>FD</span>   <span class=no>TYPE</span> <span class=no>DEVICE</span> <span class=no>SIZE</span><span class=o>/</span><span class=no>OFF</span> <span class=no>NODE</span> <span class=no>NAME</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>     <span class=mi>1348</span> <span class=n>root</span>    <span class=mi>3</span><span class=n>u</span>  <span class=no>IPv4</span>  <span class=mi>16698</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>     <span class=mi>1348</span> <span class=n>root</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv6</span>  <span class=mi>16700</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>    <span class=mi>27741</span> <span class=n>root</span>    <span class=mi>3</span><span class=n>u</span>  <span class=no>IPv4</span> <span class=mi>458958</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=n>ecs</span><span class=o>-</span><span class=n>centos</span><span class=o>-</span><span class=mi>7</span><span class=o>.</span><span class=mi>4</span><span class=o>-</span><span class=mi>64</span><span class=n>bit</span><span class=o>-</span><span class=mi>20200212</span><span class=ss>:ssh</span><span class=o>-&gt;</span><span class=mi>113</span><span class=o>.</span><span class=mi>118</span><span class=o>.</span><span class=mi>121</span><span class=o>.</span><span class=mi>220</span><span class=p>:</span><span class=mi>42395</span> <span class=p>(</span><span class=no>ESTABLISHED</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>    <span class=mi>27819</span> <span class=n>root</span>    <span class=mi>3</span><span class=n>u</span>  <span class=no>IPv4</span> <span class=mi>459250</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=n>ecs</span><span class=o>-</span><span class=n>centos</span><span class=o>-</span><span class=mi>7</span><span class=o>.</span><span class=mi>4</span><span class=o>-</span><span class=mi>64</span><span class=n>bit</span><span class=o>-</span><span class=mi>20200212</span><span class=ss>:ssh</span><span class=o>-&gt;</span><span class=mi>113</span><span class=o>.</span><span class=mi>118</span><span class=o>.</span><span class=mi>121</span><span class=o>.</span><span class=mi>220</span><span class=p>:</span><span class=mi>19807</span> <span class=p>(</span><span class=no>ESTABLISHED</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>    <span class=mi>27895</span> <span class=n>root</span>    <span class=mi>3</span><span class=n>u</span>  <span class=no>IPv4</span> <span class=mi>459828</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span>
</span></span></code></pre></div><p>上面例子列出了所有在22号端口上打开的文件</p><p>在服务器开发中，经常会部署一个网关或者代理程序，用来和客户端通讯，网关或者代理程序需要开放一个固定的端口供客户端连接用</p><p>如果客户端连接不上网关或者代理程序，我们可以用上述命令检查网关或代理程序的端口是否开启，来排除因为端口关闭了导致连接不上网关的情况</p><h4 id=列出使用了指定协议tcpudp-的文件>列出使用了指定协议(TCP/UDP) 的文件<a hidden class=anchor aria-hidden=true href=#列出使用了指定协议tcpudp-的文件>#</a></h4><p>使用 <code>lsof -i TCP/UDP</code> 列出使用了TCP 或 UDP 协议的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=o>[</span><span class=n>root</span><span class=vi>@cghost8</span> <span class=sr>/home/</span><span class=n>cgyx</span><span class=o>]</span><span class=c1># lsof -i TCP | more</span>
</span></span><span class=line><span class=cl><span class=no>COMMAND</span>      <span class=no>PID</span>   <span class=no>USER</span>   <span class=no>FD</span>   <span class=no>TYPE</span>  <span class=no>DEVICE</span> <span class=no>SIZE</span><span class=o>/</span><span class=no>OFF</span> <span class=no>NODE</span> <span class=no>NAME</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>        <span class=mi>1704</span>   <span class=n>root</span>    <span class=mi>3</span><span class=n>u</span>  <span class=no>IPv4</span>   <span class=mi>13593</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>        <span class=mi>1704</span>   <span class=n>root</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv6</span>   <span class=mi>13595</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>redis</span><span class=o>-</span><span class=n>serer</span>   <span class=mi>1725</span>   <span class=n>root</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv4</span>   <span class=mi>19773</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=ss>localhost</span><span class=p>:</span><span class=mi>6380</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>nc</span>          <span class=mi>2067</span>   <span class=n>cgyx</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv4</span>   <span class=mi>39167</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=p>:</span><span class=mi>60600</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mysqld</span>      <span class=mi>3020</span>  <span class=n>mysql</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv6</span> <span class=mi>5514608</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=mi>192</span><span class=o>.</span><span class=mi>168</span><span class=o>.</span><span class=mi>70</span><span class=o>.</span><span class=mi>10</span><span class=ss>:mysql</span><span class=o>-&gt;</span><span class=mi>192</span><span class=o>.</span><span class=mi>168</span><span class=o>.</span><span class=mi>70</span><span class=o>.</span><span class=mi>10</span><span class=p>:</span><span class=mi>37084</span> <span class=p>(</span><span class=no>ESTABLISHED</span><span class=p>)</span>
</span></span></code></pre></div><p>使用 <code>lsof -i TCP:3306</code> 列出使用了TCP 协议并且端口为3306的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=o>[</span><span class=n>root</span><span class=vi>@cghost8</span> <span class=sr>/home/</span><span class=n>cgyx</span><span class=o>]</span><span class=c1># lsof -i TCP:3306</span>
</span></span><span class=line><span class=cl><span class=no>COMMAND</span>      <span class=no>PID</span>  <span class=no>USER</span>   <span class=no>FD</span>   <span class=no>TYPE</span>  <span class=no>DEVICE</span> <span class=no>SIZE</span><span class=o>/</span><span class=no>OFF</span> <span class=no>NODE</span> <span class=no>NAME</span>
</span></span><span class=line><span class=cl><span class=n>mysqld</span>      <span class=mi>3020</span> <span class=n>mysql</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv6</span> <span class=mi>5514608</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=mi>192</span><span class=o>.</span><span class=mi>168</span><span class=o>.</span><span class=mi>70</span><span class=o>.</span><span class=mi>10</span><span class=ss>:mysql</span><span class=o>-&gt;</span><span class=mi>192</span><span class=o>.</span><span class=mi>168</span><span class=o>.</span><span class=mi>70</span><span class=o>.</span><span class=mi>10</span><span class=p>:</span><span class=mi>37084</span> <span class=p>(</span><span class=no>ESTABLISHED</span><span class=p>)</span>
</span></span></code></pre></div><p>使用 <code>lsof -i TCP:1-1024</code> 列出使用了TCP协议并且端口范围为 1 到 1024 的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=o>[</span><span class=n>root</span><span class=vi>@cghost8</span> <span class=sr>/home/</span><span class=n>cgyx</span><span class=o>]</span><span class=c1># lsof -i TCP:1-1024</span>
</span></span><span class=line><span class=cl><span class=no>COMMAND</span>   <span class=no>PID</span>   <span class=no>USER</span>   <span class=no>FD</span>   <span class=no>TYPE</span>  <span class=no>DEVICE</span> <span class=no>SIZE</span><span class=o>/</span><span class=no>OFF</span> <span class=no>NODE</span> <span class=no>NAME</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>     <span class=mi>1704</span>   <span class=n>root</span>    <span class=mi>3</span><span class=n>u</span>  <span class=no>IPv4</span>   <span class=mi>13593</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sshd</span>     <span class=mi>1704</span>   <span class=n>root</span>    <span class=mi>4</span><span class=n>u</span>  <span class=no>IPv6</span>   <span class=mi>13595</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:ssh</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cupsd</span>    <span class=mi>1709</span>   <span class=n>root</span>   <span class=mi>12</span><span class=n>u</span>  <span class=no>IPv6</span>   <span class=mi>39148</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=ss>localhost</span><span class=p>:</span><span class=n>ipp</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cupsd</span>    <span class=mi>1709</span>   <span class=n>root</span>   <span class=mi>13</span><span class=n>u</span>  <span class=no>IPv4</span>   <span class=mi>39149</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=ss>localhost</span><span class=p>:</span><span class=n>ipp</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>smbd</span>     <span class=mi>1824</span>   <span class=n>root</span>   <span class=mi>35</span><span class=n>u</span>  <span class=no>IPv6</span>   <span class=mi>17658</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:microsoft</span><span class=o>-</span><span class=n>ds</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>smbd</span>     <span class=mi>1824</span>   <span class=n>root</span>   <span class=mi>36</span><span class=n>u</span>  <span class=no>IPv6</span>   <span class=mi>17659</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:netbios</span><span class=o>-</span><span class=n>ssn</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>smbd</span>     <span class=mi>1824</span>   <span class=n>root</span>   <span class=mi>37</span><span class=n>u</span>  <span class=no>IPv4</span>   <span class=mi>17660</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:microsoft</span><span class=o>-</span><span class=n>ds</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>smbd</span>     <span class=mi>1824</span>   <span class=n>root</span>   <span class=mi>38</span><span class=n>u</span>  <span class=no>IPv4</span>   <span class=mi>17661</span>      <span class=mi>0</span><span class=n>t0</span>  <span class=no>TCP</span> <span class=o>*</span><span class=ss>:netbios</span><span class=o>-</span><span class=n>ssn</span> <span class=p>(</span><span class=no>LISTEN</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=列出指定进程id打开的文件>列出指定进程ID打开的文件<a hidden class=anchor aria-hidden=true href=#列出指定进程id打开的文件>#</a></h3><p>进程ID是操作系统进程的唯一标识，以下命令列出了进程ID为 <code>1053</code> 相关的文件, 从结果中可以知道这个进程ID对应的进程是MySQL</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=p>[</span><span class=l>root@ecs-centos-7 ~]# lsof -p 1053</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COMMAND  PID  USER   FD   TYPE             DEVICE  SIZE/OFF    NODE NAME</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>mysqld  1053 mysql  cwd    DIR              253,1      4096 1055765 /var/lib/mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>mysqld  1053 mysql  rtd    DIR              253,1      4096       2 /</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>mysqld  1053 mysql  txt    REG              253,1 251841448  534935 /usr/sbin/mysqld</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>mysqld  1053 mysql  mem    REG              253,1    209512  659436 /usr/lib64/mysql/plugin/validate_password.so</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>mysqld  1053 mysql    1w   REG              253,1    206658  924771 /var/log/mysqld.log</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>mysqld  1053 mysql    2w   REG              253,1    206658  924771 /var/log/mysqld.log</span><span class=w>
</span></span></span></code></pre></div><p>上述命令中，<code>-p</code> 选项后面可以指定多个进程ID，每个进程ID之间用逗号分隔，如果想排除掉某个进程打开的文件，可以在该进程ID前面加上 <code>^</code>符号</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-css data-lang=css><span class=line><span class=cl><span class=nt>lsof</span> <span class=nt>-p</span> <span class=nt>1</span><span class=o>,</span><span class=nt>2</span><span class=o>,</span><span class=nt>3</span><span class=o>,^</span><span class=nt>4</span>
</span></span></code></pre></div><p>上述命令会列出进程1，进程2，进程3打开的所有文件，同时忽略进程4打开的文件</p><h3 id=杀死指定用户的所有进程>杀死指定用户的所有进程<a hidden class=anchor aria-hidden=true href=#杀死指定用户的所有进程>#</a></h3><p>前面介绍了列出指定用户所有打开的文件，我们可以组合 <code>kill</code> 命令一起使用，实现杀死指定用户的所有进程的功能，具体的命令如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-perl data-lang=perl><span class=line><span class=cl><span class=nb>kill</span> <span class=o>-</span><span class=mi>9</span> <span class=sb>`lsof -t -u tt`</span>
</span></span></code></pre></div><p>上述命令中，<code>lsof -u tt</code> 是列出<code>tt</code>用户所有打开的文件，加上 <code>-t</code> 选项之后表示结果只列出PID列，也就是进程ID列，其他列都忽略，前面的 <code>kill -9</code> 表示强制结束指定的进程ID</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/commands/>Commands</a></li><li><a href=https://sirius1y.top/tags/ubuntu/>Ubuntu</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/deployment/deploy-redis-ondocker/><span class=title>« Prev</span><br><span>在docker中安装redis</span>
</a><a class=next href=https://sirius1y.top/posts/notes/network/net-frp/><span class=title>Next »</span><br><span>内网穿透——frp和花生壳实现从外部网络访问家中主机</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>