<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【go的源码阅读】channel的实现：chan.go | Sirius' Blog</title>
<meta name=keywords content="go,channel"><meta name=description content='channel的简单使用 在Go语言中，通道（channel）是一种用于在goroutine之间进行通信和同步的机制。下面是一些简单的通道使用示例，以及它们对应的底层函数调用。
package main import ( "fmt" "time" ) func main() { ch := make(chan int) // 创建通道 go func() { ch <- 42 // 发送数据到通道 }() go func() { value := <-ch // 从通道接收数据 fmt.Println("Received:", value) }() time.Sleep(1 * time.Second) // 等待goroutine完成 close(ch) // 关闭通道 } 底层函数调用 创建通道：
ch := make(chan int) 底层调用：
makechan(elemtype, size) 发送数据到通道：
ch <- 42 底层调用：
chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool 从通道接收数据：'><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/go-srccode/go-channel/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/go-srccode/go-channel/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="【go的源码阅读】channel的实现：chan.go"><meta property="og:description" content='channel的简单使用 在Go语言中，通道（channel）是一种用于在goroutine之间进行通信和同步的机制。下面是一些简单的通道使用示例，以及它们对应的底层函数调用。
package main import ( "fmt" "time" ) func main() { ch := make(chan int) // 创建通道 go func() { ch <- 42 // 发送数据到通道 }() go func() { value := <-ch // 从通道接收数据 fmt.Println("Received:", value) }() time.Sleep(1 * time.Second) // 等待goroutine完成 close(ch) // 关闭通道 } 底层函数调用 创建通道：
ch := make(chan int) 底层调用：
makechan(elemtype, size) 发送数据到通道：
ch <- 42 底层调用：
chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool 从通道接收数据：'><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/go-srccode/go-channel/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-10T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-10T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【go的源码阅读】channel的实现：chan.go"><meta name=twitter:description content='channel的简单使用 在Go语言中，通道（channel）是一种用于在goroutine之间进行通信和同步的机制。下面是一些简单的通道使用示例，以及它们对应的底层函数调用。
package main import ( "fmt" "time" ) func main() { ch := make(chan int) // 创建通道 go func() { ch <- 42 // 发送数据到通道 }() go func() { value := <-ch // 从通道接收数据 fmt.Println("Received:", value) }() time.Sleep(1 * time.Second) // 等待goroutine完成 close(ch) // 关闭通道 } 底层函数调用 创建通道：
ch := make(chan int) 底层调用：
makechan(elemtype, size) 发送数据到通道：
ch <- 42 底层调用：
chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool 从通道接收数据：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"【go的源码阅读】channel的实现：chan.go","item":"https://sirius1y.top/posts/notes/go-srccode/go-channel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【go的源码阅读】channel的实现：chan.go","name":"【go的源码阅读】channel的实现：chan.go","description":"channel的简单使用 在Go语言中，通道（channel）是一种用于在goroutine之间进行通信和同步的机制。下面是一些简单的通道使用示例，以及它们对应的底层函数调用。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int) // 创建通道 go func() { ch \u0026lt;- 42 // 发送数据到通道 }() go func() { value := \u0026lt;-ch // 从通道接收数据 fmt.Println(\u0026#34;Received:\u0026#34;, value) }() time.Sleep(1 * time.Second) // 等待goroutine完成 close(ch) // 关闭通道 } 底层函数调用 创建通道：\nch := make(chan int) 底层调用：\nmakechan(elemtype, size) 发送数据到通道：\nch \u0026lt;- 42 底层调用：\nchansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool 从通道接收数据：","keywords":["go","channel"],"articleBody":"channel的简单使用 在Go语言中，通道（channel）是一种用于在goroutine之间进行通信和同步的机制。下面是一些简单的通道使用示例，以及它们对应的底层函数调用。\npackage main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int) // 创建通道 go func() { ch \u003c- 42 // 发送数据到通道 }() go func() { value := \u003c-ch // 从通道接收数据 fmt.Println(\"Received:\", value) }() time.Sleep(1 * time.Second) // 等待goroutine完成 close(ch) // 关闭通道 } 底层函数调用 创建通道：\nch := make(chan int) 底层调用：\nmakechan(elemtype, size) 发送数据到通道：\nch \u003c- 42 底层调用：\nchansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool 从通道接收数据：\nvalue := \u003c- ch 底层调用：\nchanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) 关闭通道：\nclose(ch) 底层调用：\nclosechan(c *hchan) 这些底层函数是Go运行时系统的一部分，用于实现通道的底层操作。通过这些函数，Go语言能够在goroutine之间进行高效、安全的通信和同步。\nchan.go中包含的类 hchan和waitq chan.go中有两个struct:\nhchan, channel的内部实现 waitq, hchan中的recvq和sendq的数据结构 type hchan struct { qcount uint // total data in the queue，队列中总的元素数量 dataqsiz uint // size of the circular queue，环形缓冲区buffer的大小 buf unsafe.Pointer // points to an array of dataqsiz elements，指向buffer中元素的指针 elemsize uint16\t// 表示channel中元素的大小 closed uint32\t// 是否关闭，0表示该channel没有关闭 timer *timer // timer feeding this chan elemtype *_type // element type，channel中元素的类型 sendx uint // send index，buffer中应该发送的元素 recvx uint // receive index，buffer中接收元素的位置 recvq waitq // list of recv waiters，接受者队列 sendq waitq // list of send waiters，发送者队列 // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } // waitq由一个双向链表实现，元素类型是指向sudog的指针 type waitq struct { first *sudog\tlast *sudog } 关于sudog的补充介绍 在Go语言中，sudog 是一个重要的数据结构，用于在goroutine之间进行通信和同步。它是 “Selector User-space Data Object Group” 的缩写，表示在用户空间中用于选择器的数据对象组。\nsudog 主要用于实现Go语言中的 select 语句和通道（channel）操作。当一个goroutine在等待通道操作（如发送或接收数据）时，它会被转换为一个 sudog 结构体，并被添加到相应的等待队列中。这样，调度器可以管理这些等待的goroutine，并在通道操作完成后唤醒它们。\n以下是 sudog 结构体的一些关键字段：\ng *g：指向当前等待的goroutine。 elem unsafe.Pointer：指向发送或接收的数据元素。 c *hchan：指向正在操作的通道。 selectDone uint32：用于选择器操作的完成标志。 ticket uint32：用于公平调度。 sudog 结构体的具体实现可以在Go语言的源码中找到，通常位于 runtime 包中。通过使用 sudog，Go语言的调度器能够高效地管理goroutine的等待和唤醒，从而实现高效的并发编程。\n总结来说，sudog 是Go语言运行时系统中的一个关键数据结构，用于管理goroutine在通道操作中的等待和同步。\n// src/runtime/runtime2.go type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. // 以下字段受该 sudog 所阻塞的通道的 hchan.lock 保护。 // shrinkstack 依赖这些字段来处理涉及通道操作的 sudogs。 g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack) // 数据元素（可能指向堆栈） // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. // 以下字段从未被并发访问。 // 对于通道，waitlink 只被 g 访问。 // 对于信号量，所有字段（包括上述字段）仅在持有 semaRoot 锁时访问。 acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS'd to win the wake-up race. // isSelect 表示 g 正在参与 select，因此 g.selectDone 必须通过 CAS 来赢得唤醒竞争。 isSelect bool // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. // success 表示通过通道 c 的通信是否成功。如果 goroutine 是因为值通过通道 c 传递而被唤醒，则为 true； // 如果是因为 c 被关闭而被唤醒，则为 false。 success bool // waiters is a count of semaRoot waiting list other than head of list, // clamped to a uint16 to fit in unused space. // Only meaningful at the head of the list. // (If we wanted to be overly clever, we could store a high 16 bits // in the second entry in the list.) // waiters 是 semaRoot 等待列表中除列表头外的计数，被限制为 uint16 以适应未使用的空间。 // 仅在列表头有意义。 // （如果我们想过于聪明，我们可以将高 16 位存储在列表的第二个条目中。） waiters uint16 parent *sudog // semaRoot binary tree // semaRoot 二叉树 waitlink *sudog // g.waiting list or semaRoot // g.waiting 列表或 semaRoot waittail *sudog // semaRoot c *hchan // channel // 通道 } makechan 调用场景 在调用ch := make(chan int,2)函数的时候，编译之后可以发现他调用了makechan这个函数.\n使用的在线的一个查看汇编代码的网站\n实现代码 这是makechan的实现：\nfunc makechan(t *chantype, size int) *hchan { elem := t.Elem // compiler checks this but be safe. if elem.Size_ \u003e= 1\u003c\u003c16 { throw(\"makechan: invalid channel element type\") } if hchanSize%maxAlign != 0 || elem.Align_ \u003e maxAlign { throw(\"makechan: bad alignment\") } mem, overflow := math.MulUintptr(elem.Size_, uintptr(size)) if overflow || mem \u003e maxAlloc-hchanSize || size \u003c 0 { panic(plainError(\"makechan: size out of range\")) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG's are referenced from their owning thread so they can't be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. var c *hchan switch { case mem == 0: // Queue or element size is zero. c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() case !elem.Pointers(): // Elements do not contain pointers. // Allocate hchan and buf in one call. c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. c = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.Size_) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) if debugChan { print(\"makechan: chan=\", c, \"; elemsize=\", elem.Size_, \"; dataqsiz=\", size, \"\\n\") } return c } 解读 switch部分，分配内存 mem 是一个 uintptr 类型的变量，用于表示通道缓冲区所需的总内存大小。\nuintptr 的大小足以容纳任何指针的位模式，因此它可以用来进行指针运算和存储指针地址。\n在 Go 语言中，uintptr 通常用于以下几种情况：\n指针运算：由于 uintptr 可以表示指针的整数形式，因此可以用于指针运算，例如计算指针的偏移量。 与 unsafe 包结合使用：unsafe 包提供了一些不安全的操作，例如将指针转换为 uintptr 或将 uintptr 转换为指针。这在进行底层内存操作时非常有用。 存储指针地址：在某些情况下，需要将指针地址存储在一个整数类型中，这时可以使用 uintptr。 需要注意的是，uintptr 不是一个指针类型，因此它不会阻止垃圾回收器回收它所表示的内存。如果需要保持对象存活，应该使用实际的指针类型（如 *T），而不是 uintptr。\n通过这里的代码得到：mem, overflow := math.MulUintptr(elem.Size_, uintptr(size))\nmem 是通过将通道元素的大小（elem.Size_）与通道缓冲区的大小（size）相乘得到的。这个计算过程是通过调用 math.MulUintptr 函数来完成的。\nswitch { case mem == 0: // Queue or element size is zero. // 缓冲区buf大小为0，或者通道元素的大小为0 c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() case !elem.Pointers(): // Elements do not contain pointers. // 元素不包含指针 // Allocate hchan and buf in one call. // 通过一次调用分配给hchan和buf内存 c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. // 元素包含指针 c = new(hchan) c.buf = mallocgc(mem, elem, true) } mem == 0 的情况：\n如果 mem 为 0，这意味着通道的缓冲区大小为 0 或者通道元素的大小为 0。 在这种情况下，代码调用 mallocgc 函数分配 hchanSize 大小的内存，并将返回的内存地址转换为 *hchan 类型，赋值给 c。 mallocgc 是 Go 语言运行时系统中的一个内部函数，用于分配内存并进行垃圾回收（GC）标记。由于它是运行时系统的内部函数，通常不会直接在用户代码中使用。相反，用户代码中会使用更高层次的内存分配函数，如 new、make 等，这些函数会在内部调用 mallocgc。\n其他的内存分配函数还有:newobject，也是调用了mallocgc()\n它的函数签名如下：\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer 这个函数的参数和返回值解释如下：\nsize uintptr：需要分配的内存大小，以字节为单位。 typ *_type：指向类型信息的指针。_type 是 Go 语言中表示类型信息的一个结构体。 needzero bool：一个布尔值，表示是否需要将分配的内存初始化为零。 返回值：\nunsafe.Pointer：返回一个指向新分配内存的 unsafe.Pointer 指针。 mallocgc 函数的主要作用是分配指定大小的内存，并根据需要进行零初始化。同时，它还会对分配的内存进行垃圾回收标记，以便垃圾回收器能够正确地管理这些内存。\nc.buf = c.raceaddr() 这一行是用于竞态检测器（race detector）的同步操作。 !elem.Pointers() 的情况：\n如果通道元素不包含指针（即元素是基本类型或不包含指针的结构体），则调用 mallocgc 函数一次性分配 hchanSize + mem 大小的内存。 这里 hchanSize 是 hchan 结构体的大小，mem 是通道缓冲区的大小。 分配的内存中，前 hchanSize 字节用于存储 hchan 结构体，后面的 mem 字节用于存储通道缓冲区。 c.buf = add(unsafe.Pointer(c), hchanSize) 这一行将 c.buf 指向缓冲区的起始位置。add 函数用于计算指针的偏移量。 默认情况（default）：\n如果通道元素包含指针（即元素是包含指针的结构体），则首先调用 new(hchan) 分配 hchan 结构体的内存。 然后调用 mallocgc 函数分配 mem 大小的内存用于通道缓冲区，并将返回的内存地址赋值给 c.buf。 这种情况下，hchan 结构体和缓冲区是分开分配的。 总结来说，这段代码根据通道元素是否包含指针以及缓冲区大小是否为 0，选择不同的内存分配策略。这样可以优化内存使用，并确保在元素包含指针时能够正确地进行垃圾回收。\n其他初始化 c.elemsize = uint16(elem.Size_) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) 这一段是对c（hchan）的元素大小、元素类型、缓冲区大小、锁进行初始化。\nchansend 调用场景 实现代码和解读 chansend1 调用 chansend 函数，传递通道、元素指针、阻塞标志（true）和调用者的程序计数器。 // entry point for c \u003c- x from compiled code. // 编译代码中 c \u003c- x 的入口点。 //go:nosplit func chansend1(c *hchan, elem unsafe.Pointer) { chansend(c, elem, true, getcallerpc()) } chansend1 和 chansend 的区别 chansend1 是一个包装函数，用于在编译代码中调用 chansend。它总是以阻塞模式调用 chansend，即 block 参数为 true。 chansend 是实际执行发送操作的函数，它可以以阻塞或非阻塞模式工作，具体取决于 block 参数的值。 chansend的函数签名解读 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool ep unsafe.Pointer：这是函数的第二个参数。ep 是参数名，unsafe.Pointer 是参数类型。unsafe.Pointer 是一个可以指向任意类型数据的指针类型，通常用于与 Go 的内存管理进行低级别的交互。 block bool：这是函数的第三个参数。block 是参数名，bool 是参数类型。bool 类型表示一个布尔值，可以是 true 或 false。这个参数用于指示函数是否应该在无法立即完成发送操作时阻塞。 callerpc uintptr：这是函数的第四个参数。callerpc 是参数名，uintptr 是参数类型。uintptr 是一个无符号整数类型，通常用于表示指针的数值。callerpc 通常用于记录调用者的程序计数器（program counter），以便进行调试或性能分析。 chansend 检查通道是否为nil 检查通道是否为 nil，如果是非阻塞模式则返回 false，否则让当前 goroutine 进入永久睡眠状态。 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { // 通道为空并且不阻塞，直接返回false if !block { return false } // 能执行到这里表示通道为空并且block==true，则调用gopark gopark(nil, nil, waitReasonChanSendNilChan, traceBlockForever, 2) throw(\"unreachable\") } ... } gopark 是 Go 语言运行时系统中的一个内部函数，用于将当前的 goroutine 挂起（park），使其进入等待状态。这个函数通常在需要让出 CPU 时间片或等待某个条件满足时使用。\n函数签名 gopark 的函数签名如下：\nfunc gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) 上面的这些判断被称为 fast path，因为加锁的操作是一个很重的操作，所以能够在加锁之前返回的判断就在加锁之前做好是最好的unlockf：一个函数，用于在挂起 goroutine 之前解锁某些资源。这个函数的签名是 func(*g, unsafe.Pointer) bool，其中 *g 是当前 goroutine 的结构体，unsafe.Pointer 是一个指向任意数据的指针。 lock：一个指向锁的指针，用于在挂起 goroutine 之前解锁。 reason：一个 waitReason 类型的值，表示 goroutine 挂起的原因。 traceEv：一个字节值，用于跟踪事件。 traceskip：一个整数值，表示跟踪的跳过层数。 使用场景 gopark 通常在以下几种情况下使用：\n等待通道操作：当 goroutine 在等待通道的发送或接收操作时，如果通道当前不可用，goroutine 会被挂起。 等待锁：当 goroutine 尝试获取一个已经被其他 goroutine 持有的锁时，它会被挂起，直到锁被释放。 等待条件变量：当 goroutine 在等待某个条件变量满足时，它会被挂起，直到条件变量被通知。 Fast Path，检查通道是否未关闭非阻塞且已满 如果通道未关闭且未准备好发送（即通道已满），在非阻塞模式下返回 false。 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... // 非阻塞，未关闭，通道已满 if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { return false } ... } full()也是在runtime2.go中定义的一个函数\n// full reports whether a send on c would block (that is, the channel is full). // full函数报告发送操作是否会在channel c上阻塞（如果阻塞了，说明channel已满） // It uses a single word-sized read of mutable state, so although // the answer is instantaneously true, the correct answer may have changed // by the time the calling function receives the return value. // 该函数使用了单个字大小的可变状态读取，所以即使答案在某一时刻上正确的，但是正确的答案也可能在调用函数返回值之前改变 func full(c *hchan) bool { // c.dataqsiz is immutable (never written after the channel is created) // c.dataqsiz是不可变的（在创建通道之后不会改变） // so it is safe to read at any time during channel operation. // 所以在channel操作的任何时刻读取都是安全的 if c.dataqsiz == 0 {\t// dataqsiz表示缓冲区的大小，为0代表无缓冲通道 // Assumes that a pointer read is relaxed-atomic. // 假定指针读取是宽松原子式的 return c.recvq.first == nil\t// 缓冲区的第一个指针为nil代表该chanel可以接收不会阻塞，反之会阻塞 } // 有缓冲通道的情况 // Assumes that a uint read is relaxed-atomic. // 假定读取一个uint是宽松原子式的 return c.qcount == c.dataqsiz\t// 如果channel的元素个数等于channel的缓冲区大小说明已满阻塞，反之则有空不会阻塞 } 宽松原子式（Relaxed-atomic）:\n宽松原子式是指在多线程环境中，对某个变量的读取或写入操作是原子的，即操作是不可分割的，不会被其他线程的操作打断。 在 Go 语言中，通常假设单个字大小的读取和写入操作是原子的，这意味着读取或写入一个字（通常是 32 位或 64 位）的操作不会被其他线程的操作打断。 这种假设简化了并发编程，但需要注意的是，这种原子性是宽松的，因为它不提供顺序或可见性保证 上面的部分是加锁之前的判断，因为加锁是一个很重的操作，所以最好是能不加就能直接判断返回最好，所以有了上面的代码：channel为nil的判断和非阻塞且通道已满的两个判断。\n加锁，并判断channel是否关闭 获取通道锁。 先判断通道是否处于关闭状态，如是解锁并抛出“send on closed channel”异常。 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... var t0 int64\t// 存储时间戳 if blockprofilerate \u003e 0 { t0 = cputicks() } lock(\u0026c.lock) if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"send on closed channel\")) } ... } 如果有等待的接受者 如果找到等待的接收者，调用 send 函数直接将值传递给接收者。 如果recvq中存在等待的接受者，说明缓冲区是空的，就可以直接把要发的数据发送。\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). // 存在一个等待的接收者。我们将要发送的值直接传递给接收者，绕过通道缓冲区（如果有的话）。 // send接受一个通道指针、一个等待接收数据的 goroutine 指针、一个数据指针、一个解锁函数和一个用于堆栈跟踪的整数 // 要求通道 c 必须为空并已上锁。send 使用 unlockf 解锁 c。 // sg 必须已经从 c 中出队。 // ep 必须非空并指向堆或调用者的堆栈。 send(c, sg, ep, func() { unlock(\u0026c.lock) }, 3)\t// 关于send的实现在下面 return true } ... } dequeue 是 Go 语言运行时系统中用于从等待队列（waitq）中移除并返回一个 sudog 结构体的函数。sudog 结构体代表一个正在等待的 goroutine。这个函数的主要目的是从等待队列中安全地移除一个 sudog，并处理一些特殊情况，比如在 select 语句中等待的 goroutine。\nfunc (q *waitq) dequeue() *sudog { for { sgp := q.first if sgp == nil { return nil } y := sgp.next if y == nil { q.first = nil q.last = nil } else { y.prev = nil q.first = y sgp.next = nil // mark as removed (see dequeueSudoG) } // if a goroutine was put on this queue because of a // select, there is a small window between the goroutine // being woken up by a different case and it grabbing the // channel locks. Once it has the lock // it removes itself from the queue, so we won't see it after that. // We use a flag in the G struct to tell us when someone // else has won the race to signal this goroutine but the goroutine // hasn't removed itself from the queue yet. if sgp.isSelect \u0026\u0026 !sgp.g.selectDone.CompareAndSwap(0, 1) { continue } return sgp } } 如果缓冲区有空间 如果通道缓冲区有空间，将元素入队并解锁。 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... // 执行到这里说明上一条件未满足，即没有等待的接收者 if c.qcount \u003c c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. // channel buffer中有可用空间。将要发送的元素入队。 qp := chanbuf(c, c.sendx)\t// 获取缓冲区sendx的指针 if raceenabled {\t// 如果启用了数据竞争检测 racenotify(c, c.sendx, nil)\t// 这个函数用于通知数据竞争检测系统 } typedmemmove(c.elemtype, qp, ep) // 将数据复制到缓冲区 // 更新 sendx 索引，如果达到缓冲区大小，则重置为 0（实现循环缓冲区） c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++\t// 元素个数更新 unlock(\u0026c.lock)\t// 发送数据完成，解锁 return true } ... } chanbuf 是 Go 语言运行时系统中的一个内部函数，用于获取通道（channel）缓冲区中指定索引位置的元素的指针。这个函数通常在通道的发送和接收操作中使用，以便访问和操作通道缓冲区中的数据。\nadd：这是一个内部函数，用于计算地址偏移量。它将缓冲区起始地址 c.buf 加上索引位置 i 乘以元素大小 c.elemsize，得到指定索引位置的元素的指针。 //go:linkname chanbuf func chanbuf(c *hchan, i uint) unsafe.Pointer { return add(c.buf, uintptr(i)*uintptr(c.elemsize)) } 缓冲区已满，如果是非阻塞 如果通道缓冲区已满且非阻塞模式，解锁并返回 false。 上一条件是没有等待的接受者，缓冲区还有空。执行到这里代表缓冲区已满。\n然后分阻塞和非阻塞模式的判断，如果是非阻塞的，不会存入发送队列，直接返回false。\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... if !block { unlock(\u0026c.lock) return false } ... } 为什么非阻塞的不会存入到发送队列？ 非阻塞模式的设计目的： 非阻塞模式的设计目的是为了在发送操作不能立即完成时，不阻塞调用者。这样可以避免发送操作因为等待缓冲区可用空间而导致的线程阻塞，从而提高程序的响应性和并发性能。 直接返回 false 的意义： 当通道缓冲区已满且处于非阻塞模式时，直接返回 false 可以让调用者立即知道发送操作失败。调用者可以根据返回值来决定下一步的操作，比如重试发送、丢弃数据或采取其他策略。 避免不必要的等待： 如果非阻塞模式下仍然尝试将数据存入发送队列并等待缓冲区可用空间，这实际上会导致发送操作阻塞，违背了非阻塞模式的设计初衷。 因此，在非阻塞模式下，如果通道缓冲区已满，发送操作不会将数据存入发送队列，而是直接返回 false，以确保发送操作不会阻塞调用者。\n阻塞，创建sudog入队sendq 如果需要阻塞，获取当前 goroutine 并创建一个 sudog 结构体，将其入队到发送队列，然后让 goroutine 进入睡眠状态。 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... // Block on the channel. Some receiver will complete our operation for us. // 在通道上执行阻塞，别的接收者会完成我们的操作。 gp := getg()\t// 函数用于获取当前执行的 goroutine 的指针 mysg := acquireSudog()\t// acquireSudog() 函数用于获取一个 sudog 结构体，表示一个正在等待的 goroutine。 mysg.releasetime = 0\t// 设置mysg的等待时间为0 if t0 != 0 {\t// 如果上文的t0不为0，则将其设置为-1 mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. // 在将 elem 分配给 mysg 并将 mysg 入队到 gp.waiting 之间不能进行堆栈拆分， // copystack 可以在这里找到它。 mysg.elem = ep\t// mysg.elem 设置为要发送的数据的指针。 mysg.waitlink = nil\t// mysg.waitlink 设置为 nil，表示没有下一个等待的 sudog mysg.g = gp\t// mysg.g 设置为当前的 goroutine。 mysg.isSelect = false\t// mysg.isSelect 设置为 false，表示这不是一个 select 操作。 mysg.c = c\t// mysg.c 设置为当前的通道。 gp.waiting = mysg\t// gp.waiting 设置为当前的 sudog，表示当前 goroutine 正在等待。 gp.param = nil\t// gp.param 设置为 nil，表示没有传递参数。 c.sendq.enqueue(mysg)\t// 将mysg入队发送队列 // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. // 向任何试图缩小堆栈的人发出信号，表示我们即将挂起通道。 // 此 G 的状态变化与我们设置 gp.activeStackChans 之间的窗口对于堆栈缩小来说是不安全的。 gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceBlockChanSend, 2) // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren't considered as roots of the // stack tracer. // 确保发送的值在接收者复制它之前保持存活。sudog 有一个指向堆栈对象的指针，但 sudog 并不被视为堆栈跟踪器的根。 // KeepAlive(ep) 的作用是确保发送的值在接收者复制它之前保持存活。即使 goroutine 被挂起，ep 指向的值也不会被垃圾回收器回收。 KeepAlive(ep) ... } 处理唤醒后的操作 如果没有接收者唤醒这个 goroutine，它会一直处于阻塞状态，直到满足以下条件之一：\n有接收者从通道中接收数据，从而释放缓冲区空间，并唤醒发送者。 通道被关闭，此时发送操作会引发 panic。 因此，如果没有接收者唤醒这个 goroutine，它会一直阻塞在 gopark 调用处，直到有接收者接收数据或通道被关闭。\n当被唤醒时，检查是否因为通道关闭而被唤醒，如果是则抛出异常。 这段代码处理的是当发送操作被阻塞后，如何在被唤醒时进行后续处理。具体步骤包括检查等待的 sudog、重置 goroutine 的状态、检查通道是否关闭、记录阻塞事件、重置 sudog 的状态，并处理通道关闭的情况。\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... // someone woke us up. // 有人唤醒这个sudog，如果不是等待的sudog（即当前的mysg，前面设置的），说明等待队列被破坏，抛出错误 if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil\t// 表示当前 goroutine 不再等待 gp.activeStackChans = false\t// 表示当前 goroutine 不再活跃在通道上 closed := !mysg.success\tgp.param = nil // 如果 mysg.releasetime 大于 0，表示记录了阻塞开始的时间，调用 blockevent 函数记录阻塞事件。 if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil\t// mysg.c 设置为 nil，表示 sudog 不再关联任何通道。 releaseSudog(mysg) if closed { if c.closed == 0 { throw(\"chansend: spurious wakeup\") } panic(plainError(\"send on closed channel\")) } return true } send 的作用 send 函数处理在空通道上的发送操作。它将发送者发送的值直接复制到接收者，并唤醒接收者继续其工作。通道必须为空且已锁定，send 函数在完成后会解锁通道。\nsend 处理在空通道上的发送操作。 将发送者发送的值直接复制到接收者。 解锁通道并唤醒接收者继续其工作。 // send processes a send operation on an empty channel c. // send 处理空通道 c 上的发送操作。 // The value ep sent by the sender is copied to the receiver sg. // 发送者发送的值 ep 被复制到接收者 sg。 // The receiver is then woken up to go on its merry way. // 然后唤醒接收者让其继续。 // Channel c must be empty and locked. send unlocks c with unlockf. // 通道 c 必须为空并已上锁。send 使用 unlockf 解锁 c。 // sg must already be dequeued from c. // sg 必须已经从 c 中出队。 // ep must be non-nil and point to the heap or the caller's stack. // ep 必须非空并指向堆或调用者的堆栈。 // 接受一个通道指针、一个等待接收数据的 goroutine 指针、一个数据指针、一个解锁函数和一个用于堆栈跟踪的整数 func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 如果启用了竞争检测 if raceenabled { // 无缓冲通道 if c.dataqsiz == 0 { racesync(c, sg) } else { // Pretend we go through the buffer, even though // we copy directly. Note that we need to increment // the head/tail locations only when raceenabled. // 假装我们通过缓冲区，即使我们直接复制。注意，只有启用竞争检测时才需要增加头尾位置。 racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } } if sg.elem != nil {\t// 表示有数据需要发送 sendDirect(c.elemtype, sg, ep)\t// 直接将数据从发送者复制到接收者，这个也是在runtime2.go中定义 sg.elem = nil\t// 发送完成后，将 sg.elem 设置为 nil } gp := sg.g\t// 获取接收者的 goroutine gp unlockf()\t// 调用 unlockf() 解锁通道 gp.param = unsafe.Pointer(sg)\t// 将接收者的 gp.param 设置为 unsafe.Pointer(sg)，表示接收操作成功 sg.success = true if sg.releasetime != 0 {\t// 如果 sg.releasetime 不为 0，则记录当前时间 cputicks() sg.releasetime = cputicks() } goready(gp, skip+1)\t// 调用 goready(gp, skip+1) 将接收者的 goroutine 设置为可运行状态，准备唤醒接收者 } chanrecv 调用场景 在从ch中接收一个数字的时候，可以看到他这里是调用了runtime.chanrecv1()这个函数\n实现代码和解读 chanrecv1 这个函数实际上内部也是调用了chanrecv函数，其中第三个参数为true\n// entry points for \u003c- c from compiled code. // //go:nosplit func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } chanrecv2 这个函数实际上内部也是调用了chanrecv函数，其中第三个参数为true，同时有一个返回值\n//go:nosplit func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } chanrecv 判断c是否为nil 若为nil且非阻塞则直接返回(false,false)，若为空且阻塞则将它挂起\n// chanrecv receives on channel c and writes the received data to ep. // chanrecv 接收channel c中的元素，并将接收到的数据写给ep // ep may be nil, in which case received data is ignored. // ep可能为nil，这种情况下接收的数据被忽略 // If block == false and no elements are available, returns (false, false). // 如果是非阻塞，同时没有元素可接收，那就return (false, false) // Otherwise, if c is closed, zeros *ep and returns (true, false). // 否则，如果channel c关闭了，那么会将接收数据的指针ep清零，并且函数返回一个表示操作成功但没有数据接收的(true, false) // Otherwise, fills in *ep with an element and returns (true, true). // 否则，用接收到的元素写入到ep所指向的位置，然后return (true, true) // A non-nil ep must point to the heap or the caller's stack. // 一个非空的ep必须指向堆，或者调用者的栈 // 函数签名中的接收参数包括 传递参数的通道c，执行接收位置的指针ep，是否阻塞执行block； // 返回值selected表示通道操作是否被选中执行。在Go语言的上下文中，这通常意味着通道操作是否成功，或者是否因为通道关闭而立即返回。 // received：表示是否成功接收到了数据。 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // raceenabled: don't need to check ep, as it is always on the stack // or is new memory allocated by reflect. if debugChan { print(\"chanrecv: chan=\", c, \"\\n\") } if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceBlockForever, 2) throw(\"unreachable\") } if c.timer != nil { c.timer.maybeRunChan() } Fast Path，看能否在加锁之间返回false 在没有加锁之前判断能不能直接返回false\nempty报告了是否读操作会导致阻塞，即通道是否为空。\n函数返回的时刻，结果是原子性正确的（即没有其他并发操作干扰），并且是顺序一致的（即结果反映了调用时刻的状态）。然而，由于通道在函数返回后没有被锁定，因此通道的状态可能会立即发生变化，变得不为空。\n// empty reports whether a read from c would block (that is, the channel is // empty). It is atomically correct and sequentially consistent at the moment // it returns, but since the channel is unlocked, the channel may become // non-empty immediately afterward. func empty(c *hchan) bool { // c.dataqsiz is immutable. // 检查是否是缓冲通道 if c.dataqsiz == 0 { // 如果是非缓冲通道，那么通过原子操作加载 sendq 队列的第一个元素（first）。sendq 是一个等待发送数据的 goroutine 队列。如果 first 为 nil，则表示没有 goroutine 在等待发送数据，因此通道为空。 return atomic.Loadp(unsafe.Pointer(\u0026c.sendq.first)) == nil } // c.timer is also immutable (it is set after make(chan) but before any channel operations). // All timer channels have dataqsiz \u003e 0. if c.timer != nil { c.timer.maybeRunChan() } // 如果通道是有缓冲的，那么通过原子操作加载 qcount 字段，这个字段表示通道缓冲区中当前的数据项数量。如果 qcount 为0，则表示通道为空。 return atomic.Loaduint(\u0026c.qcount) == 0 } // Fast path: check for failed non-blocking operation without acquiring the lock. if !block \u0026\u0026 empty(c) {\t// 如果接收操作非阻塞且channel为空（这里的empty代表是否会读取之后阻塞） // After observing that the channel is not ready for receiving, we observe whether the // channel is closed. // 在观察到channel没有准备好接收之后，我们观察channel是否是处于关闭状态 // // Reordering of these checks could lead to incorrect behavior when racing with a close. // 这些检查的重新排序可能会在与关闭操作竞争时导致不正确的行为 // For example, if the channel was open and not empty, was closed, and then drained, // reordered reads could incorrectly indicate \"open and empty\". To prevent reordering, // we use atomic loads for both checks, and rely on emptying and closing to happen in // separate critical sections under the same lock. This assumption fails when closing // an unbuffered channel with a blocked send, but that is an error condition anyway. // 例如，如果通道是打开的且非空，然后被关闭，接着被清空， // 重新排序的读取可能会错误地指示“打开且空”。为了防止重新排序， // 我们使用原子加载来进行这两项检查，并依赖于清空和关闭操作在 // 同一个锁下的单独关键部分中发生。这个假设在关闭 // 一个带有阻塞发送的无缓冲通道时失败，但无论如何那都是一个错误条件。 if atomic.Load(\u0026c.closed) == 0 { // Because a channel cannot be reopened, the later observation of the channel // being not closed implies that it was also not closed at the moment of the // first observation. We behave as if we observed the channel at that moment // and report that the receive cannot proceed. // 因为通道不能被重新打开，所以稍后观察到通道 // 未关闭意味着在第一次观察的时刻它也未关闭。我们表现得好像我们在那个时刻观察到了通道 // 并报告接收操作不能继续。 return } // The channel is irreversibly closed. Re-check whether the channel has any pending data // to receive, which could have arrived between the empty and closed checks above. // Sequential consistency is also required here, when racing with such a send. // 通道已经不可逆地关闭。重新检查通道是否有任何待接收的数据 // 这些数据可能在上面的空和关闭检查之间到达。 // 当与这样的发送操作竞争时，这里也需要顺序一致性。 if empty(c) { // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } 初始化和性能监控 如果 blockprofilerate 大于 0，获取当前的 CPU 时间戳 t0 以用于后续的性能分析。 锁定通道 锁定通道 c 的互斥锁。 var t0 int64 if blockprofilerate \u003e 0 { t0 = cputicks() } lock(\u0026c.lock) 如果通道已关闭，检查有无等待的数据和发送者 如果通道已关闭且没有等待的数据： 如果启用了竞态检测，通知竞态检测器通道已关闭。 解锁通道。 如果 ep 不为 nil，清空 ep 指向的内存。 返回 true, false 表示成功接收，但通道已关闭。 否则，如果通道未关闭并且有等待的发送者： 从发送队列中获取一个等待的发送者。 调用 recv 函数处理接收操作并解锁通道。 返回 true, true 表示成功接收并且通道未关闭。 if c.closed != 0 { if c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } // 通道已关闭，但缓冲区中有数据。 } else { // 发现未关闭的等待发送者。 if sg := c.sendq.dequeue(); sg != nil { // 找到等待的发送者。如果缓冲区大小为0，则直接从发送者接收值。 // 否则，从队列头部接收值，并将发送者的值添加到队列尾部（因为队列已满，两者映射到同一缓冲区槽位）。 recv(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true, true } } 如果缓冲区不为空，接收缓冲区数据 如果缓冲区中有数据： 从缓冲区中接收数据到 ep。 清空缓冲区中的数据。 更新接收索引 recvx，如果超过缓冲区大小，重置为 0。 减少缓冲区中的数据计数 qcount。 解锁通道。 返回 true, true 表示成功接收并且通道未关闭。 if c.qcount \u003e 0 { // 直接从队列接收 qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026c.lock) return true, true } 如果是非阻塞，处理非阻塞接收 如果 block 为 false，解锁通道并返回 false, false 表示没有数据可接收且不阻塞。 if !block { unlock(\u0026c.lock) return false, false } 阻塞等待发送者 获取当前 Goroutine。 获取一个 sudog（表示 Goroutine 的结构体）并初始化。 将 ep 指向的内存地址赋值给 sudog。 将当前 Goroutine 设置为等待状态，并将 sudog 加入通道的接收队列。 如果通道有定时器，阻塞定时器。 将 Goroutine 设置为即将阻塞在通道上，调用 gopark 进行阻塞。 // 没有可用的发送者：在此通道上阻塞。 gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // 在分配元素和将mysg入队到gp.waiting之间没有栈分割 // 这样copystack可以在那里找到它。 mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) if c.timer != nil { blockTimerChan(c) } // 向任何试图缩小我们的栈的人发出信号，表明我们即将在通道上停车。 // 在这个G的状态改变和我们设置gp.activeStackChans之间的窗口 // 对于栈缩小是不安全的。 gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceBlockChanRecv, 2) 处理唤醒后的操作 检查 sudog 是否仍在等待列表中，如果不在，抛出异常。 处理定时器解锁。 将 Goroutine 从等待状态中移除，标记为不再阻塞。 处理释放时间。 返回 true 和 sudog 的成功标志。 // someone woke us up if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } if c.timer != nil { unblockTimerChan(c) } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success } recv // recv processes a receive operation on a full channel c. // There are 2 parts: // 1. The value sent by the sender sg is put into the channel // and the sender is woken up to go on its merry way. // 2. The value received by the receiver (the current G) is // written to ep. // recv处理在满通道c上的接收操作。 // 有两个部分： // 1. 发送者sg发送的值被放入通道，发送者被唤醒继续其愉快的旅程。 // 2. 接收者（当前G）接收的值被写入ep。 // // For synchronous channels, both values are the same. // For asynchronous channels, the receiver gets its data from // the channel buffer and the sender's data is put in the // channel buffer. // Channel c must be full and locked. recv unlocks c with unlockf. // sg must already be dequeued from c. // A non-nil ep must point to the heap or the caller's stack. // 对于同步通道，两个值是相同的。 // 对于异步通道，接收者从通道缓冲区获取数据，而发送者的数据被放入通道缓冲区。 // 通道c必须是满的且已锁定。recv通过unlockf解锁c。 // sg必须已经从c中出队。 // 非nil的ep必须指向堆或调用者的栈。 是非缓冲通道？ 如果是非缓冲通道，执行以下步骤：\n如果启用了竞态检测（raceenabled），则调用 racesync(c, sg) 来同步数据。\n如果 ep 不为 nil，则直接从发送者 sg 复制数据到 ep，调用 recvDirect(c.elemtype, sg, ep)。\n// recv的函数签名接收参数：一个接收数据的通道c，sg表示等待在通道上的发送数据的 goroutine，ep表示接收数据写入的地址 // unlock:在接收操作完成后解锁通道; skip:控制某些内部操作的跳过次数 func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 如果是非缓冲通道 if c.dataqsiz == 0 { if raceenabled { racesync(c, sg) } if ep != nil { // copy data from sender recvDirect(c.elemtype, sg, ep) } recvDirect 是Go语言运行时系统的一部分，用于在非缓冲通道上直接从发送者复制数据到接收者\nfunc recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) { // dst is on our stack or the heap, src is on another stack. // The channel is locked, so src will not move during this // operation. src := sg.elem typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.Size_) memmove(dst, src, t.Size_) } 是缓冲通道 如果通道是缓冲通道（即 c.dataqsiz \u003e 0），执行以下步骤：\n获取队列中当前接收位置 c.recvx 的元素 qp，调用 chanbuf(c, c.recvx)。\n如果启用了竞态检测，则调用 racenotify 来通知竞态检测器。\n如果 ep 不为 nil，则从队列 qp 复制数据到接收者 ep，调用 typedmemmove(c.elemtype, ep, qp)。\n从发送者 sg 复制数据到队列 qp，调用 typedmemmove(c.elemtype, qp, sg.elem)。\n更新接收位置 c.recvx，如果它等于缓冲区大小 c.dataqsiz，则将其重置为0，以循环使用缓冲区。\n更新发送位置 c.sendx，使其等于接收位置 c.recvx，因为队列是满的，发送者和接收者指向同一位置。\n} else { // Queue is full. Take the item at the // head of the queue. Make the sender enqueue // its item at the tail of the queue. Since the // queue is full, those are both the same slot. qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) } // copy data from queue to receiver if ep != nil { typedmemmove(c.elemtype, ep, qp) } // copy data from sender to queue typedmemmove(c.elemtype, qp, sg.elem) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } 处理后续 将发送者 sg 的 elem 字段设置为 nil，表示发送者不再持有数据。\n获取发送者 sg 对应的 goroutine gp。\n调用 unlockf() 函数来解锁通道 c，这个函数是在外部传递进来的，用于在接收操作完成后释放通道锁。\n将 gp.param 设置为指向 sg 的 unsafe.Pointer，这通常用于在唤醒 goroutine 时传递参数。\n将 sg.success 设置为 true，表示发送操作成功。\n如果 sg.releasetime 不为0，则将其设置为当前的 CPU 滴答数 cputicks()，这可能用于性能分析。\n调用 goready(gp, skip+1) 来唤醒发送者 sg 对应的 goroutine gp，使其准备好运行，skip+1 参数可能用于控制调度。\nsg.elem = nil gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } closechan 调用场景 关闭通道通过close(ch)实现，在汇编代码中可以看到是调用了runtime.closechan()这个函数\n实现代码和解读 closechan 检查通道是否为空 func closechan(c *hchan) { if c == nil { panic(plainError(\"close of nil channel\")) // 检查通道是否为空，如果为空则抛出异常 } channel加锁，检查是否已经被关闭 lock(\u0026c.lock) // 锁定通道 if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"close of closed channel\")) // 检查通道是否已经关闭，如果已关闭则抛出异常 } 竞态检测相关操作 if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) // 记录当前调用者的程序计数器 racerelease(c.raceaddr()) // 进行相关竞态检测操作 } 标记为通道已关闭 c.closed = 1 // 标记通道为已关闭 释放所有等待接收的G var glist gList // 释放所有等待接收的 Goroutine for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) // 清空接收的元素 sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() // 记录释放时间 } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) // 竞态检测 } glist.push(gp) // 将 Goroutine 加入列表 } 释放所有等待发送的G // 释放所有等待发送的 Goroutine（它们将会 panic） for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() // 记录释放时间 } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) // 竞态检测 } glist.push(gp) // 将 Goroutine 加入列表 } unlock(\u0026c.lock) // 解锁通道 释放通道锁，唤醒所有G // 现在已经释放了通道锁，唤醒所有 Goroutine for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) // 唤醒 Goroutine } } ","wordCount":"4092","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-05-10T00:00:00Z","dateModified":"2024-05-10T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/go-srccode/go-channel/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【go的源码阅读】channel的实现：chan.go</h1><div class=post-meta><span title='2024-05-10 00:00:00 +0000 UTC'>May 10, 2024</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;4092 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#channel%e7%9a%84%e7%ae%80%e5%8d%95%e4%bd%bf%e7%94%a8 aria-label=channel的简单使用>channel的简单使用</a><ul><li><a href=#%e5%ba%95%e5%b1%82%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8 aria-label=底层函数调用>底层函数调用</a></li></ul></li><li><a href=#chango%e4%b8%ad%e5%8c%85%e5%90%ab%e7%9a%84%e7%b1%bb aria-label=chan.go中包含的类>chan.go中包含的类</a><ul><li><a href=#hchan%e5%92%8cwaitq aria-label=hchan和waitq>hchan和waitq</a><ul><li><a href=#%e5%85%b3%e4%ba%8esudog%e7%9a%84%e8%a1%a5%e5%85%85%e4%bb%8b%e7%bb%8d aria-label=关于sudog的补充介绍>关于sudog的补充介绍</a></li></ul></li><li><a href=#makechan aria-label=makechan>makechan</a><ul><li><a href=#%e8%b0%83%e7%94%a8%e5%9c%ba%e6%99%af aria-label=调用场景>调用场景</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81 aria-label=实现代码>实现代码</a></li><li><a href=#%e8%a7%a3%e8%af%bb aria-label=解读>解读</a><ul><li><a href=#switch%e9%83%a8%e5%88%86%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98 aria-label=switch部分，分配内存>switch部分，分配内存</a></li><li><a href=#%e5%85%b6%e4%bb%96%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=其他初始化>其他初始化</a></li></ul></li></ul></li><li><a href=#chansend aria-label=chansend>chansend</a><ul><li><a href=#%e8%b0%83%e7%94%a8%e5%9c%ba%e6%99%af-1 aria-label=调用场景>调用场景</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81%e5%92%8c%e8%a7%a3%e8%af%bb aria-label=实现代码和解读>实现代码和解读</a><ul><li><a href=#chansend1 aria-label=chansend1>chansend1</a></li><li><a href=#chansend1-%e5%92%8c-chansend-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="chansend1 和 chansend 的区别">chansend1 和 chansend 的区别</a></li><li><a href=#chansend%e7%9a%84%e5%87%bd%e6%95%b0%e7%ad%be%e5%90%8d%e8%a7%a3%e8%af%bb aria-label=chansend的函数签名解读>chansend的函数签名解读</a></li><li><a href=#chansend-1 aria-label=chansend>chansend</a><ul><li><a href=#%e6%a3%80%e6%9f%a5%e9%80%9a%e9%81%93%e6%98%af%e5%90%a6%e4%b8%banil aria-label=检查通道是否为nil>检查通道是否为nil</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e7%ad%be%e5%90%8d aria-label=函数签名>函数签名</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label=使用场景>使用场景</a><ul><ul><ul><li><a href=#fast-path%e6%a3%80%e6%9f%a5%e9%80%9a%e9%81%93%e6%98%af%e5%90%a6%e6%9c%aa%e5%85%b3%e9%97%ad%e9%9d%9e%e9%98%bb%e5%a1%9e%e4%b8%94%e5%b7%b2%e6%bb%a1 aria-label="Fast Path，检查通道是否未关闭非阻塞且已满">Fast Path，检查通道是否未关闭非阻塞且已满</a></li><li><a href=#%e5%8a%a0%e9%94%81%e5%b9%b6%e5%88%a4%e6%96%adchannel%e6%98%af%e5%90%a6%e5%85%b3%e9%97%ad aria-label=加锁，并判断channel是否关闭>加锁，并判断channel是否关闭</a></li><li><a href=#%e5%a6%82%e6%9e%9c%e6%9c%89%e7%ad%89%e5%be%85%e7%9a%84%e6%8e%a5%e5%8f%97%e8%80%85 aria-label=如果有等待的接受者>如果有等待的接受者</a></li><li><a href=#%e5%a6%82%e6%9e%9c%e7%bc%93%e5%86%b2%e5%8c%ba%e6%9c%89%e7%a9%ba%e9%97%b4 aria-label=如果缓冲区有空间>如果缓冲区有空间</a></li><li><a href=#%e7%bc%93%e5%86%b2%e5%8c%ba%e5%b7%b2%e6%bb%a1%e5%a6%82%e6%9e%9c%e6%98%af%e9%9d%9e%e9%98%bb%e5%a1%9e aria-label=缓冲区已满，如果是非阻塞>缓冲区已满，如果是非阻塞</a></li></ul></ul></ul></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%9a%84%e4%b8%8d%e4%bc%9a%e5%ad%98%e5%85%a5%e5%88%b0%e5%8f%91%e9%80%81%e9%98%9f%e5%88%97 aria-label=为什么非阻塞的不会存入到发送队列？>为什么非阻塞的不会存入到发送队列？</a><ul><ul><ul><li><a href=#%e9%98%bb%e5%a1%9e%e5%88%9b%e5%bb%basudog%e5%85%a5%e9%98%9fsendq aria-label=阻塞，创建sudog入队sendq>阻塞，创建sudog入队sendq</a></li><li><a href=#%e5%a4%84%e7%90%86%e5%94%a4%e9%86%92%e5%90%8e%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=处理唤醒后的操作>处理唤醒后的操作</a></li></ul><li><a href=#send-%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label="send 的作用">send 的作用</a></li><li><a href=#send aria-label=send>send</a></li></ul></ul></li><li><a href=#chanrecv aria-label=chanrecv>chanrecv</a><ul><li><a href=#%e8%b0%83%e7%94%a8%e5%9c%ba%e6%99%af-2 aria-label=调用场景>调用场景</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81%e5%92%8c%e8%a7%a3%e8%af%bb-1 aria-label=实现代码和解读>实现代码和解读</a><ul><li><a href=#chanrecv1 aria-label=chanrecv1>chanrecv1</a></li><li><a href=#chanrecv2 aria-label=chanrecv2>chanrecv2</a></li><li><a href=#chanrecv-1 aria-label=chanrecv>chanrecv</a><ul><li><a href=#%e5%88%a4%e6%96%adc%e6%98%af%e5%90%a6%e4%b8%banil aria-label=判断c是否为nil>判断c是否为nil</a></li><li><a href=#fast-path%e7%9c%8b%e8%83%bd%e5%90%a6%e5%9c%a8%e5%8a%a0%e9%94%81%e4%b9%8b%e9%97%b4%e8%bf%94%e5%9b%9efalse aria-label="Fast Path，看能否在加锁之间返回false">Fast Path，看能否在加锁之间返回false</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%92%8c%e6%80%a7%e8%83%bd%e7%9b%91%e6%8e%a7 aria-label=初始化和性能监控><strong>初始化和性能监控</strong></a></li><li><a href=#%e9%94%81%e5%ae%9a%e9%80%9a%e9%81%93 aria-label=锁定通道><strong>锁定通道</strong></a></li><li><a href=#%e5%a6%82%e6%9e%9c%e9%80%9a%e9%81%93%e5%b7%b2%e5%85%b3%e9%97%ad%e6%a3%80%e6%9f%a5%e6%9c%89%e6%97%a0%e7%ad%89%e5%be%85%e7%9a%84%e6%95%b0%e6%8d%ae%e5%92%8c%e5%8f%91%e9%80%81%e8%80%85 aria-label=如果通道已关闭，检查有无等待的数据和发送者>如果通道已关闭，检查有无等待的数据和发送者</a></li><li><a href=#%e5%a6%82%e6%9e%9c%e7%bc%93%e5%86%b2%e5%8c%ba%e4%b8%8d%e4%b8%ba%e7%a9%ba%e6%8e%a5%e6%94%b6%e7%bc%93%e5%86%b2%e5%8c%ba%e6%95%b0%e6%8d%ae aria-label=如果缓冲区不为空，接收缓冲区数据>如果缓冲区不为空，接收缓冲区数据</a></li><li><a href=#%e5%a6%82%e6%9e%9c%e6%98%af%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%a4%84%e7%90%86%e9%9d%9e%e9%98%bb%e5%a1%9e%e6%8e%a5%e6%94%b6 aria-label=如果是非阻塞，处理非阻塞接收>如果是非阻塞，处理非阻塞接收</a></li><li><a href=#%e9%98%bb%e5%a1%9e%e7%ad%89%e5%be%85%e5%8f%91%e9%80%81%e8%80%85 aria-label=阻塞等待发送者><strong>阻塞等待发送者</strong></a></li><li><a href=#%e5%a4%84%e7%90%86%e5%94%a4%e9%86%92%e5%90%8e%e7%9a%84%e6%93%8d%e4%bd%9c-1 aria-label=处理唤醒后的操作><strong>处理唤醒后的操作</strong></a></li></ul></li><li><a href=#recv aria-label=recv>recv</a><ul><li><a href=#%e6%98%af%e9%9d%9e%e7%bc%93%e5%86%b2%e9%80%9a%e9%81%93 aria-label=是非缓冲通道？>是非缓冲通道？</a></li><li><a href=#%e6%98%af%e7%bc%93%e5%86%b2%e9%80%9a%e9%81%93 aria-label=是缓冲通道>是缓冲通道</a></li><li><a href=#%e5%a4%84%e7%90%86%e5%90%8e%e7%bb%ad aria-label=处理后续>处理后续</a></li></ul></li></ul></li></ul></li><li><a href=#closechan aria-label=closechan>closechan</a><ul><li><a href=#%e8%b0%83%e7%94%a8%e5%9c%ba%e6%99%af-3 aria-label=调用场景>调用场景</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81%e5%92%8c%e8%a7%a3%e8%af%bb-2 aria-label=实现代码和解读>实现代码和解读</a><ul><li><a href=#closechan-1 aria-label=closechan>closechan</a><ul><li><a href=#%e6%a3%80%e6%9f%a5%e9%80%9a%e9%81%93%e6%98%af%e5%90%a6%e4%b8%ba%e7%a9%ba aria-label=检查通道是否为空>检查通道是否为空</a></li><li><a href=#channel%e5%8a%a0%e9%94%81%e6%a3%80%e6%9f%a5%e6%98%af%e5%90%a6%e5%b7%b2%e7%bb%8f%e8%a2%ab%e5%85%b3%e9%97%ad aria-label=channel加锁，检查是否已经被关闭>channel加锁，检查是否已经被关闭</a></li><li><a href=#%e7%ab%9e%e6%80%81%e6%a3%80%e6%b5%8b%e7%9b%b8%e5%85%b3%e6%93%8d%e4%bd%9c aria-label=竞态检测相关操作>竞态检测相关操作</a></li><li><a href=#%e6%a0%87%e8%ae%b0%e4%b8%ba%e9%80%9a%e9%81%93%e5%b7%b2%e5%85%b3%e9%97%ad aria-label=标记为通道已关闭>标记为通道已关闭</a></li><li><a href=#%e9%87%8a%e6%94%be%e6%89%80%e6%9c%89%e7%ad%89%e5%be%85%e6%8e%a5%e6%94%b6%e7%9a%84g aria-label=释放所有等待接收的G>释放所有等待接收的G</a></li><li><a href=#%e9%87%8a%e6%94%be%e6%89%80%e6%9c%89%e7%ad%89%e5%be%85%e5%8f%91%e9%80%81%e7%9a%84g aria-label=释放所有等待发送的G>释放所有等待发送的G</a></li><li><a href=#%e9%87%8a%e6%94%be%e9%80%9a%e9%81%93%e9%94%81%e5%94%a4%e9%86%92%e6%89%80%e6%9c%89g aria-label=释放通道锁，唤醒所有G>释放通道锁，唤醒所有G</a></li></ul></li></ul></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=channel的简单使用>channel的简单使用<a hidden class=anchor aria-hidden=true href=#channel的简单使用>#</a></h2><p>在Go语言中，通道（channel）是一种用于在goroutine之间进行通信和同步的机制。下面是一些简单的通道使用示例，以及它们对应的底层函数调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=c1>// 创建通道
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>42</span> <span class=c1>// 发送数据到通道
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>value</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span> <span class=c1>// 从通道接收数据
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Received:&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 等待goroutine完成
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span> <span class=c1>// 关闭通道
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=底层函数调用>底层函数调用<a hidden class=anchor aria-hidden=true href=#底层函数调用>#</a></h3><ol><li><p><strong>创建通道</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span></code></pre></div><p>底层调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>makechan</span><span class=p>(</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
</span></span></code></pre></div></li><li><p><strong>发送数据到通道</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>42</span>
</span></span></code></pre></div><p>底层调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span>
</span></span></code></pre></div></li><li><p><strong>从通道接收数据</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>value</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>ch</span>
</span></span></code></pre></div><p>底层调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>chanrecv</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>(</span><span class=nx>selected</span><span class=p>,</span> <span class=nx>received</span> <span class=kt>bool</span><span class=p>)</span>
</span></span></code></pre></div></li><li><p><strong>关闭通道</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span></code></pre></div><p>底层调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>closechan</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>)</span>
</span></span></code></pre></div></li></ol><p>这些底层函数是Go运行时系统的一部分，用于实现通道的底层操作。通过这些函数，Go语言能够在goroutine之间进行高效、安全的通信和同步。</p><h2 id=chango中包含的类>chan.go中包含的类<a hidden class=anchor aria-hidden=true href=#chango中包含的类>#</a></h2><h3 id=hchan和waitq>hchan和waitq<a hidden class=anchor aria-hidden=true href=#hchan和waitq>#</a></h3><p>chan.go中有两个struct:</p><ul><li>hchan, channel的内部实现</li><li>waitq, hchan中的recvq和sendq的数据结构</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>hchan</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>qcount</span>   <span class=kt>uint</span>           <span class=c1>// total data in the queue，队列中总的元素数量
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>dataqsiz</span> <span class=kt>uint</span>           <span class=c1>// size of the circular queue，环形缓冲区buffer的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>buf</span>      <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// points to an array of dataqsiz elements，指向buffer中元素的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>elemsize</span> <span class=kt>uint16</span>			<span class=c1>// 表示channel中元素的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>closed</span>   <span class=kt>uint32</span>			<span class=c1>// 是否关闭，0表示该channel没有关闭
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>timer</span>    <span class=o>*</span><span class=nx>timer</span> <span class=c1>// timer feeding this chan
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>elemtype</span> <span class=o>*</span><span class=nx>_type</span> <span class=c1>// element type，channel中元素的类型
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sendx</span>    <span class=kt>uint</span>   <span class=c1>// send index，buffer中应该发送的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>recvx</span>    <span class=kt>uint</span>   <span class=c1>// receive index，buffer中接收元素的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>recvq</span>    <span class=nx>waitq</span>  <span class=c1>// list of recv waiters，接受者队列
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sendq</span>    <span class=nx>waitq</span>  <span class=c1>// list of send waiters，发送者队列
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// lock protects all fields in hchan, as well as several
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// fields in sudogs blocked on this channel.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Do not change another G&#39;s status while holding this lock
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// (in particular, do not ready a G), as this can deadlock
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// with stack shrinking.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>lock</span> <span class=nx>mutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// waitq由一个双向链表实现，元素类型是指向sudog的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>waitq</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>first</span> <span class=o>*</span><span class=nx>sudog</span>	
</span></span><span class=line><span class=cl>	<span class=nx>last</span>  <span class=o>*</span><span class=nx>sudog</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=关于sudog的补充介绍>关于sudog的补充介绍<a hidden class=anchor aria-hidden=true href=#关于sudog的补充介绍>#</a></h4><blockquote><p>在Go语言中，<code>sudog</code> 是一个重要的数据结构，用于在goroutine之间进行通信和同步。它是 &ldquo;<strong>S</strong>elector <strong>U</strong>ser-space <strong>D</strong>ata <strong>O</strong>bject <strong>G</strong>roup&rdquo; 的缩写，表示在用户空间中用于选择器的数据对象组。</p><p><code>sudog</code> 主要用于实现Go语言中的 <code>select</code> 语句和通道（channel）操作。当一个goroutine在等待通道操作（如发送或接收数据）时，它会被转换为一个 <code>sudog</code> 结构体，并被添加到相应的等待队列中。这样，调度器可以管理这些等待的goroutine，并在通道操作完成后唤醒它们。</p><p>以下是 <code>sudog</code> 结构体的一些关键字段：</p><ul><li><code>g *g</code>：指向当前等待的goroutine。</li><li><code>elem unsafe.Pointer</code>：指向发送或接收的数据元素。</li><li><code>c *hchan</code>：指向正在操作的通道。</li><li><code>selectDone uint32</code>：用于选择器操作的完成标志。</li><li><code>ticket uint32</code>：用于公平调度。</li></ul><p><code>sudog</code> 结构体的具体实现可以在Go语言的源码中找到，通常位于 <code>runtime</code> 包中。通过使用 <code>sudog</code>，Go语言的调度器能够高效地管理goroutine的等待和唤醒，从而实现高效的并发编程。</p><p>总结来说，<code>sudog</code> 是Go语言运行时系统中的一个关键数据结构，用于管理goroutine在通道操作中的等待和同步。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// src/runtime/runtime2.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>sudog</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// The following fields are protected by the hchan.lock of the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// channel this sudog is blocking on. shrinkstack depends on
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// this for sudogs involved in channel ops.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 以下字段受该 sudog 所阻塞的通道的 hchan.lock 保护。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// shrinkstack 依赖这些字段来处理涉及通道操作的 sudogs。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span> <span class=o>*</span><span class=nx>g</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>next</span> <span class=o>*</span><span class=nx>sudog</span>
</span></span><span class=line><span class=cl>	<span class=nx>prev</span> <span class=o>*</span><span class=nx>sudog</span>
</span></span><span class=line><span class=cl>	<span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// data element (may point to stack)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 数据元素（可能指向堆栈）
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// The following fields are never accessed concurrently.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// For channels, waitlink is only accessed by g.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// For semaphores, all fields (including the ones above)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// are only accessed when holding a semaRoot lock.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 以下字段从未被并发访问。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 对于通道，waitlink 只被 g 访问。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 对于信号量，所有字段（包括上述字段）仅在持有 semaRoot 锁时访问。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>acquiretime</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=nx>releasetime</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=nx>ticket</span>      <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// isSelect indicates g is participating in a select, so
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// g.selectDone must be CAS&#39;d to win the wake-up race.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// isSelect 表示 g 正在参与 select，因此 g.selectDone 必须通过 CAS 来赢得唤醒竞争。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>isSelect</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// success indicates whether communication over channel c
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// succeeded. It is true if the goroutine was awoken because a
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// value was delivered over channel c, and false if awoken
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// because c was closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// success 表示通过通道 c 的通信是否成功。如果 goroutine 是因为值通过通道 c 传递而被唤醒，则为 true；
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 如果是因为 c 被关闭而被唤醒，则为 false。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>success</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// waiters is a count of semaRoot waiting list other than head of list,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// clamped to a uint16 to fit in unused space.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Only meaningful at the head of the list.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// (If we wanted to be overly clever, we could store a high 16 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// in the second entry in the list.)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// waiters 是 semaRoot 等待列表中除列表头外的计数，被限制为 uint16 以适应未使用的空间。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 仅在列表头有意义。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// （如果我们想过于聪明，我们可以将高 16 位存储在列表的第二个条目中。）
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>waiters</span> <span class=kt>uint16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>parent</span>   <span class=o>*</span><span class=nx>sudog</span> <span class=c1>// semaRoot binary tree // semaRoot 二叉树
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>waitlink</span> <span class=o>*</span><span class=nx>sudog</span> <span class=c1>// g.waiting list or semaRoot // g.waiting 列表或 semaRoot
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>waittail</span> <span class=o>*</span><span class=nx>sudog</span> <span class=c1>// semaRoot
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>c</span>        <span class=o>*</span><span class=nx>hchan</span> <span class=c1>// channel // 通道
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=makechan>makechan<a hidden class=anchor aria-hidden=true href=#makechan>#</a></h3><h4 id=调用场景>调用场景<a hidden class=anchor aria-hidden=true href=#调用场景>#</a></h4><p>在调用<code>ch := make(chan int,2)</code>函数的时候，编译之后可以发现他调用了makechan这个函数.</p><p>使用的在线的一个<a href=https://godbolt.org/>查看汇编代码的网站</a></p><p><img loading=lazy src=https://s2.loli.net/2024/06/22/p2WY9cwVSj1uDFy.png alt=makechan></p><h4 id=实现代码>实现代码<a hidden class=anchor aria-hidden=true href=#实现代码>#</a></h4><p>这是makechan的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makechan</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>chantype</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>hchan</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>elem</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Elem</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// compiler checks this but be safe.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>16</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;makechan: invalid channel element type&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>hchanSize</span><span class=o>%</span><span class=nx>maxAlign</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>elem</span><span class=p>.</span><span class=nx>Align_</span> <span class=p>&gt;</span> <span class=nx>maxAlign</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;makechan: bad alignment&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>mem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>mem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span><span class=o>-</span><span class=nx>hchanSize</span> <span class=o>||</span> <span class=nx>size</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;makechan: size out of range&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// buf points into the same allocation, elemtype is persistent.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>mem</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Queue or element size is zero.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>hchan</span><span class=p>)(</span><span class=nf>mallocgc</span><span class=p>(</span><span class=nx>hchanSize</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>true</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Race detector uses this location for synchronization.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span><span class=p>.</span><span class=nx>buf</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=p>!</span><span class=nx>elem</span><span class=p>.</span><span class=nf>Pointers</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Elements do not contain pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Allocate hchan and buf in one call.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>hchan</span><span class=p>)(</span><span class=nf>mallocgc</span><span class=p>(</span><span class=nx>hchanSize</span><span class=o>+</span><span class=nx>mem</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>true</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>buf</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>c</span><span class=p>),</span> <span class=nx>hchanSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Elements contain pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>hchan</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>buf</span> <span class=p>=</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>mem</span><span class=p>,</span> <span class=nx>elem</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>elemsize</span> <span class=p>=</span> <span class=nb>uint16</span><span class=p>(</span><span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span> <span class=p>=</span> <span class=nx>elem</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=p>=</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankHchan</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>debugChan</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s>&#34;makechan: chan=&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;; elemsize=&#34;</span><span class=p>,</span> <span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=p>,</span> <span class=s>&#34;; dataqsiz=&#34;</span><span class=p>,</span> <span class=nx>size</span><span class=p>,</span> <span class=s>&#34;\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=解读>解读<a hidden class=anchor aria-hidden=true href=#解读>#</a></h4><h5 id=switch部分分配内存>switch部分，分配内存<a hidden class=anchor aria-hidden=true href=#switch部分分配内存>#</a></h5><p><code>mem</code> 是一个 <code>uintptr</code> 类型的变量，用于表示通道缓冲区所需的总内存大小。</p><blockquote><p><code>uintptr</code> 的大小足以容纳任何指针的位模式，因此它可以用来进行指针运算和存储指针地址。</p><p>在 Go 语言中，<code>uintptr</code> 通常用于以下几种情况：</p><ol><li><strong>指针运算</strong>：由于 <code>uintptr</code> 可以表示指针的整数形式，因此可以用于指针运算，例如计算指针的偏移量。</li><li><strong>与 <code>unsafe</code> 包结合使用</strong>：<code>unsafe</code> 包提供了一些不安全的操作，例如将指针转换为 <code>uintptr</code> 或将 <code>uintptr</code> 转换为指针。这在进行底层内存操作时非常有用。</li><li><strong>存储指针地址</strong>：在某些情况下，需要将指针地址存储在一个整数类型中，这时可以使用 <code>uintptr</code>。</li></ol><p>需要注意的是，<code>uintptr</code> 不是一个指针类型，因此它不会阻止垃圾回收器回收它所表示的内存。如果需要保持对象存活，应该使用实际的指针类型（如 <code>*T</code>），而不是 <code>uintptr</code>。</p></blockquote><p>通过这里的代码得到：<code>mem, overflow := math.MulUintptr(elem.Size_, uintptr(size))</code></p><p><code>mem</code> 是通过将通道元素的大小（<code>elem.Size_</code>）与通道缓冲区的大小（<code>size</code>）相乘得到的。这个计算过程是通过调用 <code>math.MulUintptr</code> 函数来完成的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>mem</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Queue or element size is zero.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 缓冲区buf大小为0，或者通道元素的大小为0
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>hchan</span><span class=p>)(</span><span class=nf>mallocgc</span><span class=p>(</span><span class=nx>hchanSize</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>true</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Race detector uses this location for synchronization.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span><span class=p>.</span><span class=nx>buf</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=p>!</span><span class=nx>elem</span><span class=p>.</span><span class=nf>Pointers</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Elements do not contain pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 元素不包含指针
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Allocate hchan and buf in one call.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 通过一次调用分配给hchan和buf内存
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>hchan</span><span class=p>)(</span><span class=nf>mallocgc</span><span class=p>(</span><span class=nx>hchanSize</span><span class=o>+</span><span class=nx>mem</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>true</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>buf</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>c</span><span class=p>),</span> <span class=nx>hchanSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Elements contain pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 元素包含指针
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>c</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>hchan</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>buf</span> <span class=p>=</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>mem</span><span class=p>,</span> <span class=nx>elem</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><ol><li><p><strong><code>mem == 0</code> 的情况：</strong></p><ul><li>如果 <code>mem</code> 为 0，这意味着通道的缓冲区大小为 0 或者通道元素的大小为 0。</li><li>在这种情况下，代码调用 <code>mallocgc</code> 函数分配 <code>hchanSize</code> 大小的内存，并将返回的内存地址转换为 <code>*hchan</code> 类型，赋值给 <code>c</code>。</li></ul><blockquote><p><code>mallocgc</code> 是 Go 语言运行时系统中的一个内部函数，用于分配内存并进行垃圾回收（GC）标记。由于它是运行时系统的内部函数，通常不会直接在用户代码中使用。相反，用户代码中会使用更高层次的内存分配函数，如 <code>new</code>、<code>make</code> 等，这些函数会在内部调用 <code>mallocgc</code>。</p><p>其他的内存分配函数还有:<code>newobject</code>，也是调用了<code>mallocgc()</code></p><p>它的函数签名如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>size</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>typ</span> <span class=o>*</span><span class=nx>_type</span><span class=p>,</span> <span class=nx>needzero</span> <span class=kt>bool</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span></code></pre></div><p>这个函数的参数和返回值解释如下：</p><ul><li><code>size uintptr</code>：需要分配的内存大小，以字节为单位。</li><li><code>typ *_type</code>：指向类型信息的指针。<code>_type</code> 是 Go 语言中表示类型信息的一个结构体。</li><li><code>needzero bool</code>：一个布尔值，表示是否需要将分配的内存初始化为零。</li></ul><p>返回值：</p><ul><li><code>unsafe.Pointer</code>：返回一个指向新分配内存的 <code>unsafe.Pointer</code> 指针。</li></ul><p><code>mallocgc</code> 函数的主要作用是分配指定大小的内存，并根据需要进行零初始化。同时，它还会对分配的内存进行垃圾回收标记，以便垃圾回收器能够正确地管理这些内存。</p></blockquote><ul><li><code>c.buf = c.raceaddr()</code> 这一行是用于竞态检测器（race detector）的同步操作。</li></ul></li><li><p><strong><code>!elem.Pointers()</code> 的情况：</strong></p><ul><li>如果通道元素不包含指针（即元素是基本类型或不包含指针的结构体），则调用 <code>mallocgc</code> 函数一次性分配 <code>hchanSize + mem</code> 大小的内存。</li><li>这里 <code>hchanSize</code> 是 <code>hchan</code> 结构体的大小，<code>mem</code> 是通道缓冲区的大小。</li><li>分配的内存中，前 <code>hchanSize</code> 字节用于存储 <code>hchan</code> 结构体，后面的 <code>mem</code> 字节用于存储通道缓冲区。</li><li><code>c.buf = add(unsafe.Pointer(c), hchanSize)</code> 这一行将 <code>c.buf</code> 指向缓冲区的起始位置。<code>add</code> 函数用于计算指针的偏移量。</li></ul></li><li><p><strong>默认情况（<code>default</code>）：</strong></p><ul><li>如果通道元素包含指针（即元素是包含指针的结构体），则首先调用 <code>new(hchan)</code> 分配 <code>hchan</code> 结构体的内存。</li><li>然后调用 <code>mallocgc</code> 函数分配 <code>mem</code> 大小的内存用于通道缓冲区，并将返回的内存地址赋值给 <code>c.buf</code>。</li><li>这种情况下，<code>hchan</code> 结构体和缓冲区是分开分配的。</li></ul></li></ol><p>总结来说，这段代码根据通道元素是否包含指针以及缓冲区大小是否为 0，选择不同的内存分配策略。这样可以优化内存使用，并确保在元素包含指针时能够正确地进行垃圾回收。</p><h5 id=其他初始化>其他初始化<a hidden class=anchor aria-hidden=true href=#其他初始化>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>c</span><span class=p>.</span><span class=nx>elemsize</span> <span class=p>=</span> <span class=nb>uint16</span><span class=p>(</span><span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span> <span class=p>=</span> <span class=nx>elem</span>
</span></span><span class=line><span class=cl><span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=p>=</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>lockRankHchan</span><span class=p>)</span>
</span></span></code></pre></div><p>这一段是对c（hchan）的元素大小、元素类型、缓冲区大小、锁进行初始化。</p><h3 id=chansend>chansend<a hidden class=anchor aria-hidden=true href=#chansend>#</a></h3><h4 id=调用场景-1>调用场景<a hidden class=anchor aria-hidden=true href=#调用场景-1>#</a></h4><p><img loading=lazy src=https://s2.loli.net/2024/06/22/Yf7BUSAtNVbmDp2.png alt=chansend1></p><h4 id=实现代码和解读>实现代码和解读<a hidden class=anchor aria-hidden=true href=#实现代码和解读>#</a></h4><h5 id=chansend1>chansend1<a hidden class=anchor aria-hidden=true href=#chansend1>#</a></h5><ul><li>调用 <code>chansend</code> 函数，传递通道、元素指针、阻塞标志（<code>true</code>）和调用者的程序计数器。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// entry point for c &lt;- x from compiled code.
</span></span></span><span class=line><span class=cl><span class=c1>// 编译代码中 c &lt;- x 的入口点。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//go:nosplit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>chansend1</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>elem</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nf>getcallerpc</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=chansend1-和-chansend-的区别>chansend1 和 chansend 的区别<a hidden class=anchor aria-hidden=true href=#chansend1-和-chansend-的区别>#</a></h5><ul><li><code>chansend1</code> 是一个包装函数，用于在编译代码中调用 <code>chansend</code>。它总是以阻塞模式调用 <code>chansend</code>，即 <code>block</code> 参数为 <code>true</code>。</li><li><code>chansend</code> 是实际执行发送操作的函数，它可以以阻塞或非阻塞模式工作，具体取决于 <code>block</code> 参数的值。</li></ul><h5 id=chansend的函数签名解读>chansend的函数签名解读<a hidden class=anchor aria-hidden=true href=#chansend的函数签名解读>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span>
</span></span></code></pre></div><ol><li><strong><code>ep unsafe.Pointer</code></strong>：这是函数的第二个参数。<code>ep</code> 是参数名，<code>unsafe.Pointer</code> 是参数类型。<code>unsafe.Pointer</code> 是一个可以指向任意类型数据的指针类型，通常用于与 Go 的内存管理进行低级别的交互。</li><li><strong><code>block bool</code></strong>：这是函数的第三个参数。<code>block</code> 是参数名，<code>bool</code> 是参数类型。<code>bool</code> 类型表示一个布尔值，可以是 <code>true</code> 或 <code>false</code>。这个参数<strong>用于指示函数是否应该在无法立即完成发送操作时阻塞</strong>。</li><li><strong><code>callerpc uintptr</code></strong>：这是函数的第四个参数。<code>callerpc</code> 是参数名，<code>uintptr</code> 是参数类型。<code>uintptr</code> 是一个无符号整数类型，通常用于表示指针的数值。<code>callerpc</code> 通常用于记录调用者的程序计数器（program counter），以便进行调试或性能分析。</li></ol><h5 id=chansend-1>chansend<a hidden class=anchor aria-hidden=true href=#chansend-1>#</a></h5><h6 id=检查通道是否为nil>检查通道是否为nil<a hidden class=anchor aria-hidden=true href=#检查通道是否为nil>#</a></h6><ul><li>检查通道是否为 <code>nil</code>，如果是非阻塞模式则返回 <code>false</code>，否则让当前 goroutine 进入永久睡眠状态。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 通道为空并且不阻塞，直接返回false
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>!</span><span class=nx>block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 能执行到这里表示通道为空并且block==true，则调用gopark
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>gopark</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>waitReasonChanSendNilChan</span><span class=p>,</span> <span class=nx>traceBlockForever</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;unreachable&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><code>gopark</code> 是 Go 语言运行时系统中的一个内部函数，用于将当前的 goroutine 挂起（park），使其进入等待状态。这个函数通常在需要让出 CPU 时间片或等待某个条件满足时使用。</p><h3 id=函数签名>函数签名<a hidden class=anchor aria-hidden=true href=#函数签名>#</a></h3><p><code>gopark</code> 的函数签名如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>gopark</span><span class=p>(</span><span class=nx>unlockf</span> <span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>lock</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>reason</span> <span class=nx>waitReason</span><span class=p>,</span> <span class=nx>traceEv</span> <span class=kt>byte</span><span class=p>,</span> <span class=nx>traceskip</span> <span class=kt>int</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><code>上面的这些判断被称为 fast path，因为加锁的操作是一个很重的操作，所以能够在加锁之前返回的判断就在加锁之前做好是最好的unlockf</code>：一个函数，用于在挂起 goroutine 之前解锁某些资源。这个函数的签名是 <code>func(*g, unsafe.Pointer) bool</code>，其中 <code>*g</code> 是当前 goroutine 的结构体，<code>unsafe.Pointer</code> 是一个指向任意数据的指针。</li><li><code>lock</code>：一个指向锁的指针，用于在挂起 goroutine 之前解锁。</li><li><code>reason</code>：一个 <code>waitReason</code> 类型的值，表示 goroutine 挂起的原因。</li><li><code>traceEv</code>：一个字节值，用于跟踪事件。</li><li><code>traceskip</code>：一个整数值，表示跟踪的跳过层数。</li></ul><h3 id=使用场景>使用场景<a hidden class=anchor aria-hidden=true href=#使用场景>#</a></h3><p><code>gopark</code> 通常在以下几种情况下使用：</p><ol><li><strong>等待通道操作</strong>：当 goroutine 在等待通道的发送或接收操作时，如果通道当前不可用，goroutine 会被挂起。</li><li><strong>等待锁</strong>：当 goroutine 尝试获取一个已经被其他 goroutine 持有的锁时，它会被挂起，直到锁被释放。</li><li><strong>等待条件变量</strong>：当 goroutine 在等待某个条件变量满足时，它会被挂起，直到条件变量被通知。</li></ol></blockquote><h6 id=fast-path检查通道是否未关闭非阻塞且已满>Fast Path，检查通道是否未关闭非阻塞且已满<a hidden class=anchor aria-hidden=true href=#fast-path检查通道是否未关闭非阻塞且已满>#</a></h6><ul><li>如果通道未关闭且未准备好发送（即通道已满），在非阻塞模式下返回 <code>false</code>。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 非阻塞，未关闭，通道已满
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>block</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span><span class=p>.</span><span class=nx>closed</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nf>full</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><code>full()</code>也是在runtime2.go中定义的一个函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// full reports whether a send on c would block (that is, the channel is full).
</span></span></span><span class=line><span class=cl><span class=c1>// full函数报告发送操作是否会在channel c上阻塞（如果阻塞了，说明channel已满）
</span></span></span><span class=line><span class=cl><span class=c1>// It uses a single word-sized read of mutable state, so although
</span></span></span><span class=line><span class=cl><span class=c1>// the answer is instantaneously true, the correct answer may have changed
</span></span></span><span class=line><span class=cl><span class=c1>// by the time the calling function receives the return value.
</span></span></span><span class=line><span class=cl><span class=c1>// 该函数使用了单个字大小的可变状态读取，所以即使答案在某一时刻上正确的，但是正确的答案也可能在调用函数返回值之前改变
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>full</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// c.dataqsiz is immutable (never written after the channel is created)
</span></span></span><span class=line><span class=cl><span class=c1>// c.dataqsiz是不可变的（在创建通道之后不会改变）
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// so it is safe to read at any time during channel operation.
</span></span></span><span class=line><span class=cl><span class=c1>// 所以在channel操作的任何时刻读取都是安全的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>	<span class=c1>// dataqsiz表示缓冲区的大小，为0代表无缓冲通道
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Assumes that a pointer read is relaxed-atomic.
</span></span></span><span class=line><span class=cl><span class=c1>// 假定指针读取是宽松原子式的
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvq</span><span class=p>.</span><span class=nx>first</span> <span class=o>==</span> <span class=kc>nil</span>	<span class=c1>// 缓冲区的第一个指针为nil代表该chanel可以接收不会阻塞，反之会阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 有缓冲通道的情况
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Assumes that a uint read is relaxed-atomic.
</span></span></span><span class=line><span class=cl><span class=c1>// 假定读取一个uint是宽松原子式的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span> <span class=o>==</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span>	<span class=c1>// 如果channel的元素个数等于channel的缓冲区大小说明已满阻塞，反之则有空不会阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>宽松原子式（Relaxed-atomic）</strong>:</p><ul><li>宽松原子式是指在多线程环境中，对某个变量的读取或写入操作是原子的，即操作是不可分割的，不会被其他线程的操作打断。</li><li>在 Go 语言中，通常假设单个字大小的读取和写入操作是原子的，这意味着读取或写入一个字（通常是 32 位或 64 位）的操作不会被其他线程的操作打断。</li><li>这种假设简化了并发编程，但需要注意的是，这种原子性是宽松的，因为它不提供顺序或可见性保证</li></ul></blockquote><p><strong>上面的部分是加锁之前的判断，因为加锁是一个很重的操作，所以最好是能不加就能直接判断返回最好，所以有了上面的代码：channel为nil的判断和非阻塞且通道已满的两个判断。</strong></p><h6 id=加锁并判断channel是否关闭>加锁，并判断channel是否关闭<a hidden class=anchor aria-hidden=true href=#加锁并判断channel是否关闭>#</a></h6><ul><li>获取通道锁。</li><li>先判断通道是否处于关闭状态，如是解锁并抛出“send on closed channel”异常。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>t0</span> <span class=kt>int64</span>	<span class=c1>// 存储时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>blockprofilerate</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t0</span> <span class=p>=</span> <span class=nf>cputicks</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>closed</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;send on closed channel&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h6 id=如果有等待的接受者>如果有等待的接受者<a hidden class=anchor aria-hidden=true href=#如果有等待的接受者>#</a></h6><ul><li>如果找到等待的接收者，调用 <code>send</code> 函数直接将值传递给接收者。</li></ul><p>如果recvq中存在等待的接受者，说明缓冲区是空的，就可以直接把要发的数据发送。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>sg</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>();</span> <span class=nx>sg</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Found a waiting receiver. We pass the value we want to send
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// directly to the receiver, bypassing the channel buffer (if any).
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 存在一个等待的接收者。我们将要发送的值直接传递给接收者，绕过通道缓冲区（如果有的话）。
</span></span></span><span class=line><span class=cl><span class=c1></span>        
</span></span><span class=line><span class=cl>        <span class=c1>// send接受一个通道指针、一个等待接收数据的 goroutine 指针、一个数据指针、一个解锁函数和一个用于堆栈跟踪的整数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 要求通道 c 必须为空并已上锁。send 使用 unlockf 解锁 c。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// sg 必须已经从 c 中出队。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// ep 必须非空并指向堆或调用者的堆栈。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>send</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>sg</span><span class=p>,</span> <span class=nx>ep</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span> <span class=p>},</span> <span class=mi>3</span><span class=p>)</span>	<span class=c1>// 关于send的实现在下面
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><code>dequeue</code> 是 Go 语言运行时系统中用于从等待队列（<code>waitq</code>）中移除并返回一个 <code>sudog</code> 结构体的函数。<code>sudog</code> 结构体代表一个正在等待的 goroutine。这个函数的主要目的是从等待队列中安全地移除一个 <code>sudog</code>，并处理一些特殊情况，比如在 <code>select</code> 语句中等待的 goroutine。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>waitq</span><span class=p>)</span> <span class=nf>dequeue</span><span class=p>()</span> <span class=o>*</span><span class=nx>sudog</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sgp</span> <span class=o>:=</span> <span class=nx>q</span><span class=p>.</span><span class=nx>first</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sgp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>y</span> <span class=o>:=</span> <span class=nx>sgp</span><span class=p>.</span><span class=nx>next</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>y</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>q</span><span class=p>.</span><span class=nx>first</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=nx>q</span><span class=p>.</span><span class=nx>last</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>y</span><span class=p>.</span><span class=nx>prev</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=nx>q</span><span class=p>.</span><span class=nx>first</span> <span class=p>=</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl>			<span class=nx>sgp</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>// mark as removed (see dequeueSudoG)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// if a goroutine was put on this queue because of a
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// select, there is a small window between the goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// being woken up by a different case and it grabbing the
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// channel locks. Once it has the lock
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// it removes itself from the queue, so we won&#39;t see it after that.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// We use a flag in the G struct to tell us when someone
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// else has won the race to signal this goroutine but the goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// hasn&#39;t removed itself from the queue yet.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>sgp</span><span class=p>.</span><span class=nx>isSelect</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>sgp</span><span class=p>.</span><span class=nx>g</span><span class=p>.</span><span class=nx>selectDone</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>sgp</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></blockquote><h6 id=如果缓冲区有空间>如果缓冲区有空间<a hidden class=anchor aria-hidden=true href=#如果缓冲区有空间>#</a></h6><ul><li>如果通道缓冲区有空间，将元素入队并解锁。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 执行到这里说明上一条件未满足，即没有等待的接收者
</span></span></span><span class=line><span class=cl><span class=c1></span>  	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span> <span class=p>&lt;</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Space is available in the channel buffer. Enqueue the element to send.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// channel buffer中有可用空间。将要发送的元素入队。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>qp</span> <span class=o>:=</span> <span class=nf>chanbuf</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=p>)</span>	<span class=c1>// 获取缓冲区sendx的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>	<span class=c1>// 如果启用了数据竞争检测
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>	<span class=c1>// 这个函数用于通知数据竞争检测系统
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>qp</span><span class=p>,</span> <span class=nx>ep</span><span class=p>)</span> <span class=c1>// 将数据复制到缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 更新 sendx 索引，如果达到缓冲区大小，则重置为 0（实现循环缓冲区）
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span> <span class=o>==</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=o>++</span>	<span class=c1>// 元素个数更新
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>	<span class=c1>// 发送数据完成，解锁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><code>chanbuf</code> 是 Go 语言运行时系统中的一个内部函数，用于获取通道（channel）缓冲区中指定索引位置的元素的指针。这个函数通常在通道的发送和接收操作中使用，以便访问和操作通道缓冲区中的数据。</p><ul><li><code>add</code>：这是一个内部函数，用于计算地址偏移量。它将缓冲区起始地址 <code>c.buf</code> 加上索引位置 <code>i</code> 乘以元素大小 <code>c.elemsize</code>，得到指定索引位置的元素的指针。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//go:linkname chanbuf
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>chanbuf</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>i</span> <span class=kt>uint</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>add</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>buf</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemsize</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></blockquote><h6 id=缓冲区已满如果是非阻塞>缓冲区已满，如果是非阻塞<a hidden class=anchor aria-hidden=true href=#缓冲区已满如果是非阻塞>#</a></h6><ul><li>如果通道缓冲区已满且非阻塞模式，解锁并返回 <code>false</code>。</li></ul><p>上一条件是没有等待的接受者，缓冲区还有空。执行到这里代表缓冲区已满。</p><p>然后分阻塞和非阻塞模式的判断，如果是非阻塞的，不会存入发送队列，直接返回false。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>  	<span class=k>if</span> <span class=p>!</span><span class=nx>block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><h3 id=为什么非阻塞的不会存入到发送队列>为什么非阻塞的不会存入到发送队列？<a hidden class=anchor aria-hidden=true href=#为什么非阻塞的不会存入到发送队列>#</a></h3><ul><li><strong>非阻塞模式的设计目的</strong>：<ul><li>非阻塞模式的设计目的是为了在发送操作不能立即完成时，不阻塞调用者。这样可以避免发送操作因为等待缓冲区可用空间而导致的线程阻塞，从而提高程序的响应性和并发性能。</li></ul></li><li><strong>直接返回 <code>false</code> 的意义</strong>：<ul><li>当通道缓冲区已满且处于非阻塞模式时，直接返回 <code>false</code> 可以让调用者立即知道发送操作失败。调用者可以根据返回值来决定下一步的操作，比如重试发送、丢弃数据或采取其他策略。</li></ul></li><li><strong>避免不必要的等待</strong>：<ul><li>如果非阻塞模式下仍然尝试将数据存入发送队列并等待缓冲区可用空间，这实际上会导致发送操作阻塞，违背了非阻塞模式的设计初衷。</li></ul></li></ul><p>因此，在非阻塞模式下，如果通道缓冲区已满，发送操作不会将数据存入发送队列，而是直接返回 <code>false</code>，以确保发送操作不会阻塞调用者。</p></blockquote><h6 id=阻塞创建sudog入队sendq>阻塞，创建sudog入队sendq<a hidden class=anchor aria-hidden=true href=#阻塞创建sudog入队sendq>#</a></h6><ul><li>如果需要阻塞，获取当前 goroutine 并创建一个 <code>sudog</code> 结构体，将其入队到发送队列，然后让 goroutine 进入睡眠状态。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 在通道上执行阻塞，别的接收者会完成我们的操作。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>	<span class=c1>// 函数用于获取当前执行的 goroutine 的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mysg</span> <span class=o>:=</span> <span class=nf>acquireSudog</span><span class=p>()</span>	<span class=c1>// acquireSudog() 函数用于获取一个 sudog 结构体，表示一个正在等待的 goroutine。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=mi>0</span>	<span class=c1>// 设置mysg的等待时间为0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>t0</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>			<span class=c1>// 如果上文的t0不为0，则将其设置为-1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// No stack splits between assigning elem and enqueuing mysg    
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// on gp.waiting where copystack can find it.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 在将 elem 分配给 mysg 并将 mysg 入队到 gp.waiting 之间不能进行堆栈拆分，
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// copystack 可以在这里找到它。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>elem</span> <span class=p>=</span> <span class=nx>ep</span>				<span class=c1>// mysg.elem 设置为要发送的数据的指针。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>waitlink</span> <span class=p>=</span> <span class=kc>nil</span>			<span class=c1>// mysg.waitlink 设置为 nil，表示没有下一个等待的 sudog
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>g</span> <span class=p>=</span> <span class=nx>gp</span>					<span class=c1>// mysg.g 设置为当前的 goroutine。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>isSelect</span> <span class=p>=</span> <span class=kc>false</span>		<span class=c1>// mysg.isSelect 设置为 false，表示这不是一个 select 操作。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>c</span> <span class=p>=</span> <span class=nx>c</span>					<span class=c1>// mysg.c 设置为当前的通道。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gp</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>=</span> <span class=nx>mysg</span>			<span class=c1>// gp.waiting 设置为当前的 sudog，表示当前 goroutine 正在等待。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=kc>nil</span>				<span class=c1>// gp.param 设置为 nil，表示没有传递参数。 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span><span class=p>.</span><span class=nx>sendq</span><span class=p>.</span><span class=nf>enqueue</span><span class=p>(</span><span class=nx>mysg</span><span class=p>)</span>		<span class=c1>// 将mysg入队发送队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stack shrinking.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 向任何试图缩小堆栈的人发出信号，表示我们即将挂起通道。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 此 G 的状态变化与我们设置 gp.activeStackChans 之间的窗口对于堆栈缩小来说是不安全的。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gp</span><span class=p>.</span><span class=nx>parkingOnChan</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>gopark</span><span class=p>(</span><span class=nx>chanparkcommit</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>),</span> <span class=nx>waitReasonChanSend</span><span class=p>,</span> <span class=nx>traceBlockChanSend</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Ensure the value being sent is kept alive until the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// receiver copies it out. The sudog has a pointer to the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stack object, but sudogs aren&#39;t considered as roots of the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stack tracer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 确保发送的值在接收者复制它之前保持存活。sudog 有一个指向堆栈对象的指针，但 sudog 并不被视为堆栈跟踪器的根。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// KeepAlive(ep) 的作用是确保发送的值在接收者复制它之前保持存活。即使 goroutine 被挂起，ep 指向的值也不会被垃圾回收器回收。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>KeepAlive</span><span class=p>(</span><span class=nx>ep</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h6 id=处理唤醒后的操作>处理唤醒后的操作<a hidden class=anchor aria-hidden=true href=#处理唤醒后的操作>#</a></h6><blockquote><p>如果没有接收者唤醒这个 goroutine，它会一直处于阻塞状态，直到满足以下条件之一：</p><ol><li>有接收者从通道中接收数据，从而释放缓冲区空间，并唤醒发送者。</li><li>通道被关闭，此时发送操作会引发 panic。</li></ol><p>因此，如果没有接收者唤醒这个 goroutine，它会一直阻塞在 <code>gopark</code> 调用处，直到有接收者接收数据或通道被关闭。</p></blockquote><ul><li>当被唤醒时，检查是否因为通道关闭而被唤醒，如果是则抛出异常。</li></ul><p>这段代码处理的是当发送操作被阻塞后，如何在被唤醒时进行后续处理。具体步骤包括检查等待的 sudog、重置 goroutine 的状态、检查通道是否关闭、记录阻塞事件、重置 sudog 的状态，并处理通道关闭的情况。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>callerpc</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>  	<span class=c1>// someone woke us up.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 有人唤醒这个sudog，如果不是等待的sudog（即当前的mysg，前面设置的），说明等待队列被破坏，抛出错误
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>mysg</span> <span class=o>!=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;G waiting list is corrupted&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>gp</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>=</span> <span class=kc>nil</span>			<span class=c1>// 表示当前 goroutine 不再等待
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gp</span><span class=p>.</span><span class=nx>activeStackChans</span> <span class=p>=</span> <span class=kc>false</span>	<span class=c1>// 表示当前 goroutine 不再活跃在通道上
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>closed</span> <span class=o>:=</span> <span class=p>!</span><span class=nx>mysg</span><span class=p>.</span><span class=nx>success</span>		
</span></span><span class=line><span class=cl>    <span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果 mysg.releasetime 大于 0，表示记录了阻塞开始的时间，调用 blockevent 函数记录阻塞事件。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>blockevent</span><span class=p>(</span><span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span><span class=o>-</span><span class=nx>t0</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>c</span> <span class=p>=</span> <span class=kc>nil</span>			<span class=c1>// mysg.c 设置为 nil，表示 sudog 不再关联任何通道。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>releaseSudog</span><span class=p>(</span><span class=nx>mysg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>closed</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>closed</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;chansend: spurious wakeup&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;send on closed channel&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=send-的作用>send 的作用<a hidden class=anchor aria-hidden=true href=#send-的作用>#</a></h5><p><code>send</code> 函数处理在空通道上的发送操作。它将发送者发送的值直接复制到接收者，并唤醒接收者继续其工作。通道必须为空且已锁定，<code>send</code> 函数在完成后会解锁通道。</p><h5 id=send>send<a hidden class=anchor aria-hidden=true href=#send>#</a></h5><ul><li>处理在空通道上的发送操作。</li><li>将发送者发送的值直接复制到接收者。</li><li>解锁通道并唤醒接收者继续其工作。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// send processes a send operation on an empty channel c.
</span></span></span><span class=line><span class=cl><span class=c1>// send 处理空通道 c 上的发送操作。
</span></span></span><span class=line><span class=cl><span class=c1>// The value ep sent by the sender is copied to the receiver sg.
</span></span></span><span class=line><span class=cl><span class=c1>// 发送者发送的值 ep 被复制到接收者 sg。
</span></span></span><span class=line><span class=cl><span class=c1>// The receiver is then woken up to go on its merry way.
</span></span></span><span class=line><span class=cl><span class=c1>// 然后唤醒接收者让其继续。
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=c1>// Channel c must be empty and locked.  send unlocks c with unlockf.
</span></span></span><span class=line><span class=cl><span class=c1>// 通道 c 必须为空并已上锁。send 使用 unlockf 解锁 c。
</span></span></span><span class=line><span class=cl><span class=c1>// sg must already be dequeued from c.
</span></span></span><span class=line><span class=cl><span class=c1>// sg 必须已经从 c 中出队。
</span></span></span><span class=line><span class=cl><span class=c1>// ep must be non-nil and point to the heap or the caller&#39;s stack.
</span></span></span><span class=line><span class=cl><span class=c1>// ep 必须非空并指向堆或调用者的堆栈。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 接受一个通道指针、一个等待接收数据的 goroutine 指针、一个数据指针、一个解锁函数和一个用于堆栈跟踪的整数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>send</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>sg</span> <span class=o>*</span><span class=nx>sudog</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>unlockf</span> <span class=kd>func</span><span class=p>(),</span> <span class=nx>skip</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果启用了竞争检测
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 无缓冲通道
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>racesync</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Pretend we go through the buffer, even though
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// we copy directly. Note that we need to increment
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// the head/tail locations only when raceenabled.            
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 假装我们通过缓冲区，即使我们直接复制。注意，只有启用竞争检测时才需要增加头尾位置。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>,</span> <span class=nx>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=o>++</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=o>==</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=c1>// c.sendx = (c.sendx+1) % c.dataqsiz
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>					<span class=c1>// 表示有数据需要发送
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sendDirect</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>sg</span><span class=p>,</span> <span class=nx>ep</span><span class=p>)</span>	<span class=c1>// 直接将数据从发送者复制到接收者，这个也是在runtime2.go中定义
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span> <span class=p>=</span> <span class=kc>nil</span>					<span class=c1>// 发送完成后，将 sg.elem 设置为 nil
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>gp</span> <span class=o>:=</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>g</span>							<span class=c1>// 获取接收者的 goroutine gp
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>unlockf</span><span class=p>()</span>							<span class=c1>// 调用 unlockf() 解锁通道
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sg</span><span class=p>)</span>		<span class=c1>// 将接收者的 gp.param 设置为 unsafe.Pointer(sg)，表示接收操作成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>sg</span><span class=p>.</span><span class=nx>success</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>			<span class=c1>// 如果 sg.releasetime 不为 0，则记录当前时间 cputicks()
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=nf>cputicks</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>goready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>skip</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>			<span class=c1>// 调用 goready(gp, skip+1) 将接收者的 goroutine 设置为可运行状态，准备唤醒接收者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=chanrecv>chanrecv<a hidden class=anchor aria-hidden=true href=#chanrecv>#</a></h3><h4 id=调用场景-2>调用场景<a hidden class=anchor aria-hidden=true href=#调用场景-2>#</a></h4><p>在从ch中接收一个数字的时候，可以看到他这里是调用了<code>runtime.chanrecv1()</code>这个函数</p><p><img loading=lazy src=https://s2.loli.net/2024/06/23/HnNdobsEYOPzg8r.png alt=chanrecv></p><h4 id=实现代码和解读-1>实现代码和解读<a hidden class=anchor aria-hidden=true href=#实现代码和解读-1>#</a></h4><h5 id=chanrecv1>chanrecv1<a hidden class=anchor aria-hidden=true href=#chanrecv1>#</a></h5><p>这个函数实际上内部也是调用了<code>chanrecv</code>函数，其中第三个参数为true</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// entry points for &lt;- c from compiled code.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:nosplit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>chanrecv1</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>chanrecv</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>elem</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=chanrecv2>chanrecv2<a hidden class=anchor aria-hidden=true href=#chanrecv2>#</a></h5><p>这个函数实际上内部也是调用了<code>chanrecv</code>函数，其中第三个参数为true，同时有一个返回值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//go:nosplit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>chanrecv2</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=p>(</span><span class=nx>received</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>received</span> <span class=p>=</span> <span class=nf>chanrecv</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>elem</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=chanrecv-1>chanrecv<a hidden class=anchor aria-hidden=true href=#chanrecv-1>#</a></h5><h6 id=判断c是否为nil>判断c是否为nil<a hidden class=anchor aria-hidden=true href=#判断c是否为nil>#</a></h6><p>若为nil且非阻塞则直接返回(false,false)，若为空且阻塞则将它挂起</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// chanrecv receives on channel c and writes the received data to ep.
</span></span></span><span class=line><span class=cl><span class=c1>// chanrecv 接收channel c中的元素，并将接收到的数据写给ep
</span></span></span><span class=line><span class=cl><span class=c1>// ep may be nil, in which case received data is ignored.
</span></span></span><span class=line><span class=cl><span class=c1>// ep可能为nil，这种情况下接收的数据被忽略
</span></span></span><span class=line><span class=cl><span class=c1>// If block == false and no elements are available, returns (false, false).
</span></span></span><span class=line><span class=cl><span class=c1>// 如果是非阻塞，同时没有元素可接收，那就return (false, false)
</span></span></span><span class=line><span class=cl><span class=c1>// Otherwise, if c is closed, zeros *ep and returns (true, false).
</span></span></span><span class=line><span class=cl><span class=c1>// 否则，如果channel c关闭了，那么会将接收数据的指针ep清零，并且函数返回一个表示操作成功但没有数据接收的(true, false)
</span></span></span><span class=line><span class=cl><span class=c1>// Otherwise, fills in *ep with an element and returns (true, true).
</span></span></span><span class=line><span class=cl><span class=c1>// 否则，用接收到的元素写入到ep所指向的位置，然后return (true, true)
</span></span></span><span class=line><span class=cl><span class=c1>// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class=line><span class=cl><span class=c1>// 一个非空的ep必须指向堆，或者调用者的栈
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 函数签名中的接收参数包括 传递参数的通道c，执行接收位置的指针ep，是否阻塞执行block；
</span></span></span><span class=line><span class=cl><span class=c1>// 返回值selected表示通道操作是否被选中执行。在Go语言的上下文中，这通常意味着通道操作是否成功，或者是否因为通道关闭而立即返回。
</span></span></span><span class=line><span class=cl><span class=c1>// received：表示是否成功接收到了数据。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>chanrecv</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>block</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>(</span><span class=nx>selected</span><span class=p>,</span> <span class=nx>received</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// raceenabled: don&#39;t need to check ep, as it is always on the stack
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// or is new memory allocated by reflect.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>debugChan</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s>&#34;chanrecv: chan=&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>gopark</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>waitReasonChanReceiveNilChan</span><span class=p>,</span> <span class=nx>traceBlockForever</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;unreachable&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span><span class=p>.</span><span class=nf>maybeRunChan</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><h6 id=fast-path看能否在加锁之间返回false>Fast Path，看能否在加锁之间返回false<a hidden class=anchor aria-hidden=true href=#fast-path看能否在加锁之间返回false>#</a></h6><p>在没有加锁之前判断能不能直接返回false</p><blockquote><p>empty报告了是否读操作会导致阻塞，即通道是否为空。</p><p>函数返回的时刻，结果是原子性正确的（即没有其他并发操作干扰），并且是顺序一致的（即结果反映了调用时刻的状态）。然而，由于通道在函数返回后没有被锁定，因此通道的状态可能会立即发生变化，变得不为空。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// empty reports whether a read from c would block (that is, the channel is
</span></span></span><span class=line><span class=cl><span class=c1>// empty).  It is atomically correct and sequentially consistent at the moment
</span></span></span><span class=line><span class=cl><span class=c1>// it returns, but since the channel is unlocked, the channel may become
</span></span></span><span class=line><span class=cl><span class=c1>// non-empty immediately afterward.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>empty</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// c.dataqsiz is immutable.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 检查是否是缓冲通道
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果是非缓冲通道，那么通过原子操作加载 sendq 队列的第一个元素（first）。sendq 是一个等待发送数据的 goroutine 队列。如果 first 为 nil，则表示没有 goroutine 在等待发送数据，因此通道为空。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Loadp</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>sendq</span><span class=p>.</span><span class=nx>first</span><span class=p>))</span> <span class=o>==</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// c.timer is also immutable (it is set after make(chan) but before any channel operations).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// All timer channels have dataqsiz &gt; 0.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span><span class=p>.</span><span class=nf>maybeRunChan</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 如果通道是有缓冲的，那么通过原子操作加载 qcount 字段，这个字段表示通道缓冲区中当前的数据项数量。如果 qcount 为0，则表示通道为空。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Loaduint</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>!</span><span class=nx>block</span> <span class=o>&amp;&amp;</span> <span class=nf>empty</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>{</span>	<span class=c1>// 如果接收操作非阻塞且channel为空（这里的empty代表是否会读取之后阻塞）
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// After observing that the channel is not ready for receiving, we observe whether the
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// channel is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 在观察到channel没有准备好接收之后，我们观察channel是否是处于关闭状态
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Reordering of these checks could lead to incorrect behavior when racing with a close.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 这些检查的重新排序可能会在与关闭操作竞争时导致不正确的行为
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// For example, if the channel was open and not empty, was closed, and then drained,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// reordered reads could incorrectly indicate &#34;open and empty&#34;. To prevent reordering,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// we use atomic loads for both checks, and rely on emptying and closing to happen in
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// separate critical sections under the same lock.  This assumption fails when closing
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// an unbuffered channel with a blocked send, but that is an error condition anyway.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 例如，如果通道是打开的且非空，然后被关闭，接着被清空，
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 重新排序的读取可能会错误地指示“打开且空”。为了防止重新排序，
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 我们使用原子加载来进行这两项检查，并依赖于清空和关闭操作在
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 同一个锁下的单独关键部分中发生。这个假设在关闭
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 一个带有阻塞发送的无缓冲通道时失败，但无论如何那都是一个错误条件。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>closed</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Because a channel cannot be reopened, the later observation of the channel
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// being not closed implies that it was also not closed at the moment of the
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// first observation. We behave as if we observed the channel at that moment
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// and report that the receive cannot proceed.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 因为通道不能被重新打开，所以稍后观察到通道
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// 未关闭意味着在第一次观察的时刻它也未关闭。我们表现得好像我们在那个时刻观察到了通道
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// 并报告接收操作不能继续。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// The channel is irreversibly closed. Re-check whether the channel has any pending data
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// to receive, which could have arrived between the empty and closed checks above.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Sequential consistency is also required here, when racing with such a send.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 通道已经不可逆地关闭。重新检查通道是否有任何待接收的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 这些数据可能在上面的空和关闭检查之间到达。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 当与这样的发送操作竞争时，这里也需要顺序一致性。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nf>empty</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// The channel is irreversibly closed and empty.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>raceacquire</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>ep</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>typedmemclr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>ep</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><h6 id=初始化和性能监控><strong>初始化和性能监控</strong><a hidden class=anchor aria-hidden=true href=#初始化和性能监控>#</a></h6><ul><li>如果 <code>blockprofilerate</code> 大于 0，获取当前的 CPU 时间戳 <code>t0</code> 以用于后续的性能分析。</li></ul><h6 id=锁定通道><strong>锁定通道</strong><a hidden class=anchor aria-hidden=true href=#锁定通道>#</a></h6><ul><li>锁定通道 <code>c</code> 的互斥锁。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>t0</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>blockprofilerate</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t0</span> <span class=p>=</span> <span class=nf>cputicks</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span></code></pre></div><h6 id=如果通道已关闭检查有无等待的数据和发送者>如果通道已关闭，检查有无等待的数据和发送者<a hidden class=anchor aria-hidden=true href=#如果通道已关闭检查有无等待的数据和发送者>#</a></h6><ul><li>如果通道已关闭且没有等待的数据：<ul><li>如果启用了竞态检测，通知竞态检测器通道已关闭。</li><li>解锁通道。</li><li>如果 <code>ep</code> 不为 <code>nil</code>，清空 <code>ep</code> 指向的内存。</li><li>返回 <code>true, false</code> 表示成功接收，但通道已关闭。</li></ul></li><li>否则，如果通道未关闭并且有等待的发送者：<ul><li>从发送队列中获取一个等待的发送者。</li><li>调用 <code>recv</code> 函数处理接收操作并解锁通道。</li><li>返回 <code>true, true</code> 表示成功接收并且通道未关闭。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>closed</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>raceacquire</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>ep</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>typedmemclr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>ep</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 通道已关闭，但缓冲区中有数据。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 发现未关闭的等待发送者。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>sg</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>sendq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>();</span> <span class=nx>sg</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 找到等待的发送者。如果缓冲区大小为0，则直接从发送者接收值。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 否则，从队列头部接收值，并将发送者的值添加到队列尾部（因为队列已满，两者映射到同一缓冲区槽位）。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>recv</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>sg</span><span class=p>,</span> <span class=nx>ep</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span> <span class=p>},</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h6 id=如果缓冲区不为空接收缓冲区数据>如果缓冲区不为空，接收缓冲区数据<a hidden class=anchor aria-hidden=true href=#如果缓冲区不为空接收缓冲区数据>#</a></h6><ul><li>如果缓冲区中有数据：<ul><li>从缓冲区中接收数据到 <code>ep</code>。</li><li>清空缓冲区中的数据。</li><li>更新接收索引 <code>recvx</code>，如果超过缓冲区大小，重置为 0。</li><li>减少缓冲区中的数据计数 <code>qcount</code>。</li><li>解锁通道。</li><li>返回 <code>true, true</code> 表示成功接收并且通道未关闭。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 直接从队列接收
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>qp</span> <span class=o>:=</span> <span class=nf>chanbuf</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>ep</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>ep</span><span class=p>,</span> <span class=nx>qp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>typedmemclr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>qp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=o>==</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h6 id=如果是非阻塞处理非阻塞接收>如果是非阻塞，处理非阻塞接收<a hidden class=anchor aria-hidden=true href=#如果是非阻塞处理非阻塞接收>#</a></h6><ul><li>如果 <code>block</code> 为 <code>false</code>，解锁通道并返回 <code>false, false</code> 表示没有数据可接收且不阻塞。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h6 id=阻塞等待发送者><strong>阻塞等待发送者</strong><a hidden class=anchor aria-hidden=true href=#阻塞等待发送者>#</a></h6><ul><li>获取当前 Goroutine。</li><li>获取一个 <code>sudog</code>（表示 Goroutine 的结构体）并初始化。</li><li>将 <code>ep</code> 指向的内存地址赋值给 <code>sudog</code>。</li><li>将当前 Goroutine 设置为等待状态，并将 <code>sudog</code> 加入通道的接收队列。</li><li>如果通道有定时器，阻塞定时器。</li><li>将 Goroutine 设置为即将阻塞在通道上，调用 <code>gopark</code> 进行阻塞。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 没有可用的发送者：在此通道上阻塞。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>mysg</span> <span class=o>:=</span> <span class=nf>acquireSudog</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>t0</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 在分配元素和将mysg入队到gp.waiting之间没有栈分割
</span></span></span><span class=line><span class=cl><span class=c1>// 这样copystack可以在那里找到它。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>mysg</span><span class=p>.</span><span class=nx>elem</span> <span class=p>=</span> <span class=nx>ep</span>
</span></span><span class=line><span class=cl><span class=nx>mysg</span><span class=p>.</span><span class=nx>waitlink</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=nx>gp</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>=</span> <span class=nx>mysg</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>mysg</span><span class=p>.</span><span class=nx>g</span> <span class=p>=</span> <span class=nx>gp</span>
</span></span><span class=line><span class=cl><span class=nx>mysg</span><span class=p>.</span><span class=nx>isSelect</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=nx>mysg</span><span class=p>.</span><span class=nx>c</span> <span class=p>=</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=nx>c</span><span class=p>.</span><span class=nx>recvq</span><span class=p>.</span><span class=nf>enqueue</span><span class=p>(</span><span class=nx>mysg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>blockTimerChan</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 向任何试图缩小我们的栈的人发出信号，表明我们即将在通道上停车。
</span></span></span><span class=line><span class=cl><span class=c1>// 在这个G的状态改变和我们设置gp.activeStackChans之间的窗口
</span></span></span><span class=line><span class=cl><span class=c1>// 对于栈缩小是不安全的。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>gp</span><span class=p>.</span><span class=nx>parkingOnChan</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>gopark</span><span class=p>(</span><span class=nx>chanparkcommit</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>),</span> <span class=nx>waitReasonChanReceive</span><span class=p>,</span> <span class=nx>traceBlockChanRecv</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><h6 id=处理唤醒后的操作-1><strong>处理唤醒后的操作</strong><a hidden class=anchor aria-hidden=true href=#处理唤醒后的操作-1>#</a></h6><ul><li>检查 <code>sudog</code> 是否仍在等待列表中，如果不在，抛出异常。</li><li>处理定时器解锁。</li><li>将 Goroutine 从等待状态中移除，标记为不再阻塞。</li><li>处理释放时间。</li><li>返回 <code>true</code> 和 <code>sudog</code> 的成功标志。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// someone woke us up
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>mysg</span> <span class=o>!=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;G waiting list is corrupted&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>unblockTimerChan</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>waiting</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>activeStackChans</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>blockevent</span><span class=p>(</span><span class=nx>mysg</span><span class=p>.</span><span class=nx>releasetime</span><span class=o>-</span><span class=nx>t0</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>success</span> <span class=o>:=</span> <span class=nx>mysg</span><span class=p>.</span><span class=nx>success</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>mysg</span><span class=p>.</span><span class=nx>c</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nf>releaseSudog</span><span class=p>(</span><span class=nx>mysg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>success</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=recv>recv<a hidden class=anchor aria-hidden=true href=#recv>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// recv processes a receive operation on a full channel c.
</span></span></span><span class=line><span class=cl><span class=c1>// There are 2 parts:
</span></span></span><span class=line><span class=cl><span class=c1>//  1. The value sent by the sender sg is put into the channel
</span></span></span><span class=line><span class=cl><span class=c1>//     and the sender is woken up to go on its merry way.
</span></span></span><span class=line><span class=cl><span class=c1>//  2. The value received by the receiver (the current G) is
</span></span></span><span class=line><span class=cl><span class=c1>//     written to ep.
</span></span></span><span class=line><span class=cl><span class=c1>// recv处理在满通道c上的接收操作。
</span></span></span><span class=line><span class=cl><span class=c1>// 有两个部分：
</span></span></span><span class=line><span class=cl><span class=c1>// 1. 发送者sg发送的值被放入通道，发送者被唤醒继续其愉快的旅程。
</span></span></span><span class=line><span class=cl><span class=c1>// 2. 接收者（当前G）接收的值被写入ep。
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// For synchronous channels, both values are the same.
</span></span></span><span class=line><span class=cl><span class=c1>// For asynchronous channels, the receiver gets its data from
</span></span></span><span class=line><span class=cl><span class=c1>// the channel buffer and the sender&#39;s data is put in the
</span></span></span><span class=line><span class=cl><span class=c1>// channel buffer.
</span></span></span><span class=line><span class=cl><span class=c1>// Channel c must be full and locked. recv unlocks c with unlockf.
</span></span></span><span class=line><span class=cl><span class=c1>// sg must already be dequeued from c.
</span></span></span><span class=line><span class=cl><span class=c1>// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class=line><span class=cl><span class=c1>// 对于同步通道，两个值是相同的。
</span></span></span><span class=line><span class=cl><span class=c1>// 对于异步通道，接收者从通道缓冲区获取数据，而发送者的数据被放入通道缓冲区。
</span></span></span><span class=line><span class=cl><span class=c1>// 通道c必须是满的且已锁定。recv通过unlockf解锁c。
</span></span></span><span class=line><span class=cl><span class=c1>// sg必须已经从c中出队。
</span></span></span><span class=line><span class=cl><span class=c1>// 非nil的ep必须指向堆或调用者的栈。
</span></span></span></code></pre></div><h6 id=是非缓冲通道>是非缓冲通道？<a hidden class=anchor aria-hidden=true href=#是非缓冲通道>#</a></h6><p>如果是非缓冲通道，执行以下步骤：</p><ul><li><p>如果启用了竞态检测（raceenabled），则调用 racesync(c, sg) 来同步数据。</p></li><li><p>如果 ep 不为 nil，则直接从发送者 sg 复制数据到 ep，调用 recvDirect(c.elemtype, sg, ep)。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// recv的函数签名接收参数：一个接收数据的通道c，sg表示等待在通道上的发送数据的 goroutine，ep表示接收数据写入的地址
</span></span></span><span class=line><span class=cl><span class=c1>// unlock:在接收操作完成后解锁通道; skip:控制某些内部操作的跳过次数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>recv</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>,</span> <span class=nx>sg</span> <span class=o>*</span><span class=nx>sudog</span><span class=p>,</span> <span class=nx>ep</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>unlockf</span> <span class=kd>func</span><span class=p>(),</span> <span class=nx>skip</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果是非缓冲通道
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>racesync</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ep</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// copy data from sender
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>recvDirect</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>sg</span><span class=p>,</span> <span class=nx>ep</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span></code></pre></div><blockquote><p><code>recvDirect</code> 是Go语言运行时系统的一部分，用于在非缓冲通道上直接从发送者复制数据到接收者</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>recvDirect</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>_type</span><span class=p>,</span> <span class=nx>sg</span> <span class=o>*</span><span class=nx>sudog</span><span class=p>,</span> <span class=nx>dst</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// dst is on our stack or the heap, src is on another stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// The channel is locked, so src will not move during this
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// operation.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>src</span> <span class=o>:=</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span>
</span></span><span class=line><span class=cl>	<span class=nf>typeBitsBulkBarrier</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>dst</span><span class=p>),</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>src</span><span class=p>),</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>memmove</span><span class=p>(</span><span class=nx>dst</span><span class=p>,</span> <span class=nx>src</span><span class=p>,</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></blockquote><h6 id=是缓冲通道>是缓冲通道<a hidden class=anchor aria-hidden=true href=#是缓冲通道>#</a></h6><p>如果通道是缓冲通道（即 c.dataqsiz > 0），执行以下步骤：</p><ul><li><p>获取队列中当前接收位置 c.recvx 的元素 qp，调用 chanbuf(c, c.recvx)。</p></li><li><p>如果启用了竞态检测，则调用 racenotify 来通知竞态检测器。</p></li><li><p>如果 ep 不为 nil，则从队列 qp 复制数据到接收者 ep，调用 typedmemmove(c.elemtype, ep, qp)。</p></li><li><p>从发送者 sg 复制数据到队列 qp，调用 typedmemmove(c.elemtype, qp, sg.elem)。</p></li><li><p>更新接收位置 c.recvx，如果它等于缓冲区大小 c.dataqsiz，则将其重置为0，以循环使用缓冲区。</p></li><li><p>更新发送位置 c.sendx，使其等于接收位置 c.recvx，因为队列是满的，发送者和接收者指向同一位置。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Queue is full. Take the item at the
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// head of the queue. Make the sender enqueue
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// its item at the tail of the queue. Since the
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// queue is full, those are both the same slot.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>qp</span> <span class=o>:=</span> <span class=nf>chanbuf</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>,</span> <span class=nx>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// copy data from queue to receiver
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>ep</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>ep</span><span class=p>,</span> <span class=nx>qp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// copy data from sender to queue
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>qp</span><span class=p>,</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=o>==</span> <span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span> <span class=c1>// c.sendx = (c.sendx+1) % c.dataqsiz
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span></code></pre></div><h6 id=处理后续>处理后续<a hidden class=anchor aria-hidden=true href=#处理后续>#</a></h6><ul><li><p>将发送者 sg 的 elem 字段设置为 nil，表示发送者不再持有数据。</p></li><li><p>获取发送者 sg 对应的 goroutine gp。</p></li><li><p>调用 unlockf() 函数来解锁通道 c，这个函数是在外部传递进来的，用于在接收操作完成后释放通道锁。</p></li><li><p>将 gp.param 设置为指向 sg 的 unsafe.Pointer，这通常用于在唤醒 goroutine 时传递参数。</p></li><li><p>将 sg.success 设置为 true，表示发送操作成功。</p></li><li><p>如果 sg.releasetime 不为0，则将其设置为当前的 CPU 滴答数 cputicks()，这可能用于性能分析。</p></li><li><p>调用 goready(gp, skip+1) 来唤醒发送者 sg 对应的 goroutine gp，使其准备好运行，skip+1 参数可能用于控制调度。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>g</span>
</span></span><span class=line><span class=cl>	<span class=nf>unlockf</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>sg</span><span class=p>.</span><span class=nx>success</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=nf>cputicks</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>goready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>skip</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=closechan>closechan<a hidden class=anchor aria-hidden=true href=#closechan>#</a></h3><h4 id=调用场景-3>调用场景<a hidden class=anchor aria-hidden=true href=#调用场景-3>#</a></h4><p>关闭通道通过<code>close(ch)</code>实现，在汇编代码中可以看到是调用了runtime.closechan()这个函数</p><p><img loading=lazy src=https://s2.loli.net/2024/06/23/m1fWKUwgVtNeQ7p.png alt=closechan></p><h4 id=实现代码和解读-2>实现代码和解读<a hidden class=anchor aria-hidden=true href=#实现代码和解读-2>#</a></h4><h5 id=closechan-1>closechan<a hidden class=anchor aria-hidden=true href=#closechan-1>#</a></h5><h6 id=检查通道是否为空>检查通道是否为空<a hidden class=anchor aria-hidden=true href=#检查通道是否为空>#</a></h6><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>closechan</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>hchan</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;close of nil channel&#34;</span><span class=p>))</span> <span class=c1>// 检查通道是否为空，如果为空则抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span></code></pre></div><h6 id=channel加锁检查是否已经被关闭>channel加锁，检查是否已经被关闭<a hidden class=anchor aria-hidden=true href=#channel加锁检查是否已经被关闭>#</a></h6><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span> <span class=c1>// 锁定通道
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>closed</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;close of closed channel&#34;</span><span class=p>))</span> <span class=c1>// 检查通道是否已经关闭，如果已关闭则抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span></code></pre></div><h6 id=竞态检测相关操作>竞态检测相关操作<a hidden class=anchor aria-hidden=true href=#竞态检测相关操作>#</a></h6><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>callerpc</span> <span class=o>:=</span> <span class=nf>getcallerpc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>racewritepc</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>(),</span> <span class=nx>callerpc</span><span class=p>,</span> <span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABIInternal</span><span class=p>(</span><span class=nx>closechan</span><span class=p>))</span> <span class=c1>// 记录当前调用者的程序计数器
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>racerelease</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span> <span class=c1>// 进行相关竞态检测操作
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span></code></pre></div><h6 id=标记为通道已关闭>标记为通道已关闭<a hidden class=anchor aria-hidden=true href=#标记为通道已关闭>#</a></h6><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>closed</span> <span class=p>=</span> <span class=mi>1</span> <span class=c1>// 标记通道为已关闭
</span></span></span></code></pre></div><h6 id=释放所有等待接收的g>释放所有等待接收的G<a hidden class=anchor aria-hidden=true href=#释放所有等待接收的g>#</a></h6><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>glist</span> <span class=nx>gList</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 释放所有等待接收的 Goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sg</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>recvq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>typedmemclr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span><span class=p>)</span> <span class=c1>// 清空接收的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=nf>cputicks</span><span class=p>()</span> <span class=c1>// 记录释放时间
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>g</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>sg</span><span class=p>.</span><span class=nx>success</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>raceacquireg</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span> <span class=c1>// 竞态检测
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>glist</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span> <span class=c1>// 将 Goroutine 加入列表
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span></code></pre></div><h6 id=释放所有等待发送的g>释放所有等待发送的G<a hidden class=anchor aria-hidden=true href=#释放所有等待发送的g>#</a></h6><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// 释放所有等待发送的 Goroutine（它们将会 panic）
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sg</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>sendq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sg</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span> <span class=p>=</span> <span class=nf>cputicks</span><span class=p>()</span> <span class=c1>// 记录释放时间
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>sg</span><span class=p>.</span><span class=nx>g</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>param</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>sg</span><span class=p>.</span><span class=nx>success</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>raceacquireg</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span> <span class=c1>// 竞态检测
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>glist</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span> <span class=c1>// 将 Goroutine 加入列表
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span> <span class=c1>// 解锁通道
</span></span></span></code></pre></div><h6 id=释放通道锁唤醒所有g>释放通道锁，唤醒所有G<a hidden class=anchor aria-hidden=true href=#释放通道锁唤醒所有g>#</a></h6><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// 现在已经释放了通道锁，唤醒所有 Goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>!</span><span class=nx>glist</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nx>glist</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span><span class=p>.</span><span class=nx>schedlink</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=nf>goready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>// 唤醒 Goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/go/>Go</a></li><li><a href=https://sirius1y.top/tags/channel/>Channel</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/dev/dev-aorb-flutter/><span class=title>« Prev</span><br><span>Flutter开发</span>
</a><a class=next href=https://sirius1y.top/posts/notes/jobhunter/cs-basic-notes/><span class=title>Next »</span><br><span>计算机基础知识</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>