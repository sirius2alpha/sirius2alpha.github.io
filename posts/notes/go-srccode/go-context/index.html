<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【go的源码阅读】context的实现：context.go | Sirius' Blog</title>
<meta name=keywords content="go,context"><meta name=description content="理解Context 这篇文章介绍的很清楚：深入理解Go Context
这个比较详细，但是层次不好：理解GO CONTEXT机制
关于context的使用场景 context的主要使用场景在于：一个任务在处理的过程中可能会启动很多个协程来进行处理。在这个过程中，如果上游的任务想要取消，下游的任务也应当一起取消。context的任务就来了。
内容介绍 context包的内容可以概括为：1个接口，4个实现，6个方法
接口 context.Context 一个接口是指：context.Context
type Context interface { Deadline() (deadline time.Time, ok bool) Done() <-chan struct{} Err() error Value(key interface{}) interface{} } Deadline( ) Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。
函数签名 Deadline() (deadline time.Time, ok bool)
Deadline 返回的时间 deadline time.Time 代表这个ctx应该被取消的时间。返回的 ok 如果是 false 表示这个context没有设置deadline。连续调用 Deadline 会返回相同的结果。
// Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set."><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/notes/go-srccode/go-context/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sirius1y.top/posts/notes/go-srccode/go-context/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="【go的源码阅读】context的实现：context.go"><meta property="og:description" content="理解Context 这篇文章介绍的很清楚：深入理解Go Context
这个比较详细，但是层次不好：理解GO CONTEXT机制
关于context的使用场景 context的主要使用场景在于：一个任务在处理的过程中可能会启动很多个协程来进行处理。在这个过程中，如果上游的任务想要取消，下游的任务也应当一起取消。context的任务就来了。
内容介绍 context包的内容可以概括为：1个接口，4个实现，6个方法
接口 context.Context 一个接口是指：context.Context
type Context interface { Deadline() (deadline time.Time, ok bool) Done() <-chan struct{} Err() error Value(key interface{}) interface{} } Deadline( ) Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。
函数签名 Deadline() (deadline time.Time, ok bool)
Deadline 返回的时间 deadline time.Time 代表这个ctx应该被取消的时间。返回的 ok 如果是 false 表示这个context没有设置deadline。连续调用 Deadline 会返回相同的结果。
// Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set."><meta property="og:type" content="article"><meta property="og:url" content="https://sirius1y.top/posts/notes/go-srccode/go-context/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-26T00:00:00+00:00"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【go的源码阅读】context的实现：context.go"><meta name=twitter:description content="理解Context 这篇文章介绍的很清楚：深入理解Go Context
这个比较详细，但是层次不好：理解GO CONTEXT机制
关于context的使用场景 context的主要使用场景在于：一个任务在处理的过程中可能会启动很多个协程来进行处理。在这个过程中，如果上游的任务想要取消，下游的任务也应当一起取消。context的任务就来了。
内容介绍 context包的内容可以概括为：1个接口，4个实现，6个方法
接口 context.Context 一个接口是指：context.Context
type Context interface { Deadline() (deadline time.Time, ok bool) Done() <-chan struct{} Err() error Value(key interface{}) interface{} } Deadline( ) Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。
函数签名 Deadline() (deadline time.Time, ok bool)
Deadline 返回的时间 deadline time.Time 代表这个ctx应该被取消的时间。返回的 ok 如果是 false 表示这个context没有设置deadline。连续调用 Deadline 会返回相同的结果。
// Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"},{"@type":"ListItem","position":2,"name":"【go的源码阅读】context的实现：context.go","item":"https://sirius1y.top/posts/notes/go-srccode/go-context/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【go的源码阅读】context的实现：context.go","name":"【go的源码阅读】context的实现：context.go","description":"理解Context 这篇文章介绍的很清楚：深入理解Go Context\n这个比较详细，但是层次不好：理解GO CONTEXT机制\n关于context的使用场景 context的主要使用场景在于：一个任务在处理的过程中可能会启动很多个协程来进行处理。在这个过程中，如果上游的任务想要取消，下游的任务也应当一起取消。context的任务就来了。\n内容介绍 context包的内容可以概括为：1个接口，4个实现，6个方法\n接口 context.Context 一个接口是指：context.Context\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline( ) Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。\n函数签名 Deadline() (deadline time.Time, ok bool)\nDeadline 返回的时间 deadline time.Time 代表这个ctx应该被取消的时间。返回的 ok 如果是 false 表示这个context没有设置deadline。连续调用 Deadline 会返回相同的结果。\n// Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set.","keywords":["go","context"],"articleBody":"理解Context 这篇文章介绍的很清楚：深入理解Go Context\n这个比较详细，但是层次不好：理解GO CONTEXT机制\n关于context的使用场景 context的主要使用场景在于：一个任务在处理的过程中可能会启动很多个协程来进行处理。在这个过程中，如果上游的任务想要取消，下游的任务也应当一起取消。context的任务就来了。\n内容介绍 context包的内容可以概括为：1个接口，4个实现，6个方法\n接口 context.Context 一个接口是指：context.Context\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{}) interface{} } Deadline( ) Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。\n函数签名 Deadline() (deadline time.Time, ok bool)\nDeadline 返回的时间 deadline time.Time 代表这个ctx应该被取消的时间。返回的 ok 如果是 false 表示这个context没有设置deadline。连续调用 Deadline 会返回相同的结果。\n// Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. Deadline() (deadline time.Time, ok bool) Done( ) Done方法返回一个信道（channel），当Context被撤销或过期时，该信道是关闭的，即它是一个表示Context是否已关闭的信号。\n函数签名 Done() \u003c-chan struct{}\nDone方法返回一个关闭的通道代表这个context应该被取消，如果这个context永远不会被取消，则Done会返回nil，连续调用会返回相同的值。Done channel的关闭可能是异步的，在cancel函数之后。\nWithCancel 函数安排当 cancel 被调用的时候关闭Done WithDeadline 安排当 deadline 过期的时候关闭Done WithTimeout 安排当 timeout 过期的时候关闭Done Done 可以在 select 表达式中使用\n// Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. // The close of the Done channel may happen asynchronously, // after the cancel function returns. // // WithCancel arranges for Done to be closed when cancel is called; // WithDeadline arranges for Done to be closed when the deadline // expires; WithTimeout arranges for Done to be closed when the timeout // elapses. // // Done is provided for use in select statements: // // // Stream generates values with DoSomething and sends them to out // // until DoSomething returns an error or ctx.Done is closed. // func Stream(ctx context.Context, out chan\u003c- Value) error { // for { // v, err := DoSomething(ctx) // if err != nil { // return err // } // select { // case \u003c-ctx.Done(): // return ctx.Err() // case out \u003c- v: // } // } // } // // See https://blog.golang.org/pipelines for more examples of how to use // a Done channel for cancellation. Done() \u003c-chan struct{} Err( ) 当Done信道关闭后，Err方法表明Context被撤的原因。\n函数签名 Err() error\n如果 Done 还没有关闭，Err() 返回nil；如果已经关闭了，Err() 会返回一个非空的error解释为什么关闭。\n如果上下文被取消，则返回 Canceled 如果上下文的截止日期已过，则返回 DeadlineExceeded。 Canceled 和 DeadlineExceeded 是两个 error，他们都是由 context.Err() 返回\n// Canceled is the error returned by [Context.Err] when the context is canceled. var Canceled = errors.New(\"context canceled\") // DeadlineExceeded is the error returned by [Context.Err] when the context's // deadline passes. var DeadlineExceeded error = deadlineExceededError{} func (deadlineExceededError) Error() string { return \"context deadline exceeded\" } func (deadlineExceededError) Timeout() bool { return true } func (deadlineExceededError) Temporary() bool { return true } 当 Err() 返回非空错误之后，连续调用 Err() 会返回相同的错误\n// If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. // After Err returns a non-nil error, successive calls to Err return the same error. Err() error Value( ) Value可以让Goroutine共享一些数据，当然获得数据是协程安全的。但使用这些数据的时候要注意同步，比如返回了一个map，而这个map的读写则要加锁。\n函数签名 Value(key any) any\nValue() 返回传入的 key 在这个 context 中关联的 value；如果这个 key 没有关联值则会返回 nil 。连续调用相同的 key 会返回相同的结果。\nValues 应该只用作传递跨进程和 API 边界的请求作用域数据，而不是用于传递函数的可选参数。\nkey 标识 Context 中的特定值。一个函数如果想要在 Context 中存储值，通常会在全局变量中分配一个 key ，然后使用该键作为 context.WithValue 和 Context.Value 的参数。\nkey 可以是任何支持相等的类型；软件包应将键定义为不导出的类型（变量名小写），以避免碰撞。\n// Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. // // Use context values only for request-scoped data that transits // processes and API boundaries, not for passing optional parameters to // functions. // // A key identifies a specific value in a Context. Functions that wish // to store values in Context typically allocate a key in a global // variable then use that key as the argument to context.WithValue and // Context.Value. A key can be any type that supports equality; // packages should define keys as an unexported type to avoid // collisions. // // Packages that define a Context key should provide type-safe accessors // for the values stored using that key: // // // Package user defines a User type that's stored in Contexts. // package user // // import \"context\" // // // User is the type of value stored in the Contexts. // type User struct {...} // // // key is an unexported type for keys defined in this package. // // This prevents collisions with keys defined in other packages. // type key int // // // userKey is the key for user.User values in Contexts. It is // // unexported; clients use user.NewContext and user.FromContext // // instead of using this key directly. // var userKey key // // // NewContext returns a new Context that carries value u. // func NewContext(ctx context.Context, u *User) context.Context { // return context.WithValue(ctx, userKey, u) // } // // // FromContext returns the User value stored in ctx, if any. // func FromContext(ctx context.Context) (*User, bool) { // u, ok := ctx.Value(userKey).(*User) // return u, ok // } Value(key any) any 实现 emptyCtx emptyCtx 是一个结构体，实现了 Context 接口中的所有方法\nemptyCtx 永远不会被取消，没有vlue，没有deadline；他是backgroundCtx 和 todoCtx 的共同基础\n// An emptyCtx is never canceled, has no values, and has no deadline. // It is the common base of backgroundCtx and todoCtx. type emptyCtx struct{} func (emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (emptyCtx) Done() \u003c-chan struct{} { return nil } func (emptyCtx) Err() error { return nil } func (emptyCtx) Value(key any) any { return nil } backgroundCtx 结构体中包含了emptyCtx，它的 String 方法返回一个字符串\"context.Background\"\n主要在 context.Background 中被返回\ntype backgroundCtx struct{ emptyCtx } func (backgroundCtx) String() string { return \"context.Background\" } todoCtx 结构体中包含了emptyCtx，它的 String 方法返回一个字符串\"context.TODO\"\n主要在 context.TODO 中被返回\ntype todoCtx struct{ emptyCtx } func (todoCtx) String() string { return \"context.TODO\" } cancelCtx cancelCtx是一个可以被取消的Context。当它被取消时，它还会取消任何实现了canceler接口的子Context。\nContext: 嵌入的Context接口，使得cancelCtx可以作为Context使用。 mu: 一个互斥锁（sync.Mutex），用于保护以下字段。 done: 一个atomic.Value，存储一个chan struct{}类型的通道，这个通道在第一次取消调用时会被关闭。 children: 一个映射，存储所有实现了canceler接口的子Context。在第一次取消调用时，这个映射会被设置为nil。 err: 一个错误，在第一次取消调用时会被设置为非nil值，表示Context已经被取消。 cause: 一个错误，在第一次取消调用时会被设置为非nil值，表示取消的原因。 // A cancelCtx can be canceled. When canceled, it also cancels any children // that implement canceler. type cancelCtx struct { Context mu sync.Mutex // protects following fields done atomic.Value // of chan struct{}, created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call cause error // set to non-nil by the first cancel call } func (c *cancelCtx) Value(key any) any { if key == \u0026cancelCtxKey { return c } return value(c.Context, key) } func (c *cancelCtx) Done() \u003c-chan struct{} { d := c.done.Load() if d != nil { return d.(chan struct{}) } c.mu.Lock() defer c.mu.Unlock() d = c.done.Load() if d == nil { d = make(chan struct{}) c.done.Store(d) } return d.(chan struct{}) } func (c *cancelCtx) Err() error { c.mu.Lock() err := c.err c.mu.Unlock() return err } timerCtx timerCtx 包含一个计时器和截止时间；\ntimerCtx 嵌入了一个cancelCtx，以实现Done和Err方法。这意味着 timerCtx 可以直接使用 cancelCtx 的Done和Err方法来处理取消通知和错误状态。\ntimerCtx实现取消操作时，首先会停止其计时器，然后委托cancelCtx.cancel方法来执行实际的取消操作。这意味着在取消timerCtx时，会先确保计时器不再触发，然后再进行取消操作。\n// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to // implement Done and Err. It implements cancel by stopping its timer then // delegating to cancelCtx.cancel. type timerCtx struct { cancelCtx timer *time.Timer // Under cancelCtx.mu. deadline time.Time } func (c *timerCtx) Deadline() (deadline time.Time, ok bool) { return c.deadline, true } func (c *timerCtx) String() string { return contextName(c.cancelCtx.Context) + \".WithDeadline(\" + c.deadline.String() + \" [\" + time.Until(c.deadline).String() + \"])\" } func (c *timerCtx) cancel(removeFromParent bool, err, cause error) { c.cancelCtx.cancel(false, err, cause) if removeFromParent { // Remove this timerCtx from its parent cancelCtx's children. removeChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } valueCtx valueCtx结构体包含一个键值对，其中key和val字段分别表示键和值\nvalueCtx实现了Value方法，用于检索与特定键关联的值。对于其他方法的调用，它会委托给嵌入的Context\nstringify 函数尝试将任意类型的值转换为字符串，而不使用fmt包。\n该函数用于*valueCtx.String()方法中，将键和值转换为字符串表示。 使用类型断言检查值的类型： 如果是实现了stringer接口的类型，调用其String方法。 如果是字符串类型，直接返回该字符串。 如果是nil，返回字符串\"\"。 其他情况，使用reflectlite.TypeOf(v).String()获取类型名称。 String 方法返回valueCtx的字符串表示。\n调用contextName(c.Context)获取父Context的名称。 使用stringify函数将键和值转换为字符串。 拼接这些字符串，形成最终的字符串表示。 Value 方法用于检索与特定键关联的值。\n首先检查传入的key是否与valueCtx中的key匹配。 如果匹配，返回对应的值c.val。 如果不匹配，调用value(c.Context, key)从父Context中检索值。 value 函数用于在Context链中检索特定键的值。\n使用一个无限循环遍历Context链。 使用类型断言检查当前Context的类型： 如果是*valueCtx，检查键是否匹配，如果匹配则返回值，否则继续检查父Context。 如果是*cancelCtx，检查键是否为\u0026cancelCtxKey，如果是则返回Context本身，否则继续检查父Context。 如果是withoutCancelCtx，检查键是否为\u0026cancelCtxKey，如果是则返回nil，否则继续检查父Context。 如果是*timerCtx，检查键是否为\u0026cancelCtxKey，如果是则返回\u0026ctx.cancelCtx，否则继续检查父Context。 如果是backgroundCtx或todoCtx，直接返回nil。 默认情况下，调用当前Context的Value方法继续检索值。 // A valueCtx carries a key-value pair. It implements Value for that key and // delegates all other calls to the embedded Context. type valueCtx struct { Context key, val any } // stringify tries a bit to stringify v, without using fmt, since we don't // want context depending on the unicode tables. This is only used by // *valueCtx.String(). func stringify(v any) string { switch s := v.(type) { case stringer: return s.String() case string: return s case nil: return \"\" } return reflectlite.TypeOf(v).String() } func (c *valueCtx) String() string { return contextName(c.Context) + \".WithValue(\" + stringify(c.key) + \", \" + stringify(c.val) + \")\" } func (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) } func value(c Context, key any) any { for { switch ctx := c.(type) { case *valueCtx: if key == ctx.key { return ctx.val } c = ctx.Context case *cancelCtx: if key == \u0026cancelCtxKey { return c } c = ctx.Context case withoutCancelCtx: if key == \u0026cancelCtxKey { // This implements Cause(ctx) == nil // when ctx is created using WithoutCancel. return nil } c = ctx.c case *timerCtx: if key == \u0026cancelCtxKey { return \u0026ctx.cancelCtx } c = ctx.Context case backgroundCtx, todoCtx: return nil default: return c.Value(key) } } } 方法 Background context.Background 方法返回一个 non-nil 但是 empty 的一个 context。返回的这个context其实就是 emptyCtx ，外加了一个 String 方法\n函数调用场景\n这个方法主要在 main 函数中使用，作为 Context 树中的最高的节点\n// Background returns a non-nil, empty [Context]. It is never canceled, has no // values, and has no deadline. It is typically used by the main function, // initialization, and tests, and as the top-level Context for incoming // requests. func Background() Context { return backgroundCtx{} } TODO context.TODO 返回一个 non-nil 但是 empty 的一个context。返回的这个context其实就是 emptyCtx ，外加了一个 String 方法\n函数调用场景\n不明确使用哪个Context：在某些情况下，开发者可能不清楚应该使用哪个Context。可能因为代码中存在多个Context，而每个Context都有其特定的用途或生命周期，选择错误的Context可能会导致预期之外的行为。 Context尚不可用：在代码的早期版本中，当时还没有引入Context作为函数参数。随着代码编写，开发者可能需要将Context参数添加到函数中，以便更好地管理请求的生命周期和取消操作。 // TODO returns a non-nil, empty [Context]. Code should use context.TODO when // it's unclear which Context to use or it is not yet available (because the // surrounding function has not yet been extended to accept a Context // parameter). func TODO() Context { return todoCtx{} } WithCancel CancelFunc 类型 CancelFunc 用于通知某个操作放弃其工作。调用这个函数意味着操作应该停止执行。\n函数本身不会等待操作实际停止。它只是发送一个信号，告诉操作应该停止，但不会阻塞等待操作真正停止。\n可以被多个goroutine同时调用。这意味着多个并发执行的goroutine可以独立地决定取消操作。\n一旦CancelFunc被第一次调用，后续的调用将不会有任何效果。这确保了取消操作只会被执行一次，避免了重复取消的问题。\nWithCancel 函数 函数签名 func WithCancel(parent Context) (ctx Context, cancel CancelFunc)\nWithCancel函数返回一个基于父Context的新Context实例，并附带一个新的Done通道。\n返回的Context的Done通道会在以下两种情况之一发生时关闭：\n返回的cancel函数被调用。 父Context的Done通道被关闭。 取消这个Context会释放与之关联的资源，因此代码应该在运行在这个Context中的操作完成后立即调用cancel函数。\n// A CancelFunc tells an operation to abandon its work. // A CancelFunc does not wait for the work to stop. // A CancelFunc may be called by multiple goroutines simultaneously. // After the first call, subsequent calls to a CancelFunc do nothing. type CancelFunc func() // WithCancel returns a copy of parent with a new Done channel. The returned // context's Done channel is closed when the returned cancel function is called // or when the parent context's Done channel is closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this [Context] complete. func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := withCancel(parent) return c, func() { c.cancel(true, Canceled, nil) } } WithCancelCause CancelCauseFunc是一个用于取消操作并设置取消原因的函数类型，WithCancelCause函数用于创建一个可以被取消并记录原因的Context。\nCancelCauseFunc 类型 // A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause. // This cause can be retrieved by calling [Cause] on the canceled Context or on // any of its derived Contexts. // // If the context has already been canceled, CancelCauseFunc does not set the cause. // For example, if childContext is derived from parentContext: // - if parentContext is canceled with cause1 before childContext is canceled with cause2, // then Cause(parentContext) == Cause(childContext) == cause1 // - if childContext is canceled with cause2 before parentContext is canceled with cause1, // then Cause(parentContext) == cause1 and Cause(childContext) == cause2 type CancelCauseFunc func(cause error) A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause.\nCancelCauseFunc是一个函数类型，类似于CancelFunc，但它还额外设置了取消的原因（cause）。 This cause can be retrieved by calling [Cause] on the canceled Context or on any of its derived Contexts.\n这个取消原因可以通过调用Cause函数在已取消的Context或其派生的任何Context上检索。 If the context has already been canceled, CancelCauseFunc does not set the cause.\n如果Context已经取消，CancelCauseFunc不会设置原因。 For example, if childContext is derived from parentContext:\n例如，如果childContext是从parentContext派生的： 如果parentContext在childContext之前被用cause1取消，那么Cause(parentContext) == Cause(childContext) == cause1。 如果childContext在parentContext之前被用cause2取消，那么Cause(parentContext) == cause1且Cause(childContext) == cause2。 withCancel 函数 func withCancel(parent Context) *cancelCtx { if parent == nil { panic(\"cannot create context from nil parent\") } c := \u0026cancelCtx{} c.propagateCancel(parent, c) return c } withCancel 函数用于创建一个新的cancelCtx实例，并将其与父Context关联起来。 如果传入的parent为nil，则会引发panic。 创建一个新的cancelCtx实例，并调用propagateCancel方法将新Context与父Context关联起来。 WithCancelCause 函数 // WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc]. // Calling cancel with a non-nil error (the \"cause\") records that error in ctx; // it can then be retrieved using Cause(ctx). // Calling cancel with nil sets the cause to Canceled. // // Example use: // //\tctx, cancel := context.WithCancelCause(parent) //\tcancel(myError) //\tctx.Err() // returns context.Canceled //\tcontext.Cause(ctx) // returns myError func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc) { c := withCancel(parent) return c, func(cause error) { c.cancel(true, Canceled, cause) } } WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].\nWithCancelCause函数类似于WithCancel，但它返回的是一个CancelCauseFunc而不是CancelFunc。 Calling cancel with a non-nil error (the “cause”) records that error in ctx; it can then be retrieved using Cause(ctx).\n调用cancel函数时传入一个非nil的错误（即“cause”），会将该错误记录在ctx中；可以通过调用Cause(ctx)来检索该错误。 Calling cancel with nil sets the cause to Canceled.\n如果调用cancel函数时传入nil，则会将原因设置为Canceled。 Example use:\n示例用法： ctx, cancel := context.WithCancelCause(parent) cancel(myError) ctx.Err() // 返回 context.Canceled context.Cause(ctx) // 返回 myError Cause Cause函数用于检索已取消Context的原因。\n// Cause returns a non-nil error explaining why c was canceled. // The first cancellation of c or one of its parents sets the cause. // If that cancellation happened via a call to CancelCauseFunc(err), // then [Cause] returns err. // Otherwise Cause(c) returns the same value as c.Err(). // Cause returns nil if c has not been canceled yet. func Cause(c Context) error { if cc, ok := c.Value(\u0026cancelCtxKey).(*cancelCtx); ok { cc.mu.Lock() defer cc.mu.Unlock() return cc.cause } // There is no cancelCtxKey value, so we know that c is // not a descendant of some Context created by WithCancelCause. // Therefore, there is no specific cause to return. // If this is not one of the standard Context types, // it might still have an error even though it won't have a cause. return c.Err() } Cause 函数返回一个非nil的错误，解释为什么c被取消了。 第一个取消c或其父Context的操作会设置原因。 如果取消是通过调用CancelCauseFunc(err)发生的，那么Cause返回err。 否则，Cause(c)返回与c.Err()相同的值。 如果c尚未被取消，则Cause返回nil。 WithDeadline WithDeadline 返回基于父 Context 的新 Context 实例。这个新 Context 是父 Context 的一个副本，但它具有不同的截止时间。新Context的截止时间被调整为不晚于给定的d时间。d是一个time.Time类型的值，表示截止时间。如果父 context 的 deadline 早于 d ，调用WithDeadline(parent, d)在语义上等同于直接使用父Context。\n在以下任一情况下，Context.Done 返回的通道是关闭的：\ndeadline 过期了 返回的 CancelFunc 被调用了 父 context 的 Done channel 被关闭了 取消这个Context会释放与之关联的资源，因此代码应该在运行在这个Context中的操作完成后立即调用cancel函数。WithDeadline函数实际上是调用WithDeadlineCause函数，并将cause参数设置为nil。这意味着在截止时间到达时，不会设置具体的取消原因。\nWithDeadlineCause函数类似于WithDeadline，但它还会在截止时间到达时设置返回Context的取消原因。返回的CancelFunc不会设置原因。\n// WithDeadline returns a copy of the parent context with the deadline adjusted // to be no later than d. If the parent's deadline is already earlier than d, // WithDeadline(parent, d) is semantically equivalent to parent. The returned // [Context.Done] channel is closed when the deadline expires, when the returned // cancel function is called, or when the parent context's Done channel is // closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this [Context] complete. func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { return WithDeadlineCause(parent, d, nil) } // WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the // returned Context when the deadline is exceeded. The returned [CancelFunc] does // not set the cause. func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc) { if parent == nil { panic(\"cannot create context from nil parent\") } if cur, ok := parent.Deadline(); ok \u0026\u0026 cur.Before(d) { // The current deadline is already sooner than the new one. return WithCancel(parent) } c := \u0026timerCtx{ deadline: d, } c.cancelCtx.propagateCancel(parent, c) dur := time.Until(d) if dur \u003c= 0 { c.cancel(true, DeadlineExceeded, cause) // deadline has already passed return c, func() { c.cancel(false, Canceled, nil) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded, cause) }) } return c, func() { c.cancel(true, Canceled, nil) } } WithTimeout WithTimeout函数实际上是调用WithDeadline函数，并将截止时间设置为当前时间加上超时时间。取消这个Context会释放与之关联的资源，因此代码应该在运行在这个Context中的操作完成后立即调用cancel函数。\nWithTimeoutCause函数类似于WithTimeout，但它还会在超时时间到达时设置返回Context的取消原因。返回的CancelFunc不会设置原因。WithTimeoutCause函数实际上是调用WithDeadlineCause函数，并将截止时间设置为当前时间加上超时时间，同时传递一个取消原因。\n// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)). // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this [Context] complete: // //\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) { //\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond) //\tdefer cancel() // releases resources if slowOperation completes before timeout elapses //\treturn slowOperation(ctx) //\t} func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } // WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the // returned Context when the timeout expires. The returned [CancelFunc] does // not set the cause. func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc) { return WithDeadlineCause(parent, time.Now().Add(timeout), cause) } WithValue WithValue函数返回一个基于父Context的新Context实例，并在该Context中关联key和val。\n检查父Context是否为nil，如果是则引发panic。 检查键是否为nil，如果是则引发panic。 检查键是否是可比较的（comparable），如果不是则引发panic。 返回一个新的valueCtx实例，该实例包含父Context、键和值。 使用Context的值仅限于请求范围内的数据，这些数据在进程和API之间传递，而不应用于向函数传递可选参数。\n// WithValue returns a copy of parent in which the value associated with key is // val. // // Use context Values only for request-scoped data that transits processes and // APIs, not for passing optional parameters to functions. // // The provided key must be comparable and should not be of type // string or any other built-in type to avoid collisions between // packages using context. Users of WithValue should define their own // types for keys. To avoid allocating when assigning to an // interface{}, context keys often have concrete type // struct{}. Alternatively, exported context key variables' static // type should be a pointer or interface. func WithValue(parent Context, key, val any) Context { if parent == nil { panic(\"cannot create context from nil parent\") } if key == nil { panic(\"nil key\") } if !reflectlite.TypeOf(key).Comparable() { panic(\"key is not comparable\") } return \u0026valueCtx{parent, key, val} } 关于键的使用建议\n提供的键必须是可比较的，并且不应是字符串或其他内置类型，以避免在使用Context的包之间发生冲突。WithValue的用户应该为键定义自己的类型。为了避免在赋值给接口时分配内存，Context的键通常具有具体类型struct{}。或者，导出的Context键变量的静态类型应该是指针或接口。\n","wordCount":"2785","inLanguage":"en","image":"https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-07-26T00:00:00Z","dateModified":"2024-07-26T00:00:00Z","author":{"@type":"Person","name":"sirius1y"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sirius1y.top/posts/notes/go-srccode/go-context/"},"publisher":{"@type":"Organization","name":"Sirius' Blog","logo":{"@type":"ImageObject","url":"https://sirius1y.top/images/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a>&nbsp;»&nbsp;<a href=https://sirius1y.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【go的源码阅读】context的实现：context.go</h1><div class=post-meta><span title='2024-07-26 00:00:00 +0000 UTC'>July 26, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2785 words&nbsp;·&nbsp;sirius1y</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%90%86%e8%a7%a3context aria-label=理解Context>理解Context</a></li><li><a href=#%e5%85%b3%e4%ba%8econtext%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label=关于context的使用场景>关于context的使用场景</a></li><li><a href=#%e5%86%85%e5%ae%b9%e4%bb%8b%e7%bb%8d aria-label=内容介绍>内容介绍</a><ul><li><a href=#%e6%8e%a5%e5%8f%a3 aria-label=接口>接口</a><ul><li><a href=#contextcontext aria-label=context.Context>context.Context</a><ul><li><a href=#deadline- aria-label="Deadline( )">Deadline( )</a></li><li><a href=#done- aria-label="Done( )">Done( )</a></li><li><a href=#err- aria-label="Err( )">Err( )</a></li><li><a href=#value- aria-label="Value( )">Value( )</a></li></ul></li></ul></li><li><a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a><ul><li><a href=#emptyctx aria-label=emptyCtx>emptyCtx</a><ul><li><a href=#backgroundctx aria-label=backgroundCtx>backgroundCtx</a></li><li><a href=#todoctx aria-label=todoCtx>todoCtx</a></li></ul></li><li><a href=#cancelctx aria-label=cancelCtx>cancelCtx</a></li><li><a href=#timerctx aria-label=timerCtx>timerCtx</a></li><li><a href=#valuectx aria-label=valueCtx>valueCtx</a></li></ul></li><li><a href=#%e6%96%b9%e6%b3%95 aria-label=方法>方法</a><ul><li><a href=#background aria-label=Background>Background</a></li><li><a href=#todo aria-label=TODO>TODO</a></li><li><a href=#withcancel aria-label=WithCancel>WithCancel</a><ul><li><a href=#cancelfunc-%e7%b1%bb%e5%9e%8b aria-label="CancelFunc 类型"><strong>CancelFunc</strong> 类型</a></li><li><a href=#withcancel-%e5%87%bd%e6%95%b0 aria-label="WithCancel 函数"><strong>WithCancel</strong> 函数</a></li></ul></li><li><a href=#withcancelcause aria-label=WithCancelCause>WithCancelCause</a><ul><li><a href=#cancelcausefunc-%e7%b1%bb%e5%9e%8b aria-label="CancelCauseFunc 类型"><strong>CancelCauseFunc 类型</strong></a></li><li><a href=#withcancel-%e5%87%bd%e6%95%b0-1 aria-label="withCancel 函数"><strong>withCancel 函数</strong></a></li><li><a href=#withcancelcause-%e5%87%bd%e6%95%b0 aria-label="WithCancelCause 函数"><strong>WithCancelCause 函数</strong></a></li></ul></li><li><a href=#cause aria-label=Cause>Cause</a></li><li><a href=#withdeadline aria-label=WithDeadline>WithDeadline</a></li><li><a href=#withtimeout aria-label=WithTimeout>WithTimeout</a></li><li><a href=#withvalue aria-label=WithValue>WithValue</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=理解context>理解Context<a hidden class=anchor aria-hidden=true href=#理解context>#</a></h1><p>这篇文章介绍的很清楚：<a href=https://www.cnblogs.com/itbsl/p/14277002.html>深入理解Go Context</a></p><p>这个比较详细，但是层次不好：<a href=https://www.cnblogs.com/zhangboyu/p/7456606.html>理解GO CONTEXT机制</a></p><h1 id=关于context的使用场景>关于context的使用场景<a hidden class=anchor aria-hidden=true href=#关于context的使用场景>#</a></h1><p>context的主要使用场景在于：一个任务在处理的过程中可能会启动很多个协程来进行处理。在这个过程中，如果上游的任务想要取消，下游的任务也应当一起取消。context的任务就来了。</p><h1 id=内容介绍>内容介绍<a hidden class=anchor aria-hidden=true href=#内容介绍>#</a></h1><p>context包的内容可以概括为：1个接口，4个实现，6个方法</p><p><img loading=lazy src=https://img2020.cnblogs.com/blog/720430/202101/720430-20210114141813698-554893972.png alt=context包的内容></p><h2 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h2><h3 id=contextcontext>context.Context<a hidden class=anchor aria-hidden=true href=#contextcontext>#</a></h3><p>一个接口是指：<code>context.Context</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Context</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Deadline</span><span class=p>()</span> <span class=p>(</span><span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Done</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nf>Err</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=deadline->Deadline( )<a hidden class=anchor aria-hidden=true href=#deadline->#</a></h4><p>Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。</p><p><strong>函数签名</strong> <code>Deadline() (deadline time.Time, ok bool)</code></p><p><code>Deadline</code> 返回的时间 <code>deadline time.Time</code> 代表这个ctx应该被取消的时间。返回的 <code>ok</code> 如果是 <code>false</code> 表示这个context没有设置deadline。连续调用 <code>Deadline</code> 会返回相同的结果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// Deadline returns the time when work done on behalf of this context
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// should be canceled. Deadline returns ok==false when no deadline is
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// set. Successive calls to Deadline return the same results.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Deadline</span><span class=p>()</span> <span class=p>(</span><span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=done->Done( )<a hidden class=anchor aria-hidden=true href=#done->#</a></h4><p>Done方法返回一个信道（channel），当Context被撤销或过期时，该信道是关闭的，即它是一个表示Context是否已关闭的信号。</p><p><strong>函数签名</strong> <code>Done() &lt;-chan struct{}</code></p><p>Done方法返回一个关闭的通道代表这个context应该被取消，如果这个context永远不会被取消，则Done会返回nil，连续调用会返回相同的值。Done channel的关闭可能是异步的，在cancel函数之后。</p><ul><li>WithCancel 函数安排当 cancel 被调用的时候关闭Done</li><li>WithDeadline 安排当 deadline 过期的时候关闭Done</li><li>WithTimeout 安排当 timeout 过期的时候关闭Done</li></ul><p>Done 可以在 select 表达式中使用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// Done returns a channel that&#39;s closed when work done on behalf of this
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// context should be canceled. Done may return nil if this context can
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// never be canceled. Successive calls to Done return the same value.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// The close of the Done channel may happen asynchronously,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// after the cancel function returns.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// WithCancel arranges for Done to be closed when cancel is called;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// WithDeadline arranges for Done to be closed when the deadline
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// expires; WithTimeout arranges for Done to be closed when the timeout
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// elapses.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Done is provided for use in select statements:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  // Stream generates values with DoSomething and sends them to out
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  // until DoSomething returns an error or ctx.Done is closed.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  func Stream(ctx context.Context, out chan&lt;- Value) error {
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  	for {
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  		v, err := DoSomething(ctx)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  		if err != nil {
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  			return err
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  		}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  		select {
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  		case &lt;-ctx.Done():
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  			return ctx.Err()
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  		case out &lt;- v:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  		}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  	}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  }
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// See https://blog.golang.org/pipelines for more examples of how to use
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// a Done channel for cancellation.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Done</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span></code></pre></div><h4 id=err->Err( )<a hidden class=anchor aria-hidden=true href=#err->#</a></h4><p>当Done信道关闭后，Err方法表明Context被撤的原因。</p><p><strong>函数签名</strong> <code>Err() error</code></p><p>如果 Done 还没有关闭，Err() 返回nil；如果已经关闭了，Err() 会返回一个非空的error解释为什么关闭。</p><ul><li>如果上下文被取消，则返回 Canceled</li><li>如果上下文的截止日期已过，则返回 DeadlineExceeded。</li></ul><blockquote><p>Canceled 和 DeadlineExceeded 是两个 error，他们都是由 context.Err() 返回</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Canceled is the error returned by [Context.Err] when the context is canceled.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>Canceled</span> <span class=p>=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;context canceled&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// DeadlineExceeded is the error returned by [Context.Err] when the context&#39;s
</span></span></span><span class=line><span class=cl><span class=c1>// deadline passes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>DeadlineExceeded</span> <span class=kt>error</span> <span class=p>=</span> <span class=nx>deadlineExceededError</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>deadlineExceededError</span><span class=p>)</span> <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span>   <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;context deadline exceeded&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>deadlineExceededError</span><span class=p>)</span> <span class=nf>Timeout</span><span class=p>()</span> <span class=kt>bool</span>   <span class=p>{</span> <span class=k>return</span> <span class=kc>true</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>deadlineExceededError</span><span class=p>)</span> <span class=nf>Temporary</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=kc>true</span> <span class=p>}</span>
</span></span></code></pre></div></blockquote><p>当 Err() 返回非空错误之后，连续调用 Err() 会返回相同的错误</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// If Done is not yet closed, Err returns nil.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// If Done is closed, Err returns a non-nil error explaining why:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Canceled if the context was canceled
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// or DeadlineExceeded if the context&#39;s deadline passed.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// After Err returns a non-nil error, successive calls to Err return the same error.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Err</span><span class=p>()</span> <span class=kt>error</span>
</span></span></code></pre></div><h4 id=value->Value( )<a hidden class=anchor aria-hidden=true href=#value->#</a></h4><p>Value可以让Goroutine共享一些数据，当然获得数据是协程安全的。但使用这些数据的时候要注意同步，比如返回了一个map，而这个map的读写则要加锁。</p><p><strong>函数签名</strong> <code>Value(key any) any</code></p><p>Value() 返回传入的 key 在这个 context 中关联的 value；如果这个 key 没有关联值则会返回 nil 。连续调用相同的 key 会返回相同的结果。</p><p>Values 应该只用作传递跨进程和 API 边界的请求作用域数据，而不是用于传递函数的可选参数。</p><p>key 标识 Context 中的特定值。一个函数如果想要在 Context 中存储值，通常会在全局变量中分配一个 key ，然后使用该键作为 context.WithValue 和 Context.Value 的参数。</p><p>key 可以是任何支持相等的类型；软件包应将键定义为不导出的类型（变量名小写），以避免碰撞。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// Value returns the value associated with this context for key, or nil
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// if no value is associated with key. Successive calls to Value with
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// the same key returns the same result.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Use context values only for request-scoped data that transits
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// processes and API boundaries, not for passing optional parameters to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// functions.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// A key identifies a specific value in a Context. Functions that wish
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// to store values in Context typically allocate a key in a global
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// variable then use that key as the argument to context.WithValue and
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Context.Value. A key can be any type that supports equality;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// packages should define keys as an unexported type to avoid
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// collisions.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Packages that define a Context key should provide type-safe accessors
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// for the values stored using that key:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// Package user defines a User type that&#39;s stored in Contexts.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	package user
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	import &#34;context&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// User is the type of value stored in the Contexts.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	type User struct {...}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// key is an unexported type for keys defined in this package.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// This prevents collisions with keys defined in other packages.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	type key int
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// userKey is the key for user.User values in Contexts. It is
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// unexported; clients use user.NewContext and user.FromContext
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// instead of using this key directly.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	var userKey key
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// NewContext returns a new Context that carries value u.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	func NewContext(ctx context.Context, u *User) context.Context {
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 		return context.WithValue(ctx, userKey, u)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	// FromContext returns the User value stored in ctx, if any.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	func FromContext(ctx context.Context) (*User, bool) {
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 		u, ok := ctx.Value(userKey).(*User)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 		return u, ok
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 	}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=nx>any</span><span class=p>)</span> <span class=nx>any</span>
</span></span></code></pre></div><h2 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h2><h3 id=emptyctx>emptyCtx<a hidden class=anchor aria-hidden=true href=#emptyctx>#</a></h3><p>emptyCtx 是一个结构体，实现了 Context 接口中的所有方法</p><p>emptyCtx 永远不会被取消，没有vlue，没有deadline；他是backgroundCtx 和 todoCtx 的共同基础</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// An emptyCtx is never canceled, has no values, and has no deadline.
</span></span></span><span class=line><span class=cl><span class=c1>// It is the common base of backgroundCtx and todoCtx.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>emptyCtx</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Deadline</span><span class=p>()</span> <span class=p>(</span><span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Done</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Err</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>emptyCtx</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=nx>any</span><span class=p>)</span> <span class=nx>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=backgroundctx>backgroundCtx<a hidden class=anchor aria-hidden=true href=#backgroundctx>#</a></h4><p>结构体中包含了emptyCtx，它的 String 方法返回一个字符串"context.Background"</p><p>主要在 context.Background 中被返回</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>backgroundCtx</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>emptyCtx</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>backgroundCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=s>&#34;context.Background&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=todoctx>todoCtx<a hidden class=anchor aria-hidden=true href=#todoctx>#</a></h4><p>结构体中包含了emptyCtx，它的 String 方法返回一个字符串"context.TODO"</p><p>主要在 context.TODO 中被返回</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>todoCtx</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>emptyCtx</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>todoCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=s>&#34;context.TODO&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=cancelctx>cancelCtx<a hidden class=anchor aria-hidden=true href=#cancelctx>#</a></h3><p><code>cancelCtx</code>是一个可以被取消的Context。当它被取消时，它还会取消任何实现了<code>canceler</code>接口的子Context。</p><ul><li><code>Context</code>: 嵌入的<code>Context</code>接口，使得<code>cancelCtx</code>可以作为<code>Context</code>使用。</li><li><code>mu</code>: 一个互斥锁（<code>sync.Mutex</code>），用于保护以下字段。</li><li><code>done</code>: 一个<code>atomic.Value</code>，存储一个<code>chan struct{}</code>类型的通道，这个通道在第一次取消调用时会被关闭。</li><li><code>children</code>: 一个映射，存储所有实现了<code>canceler</code>接口的子Context。在第一次取消调用时，这个映射会被设置为nil。</li><li><code>err</code>: 一个错误，在第一次取消调用时会被设置为非nil值，表示Context已经被取消。</li><li><code>cause</code>: 一个错误，在第一次取消调用时会被设置为非nil值，表示取消的原因。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// A cancelCtx can be canceled. When canceled, it also cancels any children
</span></span></span><span class=line><span class=cl><span class=c1>// that implement canceler.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>cancelCtx</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Context</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>mu</span>       <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>            <span class=c1>// protects following fields
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>done</span>     <span class=nx>atomic</span><span class=p>.</span><span class=nx>Value</span>          <span class=c1>// of chan struct{}, created lazily, closed by first cancel call
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>children</span> <span class=kd>map</span><span class=p>[</span><span class=nx>canceler</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}</span> <span class=c1>// set to nil by the first cancel call
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>err</span>      <span class=kt>error</span>                 <span class=c1>// set to non-nil by the first cancel call
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>cause</span>    <span class=kt>error</span>                 <span class=c1>// set to non-nil by the first cancel call
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=nx>any</span><span class=p>)</span> <span class=nx>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>value</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>Done</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>d</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>d</span><span class=p>.(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>d</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>d</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>done</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>d</span><span class=p>.(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>)</span> <span class=nf>Err</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=timerctx>timerCtx<a hidden class=anchor aria-hidden=true href=#timerctx>#</a></h3><p>timerCtx 包含一个计时器和截止时间；</p><p><code>timerCtx</code> 嵌入了一个<code>cancelCtx</code>，以实现<code>Done</code>和<code>Err</code>方法。这意味着 <code>timerCtx</code> 可以直接使用 <code>cancelCtx</code> 的<code>Done</code>和<code>Err</code>方法来处理取消通知和错误状态。</p><p><code>timerCtx</code>实现取消操作时，首先会停止其计时器，然后委托<code>cancelCtx.cancel</code>方法来执行实际的取消操作。这意味着在取消<code>timerCtx</code>时，会先确保计时器不再触发，然后再进行取消操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to
</span></span></span><span class=line><span class=cl><span class=c1>// implement Done and Err. It implements cancel by stopping its timer then
</span></span></span><span class=line><span class=cl><span class=c1>// delegating to cancelCtx.cancel.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>timerCtx</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cancelCtx</span>
</span></span><span class=line><span class=cl>	<span class=nx>timer</span> <span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Timer</span> <span class=c1>// Under cancelCtx.mu.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>)</span> <span class=nf>Deadline</span><span class=p>()</span> <span class=p>(</span><span class=nx>deadline</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>deadline</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>contextName</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;.WithDeadline(&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>deadline</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span> <span class=o>+</span> <span class=s>&#34; [&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Until</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>deadline</span><span class=p>).</span><span class=nf>String</span><span class=p>()</span> <span class=o>+</span> <span class=s>&#34;])&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>)</span> <span class=nf>cancel</span><span class=p>(</span><span class=nx>removeFromParent</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>removeFromParent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Remove this timerCtx from its parent cancelCtx&#39;s children.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>removeChild</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=valuectx>valueCtx<a hidden class=anchor aria-hidden=true href=#valuectx>#</a></h3><p><code>valueCtx</code>结构体包含一个键值对，其中<code>key</code>和<code>val</code>字段分别表示键和值</p><p><code>valueCtx</code>实现了<code>Value</code>方法，用于检索与特定键关联的值。对于其他方法的调用，它会委托给嵌入的<code>Context</code></p><p><strong>stringify 函数尝试将任意类型的值转换为字符串，而不使用<code>fmt</code>包。</strong></p><ul><li>该函数用于<code>*valueCtx.String()</code>方法中，将键和值转换为字符串表示。</li><li>使用类型断言检查值的类型：<ul><li>如果是实现了<code>stringer</code>接口的类型，调用其<code>String</code>方法。</li><li>如果是字符串类型，直接返回该字符串。</li><li>如果是nil，返回字符串<code>"&lt;nil>"</code>。</li><li>其他情况，使用<code>reflectlite.TypeOf(v).String()</code>获取类型名称。</li></ul></li></ul><p><strong>String 方法返回<code>valueCtx</code>的字符串表示。</strong></p><ul><li>调用<code>contextName(c.Context)</code>获取父Context的名称。</li><li>使用<code>stringify</code>函数将键和值转换为字符串。</li><li>拼接这些字符串，形成最终的字符串表示。</li></ul><p><strong>Value 方法用于检索与特定键关联的值。</strong></p><ul><li>首先检查传入的<code>key</code>是否与<code>valueCtx</code>中的<code>key</code>匹配。<ul><li>如果匹配，返回对应的值<code>c.val</code>。</li></ul></li><li>如果不匹配，调用<code>value(c.Context, key)</code>从父Context中检索值。</li></ul><p><strong>value 函数用于在Context链中检索特定键的值。</strong></p><ul><li>使用一个无限循环遍历Context链。</li><li>使用类型断言检查当前Context的类型：<ul><li>如果是<code>*valueCtx</code>，检查键是否匹配，如果匹配则返回值，否则继续检查父Context。</li><li>如果是<code>*cancelCtx</code>，检查键是否为<code>&amp;cancelCtxKey</code>，如果是则返回Context本身，否则继续检查父Context。</li><li>如果是<code>withoutCancelCtx</code>，检查键是否为<code>&amp;cancelCtxKey</code>，如果是则返回nil，否则继续检查父Context。</li><li>如果是<code>*timerCtx</code>，检查键是否为<code>&amp;cancelCtxKey</code>，如果是则返回<code>&amp;ctx.cancelCtx</code>，否则继续检查父Context。</li><li>如果是<code>backgroundCtx</code>或<code>todoCtx</code>，直接返回nil。</li><li>默认情况下，调用当前Context的<code>Value</code>方法继续检索值。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// A valueCtx carries a key-value pair. It implements Value for that key and
</span></span></span><span class=line><span class=cl><span class=c1>// delegates all other calls to the embedded Context.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>valueCtx</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Context</span>
</span></span><span class=line><span class=cl>	<span class=nx>key</span><span class=p>,</span> <span class=nx>val</span> <span class=nx>any</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// stringify tries a bit to stringify v, without using fmt, since we don&#39;t
</span></span></span><span class=line><span class=cl><span class=c1>// want context depending on the unicode tables. This is only used by
</span></span></span><span class=line><span class=cl><span class=c1>// *valueCtx.String().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>stringify</span><span class=p>(</span><span class=nx>v</span> <span class=nx>any</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>s</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>stringer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=kt>string</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=kc>nil</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=s>&#34;&lt;nil&gt;&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>reflectlite</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>v</span><span class=p>).</span><span class=nf>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>valueCtx</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>contextName</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;.WithValue(&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nf>stringify</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;, &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=nf>stringify</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>val</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;)&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>valueCtx</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=nx>any</span><span class=p>)</span> <span class=nx>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>key</span> <span class=o>==</span> <span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>val</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>value</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>value</span><span class=p>(</span><span class=nx>c</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>any</span><span class=p>)</span> <span class=nx>any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>valueCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>val</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>cancelCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>withoutCancelCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// This implements Cause(ctx) == nil
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// when ctx is created using WithoutCancel.
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>c</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>timerCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>cancelCtxKey</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=o>&amp;</span><span class=nx>ctx</span><span class=p>.</span><span class=nx>cancelCtx</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>backgroundCtx</span><span class=p>,</span> <span class=nx>todoCtx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=方法>方法<a hidden class=anchor aria-hidden=true href=#方法>#</a></h2><h3 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h3><p><code>context.Background</code> 方法返回一个 non-nil 但是 empty 的一个 context。返回的这个context其实就是 emptyCtx ，外加了一个 String 方法</p><p><strong>函数调用场景</strong></p><p>这个方法主要在 main 函数中使用，作为 Context 树中的最高的节点</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Background returns a non-nil, empty [Context]. It is never canceled, has no
</span></span></span><span class=line><span class=cl><span class=c1>// values, and has no deadline. It is typically used by the main function,
</span></span></span><span class=line><span class=cl><span class=c1>// initialization, and tests, and as the top-level Context for incoming
</span></span></span><span class=line><span class=cl><span class=c1>// requests.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Background</span><span class=p>()</span> <span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>backgroundCtx</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=todo>TODO<a hidden class=anchor aria-hidden=true href=#todo>#</a></h3><p><code>context.TODO</code> 返回一个 non-nil 但是 empty 的一个context。返回的这个context其实就是 emptyCtx ，外加了一个 String 方法</p><p><strong>函数调用场景</strong></p><ul><li><strong>不明确使用哪个Context</strong>：在某些情况下，开发者可能不清楚应该使用哪个Context。可能因为代码中存在多个Context，而每个Context都有其特定的用途或生命周期，选择错误的Context可能会导致预期之外的行为。</li><li><strong>Context尚不可用</strong>：在代码的早期版本中，当时还没有引入Context作为函数参数。随着代码编写，开发者可能需要将Context参数添加到函数中，以便更好地管理请求的生命周期和取消操作。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// TODO returns a non-nil, empty [Context]. Code should use context.TODO when
</span></span></span><span class=line><span class=cl><span class=c1>// it&#39;s unclear which Context to use or it is not yet available (because the
</span></span></span><span class=line><span class=cl><span class=c1>// surrounding function has not yet been extended to accept a Context
</span></span></span><span class=line><span class=cl><span class=c1>// parameter).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>TODO</span><span class=p>()</span> <span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>todoCtx</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=withcancel>WithCancel<a hidden class=anchor aria-hidden=true href=#withcancel>#</a></h3><h4 id=cancelfunc-类型><strong>CancelFunc</strong> 类型<a hidden class=anchor aria-hidden=true href=#cancelfunc-类型>#</a></h4><p>CancelFunc 用于通知某个操作放弃其工作。调用这个函数意味着操作应该停止执行。</p><p>函数本身不会等待操作实际停止。它只是发送一个信号，告诉操作应该停止，但<strong>不会阻塞</strong>等待操作真正停止。</p><p>可以被多个goroutine同时调用。这意味着<strong>多个并发执行的goroutine可以独立地决定取消操作</strong>。</p><p>一旦<code>CancelFunc</code>被第一次调用，后续的调用将不会有任何效果。这确保了取消操作只会被执行一次，避免了重复取消的问题。</p><h4 id=withcancel-函数><strong>WithCancel</strong> 函数<a hidden class=anchor aria-hidden=true href=#withcancel-函数>#</a></h4><p><strong>函数签名</strong> <code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></p><p><code>WithCancel</code>函数返回一个基于父Context的新Context实例，并附带一个新的Done通道。</p><p>返回的Context的Done通道会在以下两种情况之一发生时关闭：</p><ol><li>返回的<code>cancel</code>函数被调用。</li><li>父Context的Done通道被关闭。</li></ol><p>取消这个Context会释放与之关联的资源，因此代码应该在运行在这个Context中的操作完成后立即调用<code>cancel</code>函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// A CancelFunc tells an operation to abandon its work.
</span></span></span><span class=line><span class=cl><span class=c1>// A CancelFunc does not wait for the work to stop.
</span></span></span><span class=line><span class=cl><span class=c1>// A CancelFunc may be called by multiple goroutines simultaneously.
</span></span></span><span class=line><span class=cl><span class=c1>// After the first call, subsequent calls to a CancelFunc do nothing.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>CancelFunc</span> <span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WithCancel returns a copy of parent with a new Done channel. The returned
</span></span></span><span class=line><span class=cl><span class=c1>// context&#39;s Done channel is closed when the returned cancel function is called
</span></span></span><span class=line><span class=cl><span class=c1>// or when the parent context&#39;s Done channel is closed, whichever happens first.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Canceling this context releases resources associated with it, so code should
</span></span></span><span class=line><span class=cl><span class=c1>// call cancel as soon as the operations running in this [Context] complete.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>WithCancel</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>cancel</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nf>withCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=withcancelcause>WithCancelCause<a hidden class=anchor aria-hidden=true href=#withcancelcause>#</a></h3><p><code>CancelCauseFunc</code>是一个用于取消操作并设置取消原因的函数类型，<code>WithCancelCause</code>函数用于创建一个可以被取消并记录原因的Context。</p><h4 id=cancelcausefunc-类型><strong>CancelCauseFunc 类型</strong><a hidden class=anchor aria-hidden=true href=#cancelcausefunc-类型>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause.
</span></span></span><span class=line><span class=cl><span class=c1>// This cause can be retrieved by calling [Cause] on the canceled Context or on
</span></span></span><span class=line><span class=cl><span class=c1>// any of its derived Contexts.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// If the context has already been canceled, CancelCauseFunc does not set the cause.
</span></span></span><span class=line><span class=cl><span class=c1>// For example, if childContext is derived from parentContext:
</span></span></span><span class=line><span class=cl><span class=c1>//   - if parentContext is canceled with cause1 before childContext is canceled with cause2,
</span></span></span><span class=line><span class=cl><span class=c1>//     then Cause(parentContext) == Cause(childContext) == cause1
</span></span></span><span class=line><span class=cl><span class=c1>//   - if childContext is canceled with cause2 before parentContext is canceled with cause1,
</span></span></span><span class=line><span class=cl><span class=c1>//     then Cause(parentContext) == cause1 and Cause(childContext) == cause2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>CancelCauseFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><p><strong>A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause.</strong></p><ul><li><code>CancelCauseFunc</code>是一个函数类型，类似于<code>CancelFunc</code>，但它还额外设置了取消的原因（cause）。</li></ul></li><li><p><strong>This cause can be retrieved by calling [Cause] on the canceled Context or on any of its derived Contexts.</strong></p><ul><li>这个取消原因可以通过调用<code>Cause</code>函数在已取消的Context或其派生的任何Context上检索。</li></ul></li><li><p><strong>If the context has already been canceled, CancelCauseFunc does not set the cause.</strong></p><ul><li>如果Context已经取消，<code>CancelCauseFunc</code>不会设置原因。</li></ul></li><li><p><strong>For example, if childContext is derived from parentContext:</strong></p><ul><li>例如，如果<code>childContext</code>是从<code>parentContext</code>派生的：<ul><li>如果<code>parentContext</code>在<code>childContext</code>之前被用<code>cause1</code>取消，那么<code>Cause(parentContext) == Cause(childContext) == cause1</code>。</li><li>如果<code>childContext</code>在<code>parentContext</code>之前被用<code>cause2</code>取消，那么<code>Cause(parentContext) == cause1</code>且<code>Cause(childContext) == cause2</code>。</li></ul></li></ul></li></ul><h4 id=withcancel-函数-1><strong>withCancel 函数</strong><a hidden class=anchor aria-hidden=true href=#withcancel-函数-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>withCancel</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>)</span> <span class=o>*</span><span class=nx>cancelCtx</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>parent</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;cannot create context from nil parent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>cancelCtx</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>propagateCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>withCancel 函数用于创建一个新的<code>cancelCtx</code>实例，并将其与父Context关联起来。</strong><ul><li>如果传入的<code>parent</code>为nil，则会引发panic。</li><li>创建一个新的<code>cancelCtx</code>实例，并调用<code>propagateCancel</code>方法将新Context与父Context关联起来。</li></ul></li></ul><h4 id=withcancelcause-函数><strong>WithCancelCause 函数</strong><a hidden class=anchor aria-hidden=true href=#withcancelcause-函数>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].
</span></span></span><span class=line><span class=cl><span class=c1>// Calling cancel with a non-nil error (the &#34;cause&#34;) records that error in ctx;
</span></span></span><span class=line><span class=cl><span class=c1>// it can then be retrieved using Cause(ctx).
</span></span></span><span class=line><span class=cl><span class=c1>// Calling cancel with nil sets the cause to Canceled.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Example use:
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	ctx, cancel := context.WithCancelCause(parent)
</span></span></span><span class=line><span class=cl><span class=c1>//	cancel(myError)
</span></span></span><span class=line><span class=cl><span class=c1>//	ctx.Err() // returns context.Canceled
</span></span></span><span class=line><span class=cl><span class=c1>//	context.Cause(ctx) // returns myError
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>WithCancelCause</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>cancel</span> <span class=nx>CancelCauseFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nf>withCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p><strong>WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].</strong></p><ul><li><code>WithCancelCause</code>函数类似于<code>WithCancel</code>，但它返回的是一个<code>CancelCauseFunc</code>而不是<code>CancelFunc</code>。</li></ul></li><li><p><strong>Calling cancel with a non-nil error (the &ldquo;cause&rdquo;) records that error in ctx; it can then be retrieved using Cause(ctx).</strong></p><ul><li>调用<code>cancel</code>函数时传入一个非nil的错误（即“cause”），会将该错误记录在<code>ctx</code>中；可以通过调用<code>Cause(ctx)</code>来检索该错误。</li></ul></li><li><p><strong>Calling cancel with nil sets the cause to Canceled.</strong></p><ul><li>如果调用<code>cancel</code>函数时传入nil，则会将原因设置为<code>Canceled</code>。</li></ul></li><li><p><strong>Example use:</strong></p><ul><li>示例用法：<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancelCause</span><span class=p>(</span><span class=nx>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>cancel</span><span class=p>(</span><span class=nx>myError</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span> <span class=c1>// 返回 context.Canceled
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>context</span><span class=p>.</span><span class=nf>Cause</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span> <span class=c1>// 返回 myError
</span></span></span></code></pre></div></li></ul></li></ul><h3 id=cause>Cause<a hidden class=anchor aria-hidden=true href=#cause>#</a></h3><p><code>Cause</code>函数用于检索已取消Context的原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Cause returns a non-nil error explaining why c was canceled.
</span></span></span><span class=line><span class=cl><span class=c1>// The first cancellation of c or one of its parents sets the cause.
</span></span></span><span class=line><span class=cl><span class=c1>// If that cancellation happened via a call to CancelCauseFunc(err),
</span></span></span><span class=line><span class=cl><span class=c1>// then [Cause] returns err.
</span></span></span><span class=line><span class=cl><span class=c1>// Otherwise Cause(c) returns the same value as c.Err().
</span></span></span><span class=line><span class=cl><span class=c1>// Cause returns nil if c has not been canceled yet.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Cause</span><span class=p>(</span><span class=nx>c</span> <span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>cc</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>cancelCtxKey</span><span class=p>).(</span><span class=o>*</span><span class=nx>cancelCtx</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>cc</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>cc</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>cc</span><span class=p>.</span><span class=nx>cause</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// There is no cancelCtxKey value, so we know that c is
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// not a descendant of some Context created by WithCancelCause.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Therefore, there is no specific cause to return.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// If this is not one of the standard Context types,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// it might still have an error even though it won&#39;t have a cause.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>Cause 函数返回一个非nil的错误，解释为什么c被取消了。</strong><ul><li>第一个取消c或其父Context的操作会设置原因。</li><li>如果取消是通过调用<code>CancelCauseFunc(err)</code>发生的，那么<code>Cause</code>返回<code>err</code>。</li><li>否则，<code>Cause(c)</code>返回与<code>c.Err()</code>相同的值。</li><li>如果c尚未被取消，则<code>Cause</code>返回nil。</li></ul></li></ul><h3 id=withdeadline>WithDeadline<a hidden class=anchor aria-hidden=true href=#withdeadline>#</a></h3><p><code>WithDeadline</code> 返回基于父 Context 的新 Context 实例。这个新 Context 是父 Context 的一个副本，但它具有不同的截止时间。新Context的截止时间被调整为不晚于给定的<code>d</code>时间。<code>d</code>是一个<code>time.Time</code>类型的值，表示截止时间。如果父 context 的 deadline 早于 d ，调用<code>WithDeadline(parent, d)</code>在语义上等同于直接使用父Context。</p><p>在以下任一情况下，Context.Done 返回的通道是关闭的：</p><ul><li>deadline 过期了</li><li>返回的 CancelFunc 被调用了</li><li>父 context 的 Done channel 被关闭了</li></ul><p>取消这个Context会释放与之关联的资源，因此代码应该在运行在这个Context中的操作完成后立即调用<code>cancel</code>函数。<code>WithDeadline</code>函数实际上是调用<code>WithDeadlineCause</code>函数，并将<code>cause</code>参数设置为<code>nil</code>。这意味着在截止时间到达时，不会设置具体的取消原因。</p><p><code>WithDeadlineCause</code>函数类似于<code>WithDeadline</code>，但它还会在截止时间到达时设置返回Context的取消原因。返回的<code>CancelFunc</code>不会设置原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// WithDeadline returns a copy of the parent context with the deadline adjusted
</span></span></span><span class=line><span class=cl><span class=c1>// to be no later than d. If the parent&#39;s deadline is already earlier than d,
</span></span></span><span class=line><span class=cl><span class=c1>// WithDeadline(parent, d) is semantically equivalent to parent. The returned
</span></span></span><span class=line><span class=cl><span class=c1>// [Context.Done] channel is closed when the deadline expires, when the returned
</span></span></span><span class=line><span class=cl><span class=c1>// cancel function is called, or when the parent context&#39;s Done channel is
</span></span></span><span class=line><span class=cl><span class=c1>// closed, whichever happens first.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Canceling this context releases resources associated with it, so code should
</span></span></span><span class=line><span class=cl><span class=c1>// call cancel as soon as the operations running in this [Context] complete.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>d</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>)</span> <span class=p>(</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>WithDeadlineCause</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>d</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the
</span></span></span><span class=line><span class=cl><span class=c1>// returned Context when the deadline is exceeded. The returned [CancelFunc] does
</span></span></span><span class=line><span class=cl><span class=c1>// not set the cause.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>WithDeadlineCause</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>d</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>(</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>parent</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;cannot create context from nil parent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>cur</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>parent</span><span class=p>.</span><span class=nf>Deadline</span><span class=p>();</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>cur</span><span class=p>.</span><span class=nf>Before</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// The current deadline is already sooner than the new one.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nf>WithCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>timerCtx</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>deadline</span><span class=p>:</span> <span class=nx>d</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span><span class=p>.</span><span class=nf>propagateCancel</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>dur</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Until</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>dur</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>DeadlineExceeded</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span> <span class=c1>// deadline has already passed
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>timer</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>AfterFunc</span><span class=p>(</span><span class=nx>dur</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>DeadlineExceeded</span><span class=p>,</span> <span class=nx>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nf>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=nx>Canceled</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=withtimeout>WithTimeout<a hidden class=anchor aria-hidden=true href=#withtimeout>#</a></h3><p><code>WithTimeout</code>函数实际上是调用<code>WithDeadline</code>函数，并将截止时间设置为当前时间加上超时时间。取消这个Context会释放与之关联的资源，因此代码应该在运行在这个Context中的操作完成后立即调用<code>cancel</code>函数。</p><p><code>WithTimeoutCause</code>函数类似于<code>WithTimeout</code>，但它还会在超时时间到达时设置返回Context的取消原因。返回的<code>CancelFunc</code>不会设置原因。<code>WithTimeoutCause</code>函数实际上是调用<code>WithDeadlineCause</code>函数，并将截止时间设置为当前时间加上超时时间，同时传递一个取消原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Canceling this context releases resources associated with it, so code should
</span></span></span><span class=line><span class=cl><span class=c1>// call cancel as soon as the operations running in this [Context] complete:
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
</span></span></span><span class=line><span class=cl><span class=c1>//		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
</span></span></span><span class=line><span class=cl><span class=c1>//		defer cancel()  // releases resources if slowOperation completes before timeout elapses
</span></span></span><span class=line><span class=cl><span class=c1>//		return slowOperation(ctx)
</span></span></span><span class=line><span class=cl><span class=c1>//	}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>timeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span> <span class=p>(</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>timeout</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the
</span></span></span><span class=line><span class=cl><span class=c1>// returned Context when the timeout expires. The returned [CancelFunc] does
</span></span></span><span class=line><span class=cl><span class=c1>// not set the cause.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>WithTimeoutCause</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>timeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>,</span> <span class=nx>cause</span> <span class=kt>error</span><span class=p>)</span> <span class=p>(</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>WithDeadlineCause</span><span class=p>(</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>timeout</span><span class=p>),</span> <span class=nx>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=withvalue>WithValue<a hidden class=anchor aria-hidden=true href=#withvalue>#</a></h3><p><code>WithValue</code>函数返回一个基于父Context的新Context实例，并在该Context中关联<code>key</code>和<code>val</code>。</p><ul><li>检查父Context是否为nil，如果是则引发panic。</li><li>检查键是否为nil，如果是则引发panic。</li><li>检查键是否是可比较的（comparable），如果不是则引发panic。</li><li>返回一个新的<code>valueCtx</code>实例，该实例包含父Context、键和值。</li></ul><p>使用Context的值仅限于请求范围内的数据，这些数据在进程和API之间传递，而不应用于向函数传递可选参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// WithValue returns a copy of parent in which the value associated with key is
</span></span></span><span class=line><span class=cl><span class=c1>// val.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Use context Values only for request-scoped data that transits processes and
</span></span></span><span class=line><span class=cl><span class=c1>// APIs, not for passing optional parameters to functions.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// The provided key must be comparable and should not be of type
</span></span></span><span class=line><span class=cl><span class=c1>// string or any other built-in type to avoid collisions between
</span></span></span><span class=line><span class=cl><span class=c1>// packages using context. Users of WithValue should define their own
</span></span></span><span class=line><span class=cl><span class=c1>// types for keys. To avoid allocating when assigning to an
</span></span></span><span class=line><span class=cl><span class=c1>// interface{}, context keys often have concrete type
</span></span></span><span class=line><span class=cl><span class=c1>// struct{}. Alternatively, exported context key variables&#39; static
</span></span></span><span class=line><span class=cl><span class=c1>// type should be a pointer or interface.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>WithValue</span><span class=p>(</span><span class=nx>parent</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>val</span> <span class=nx>any</span><span class=p>)</span> <span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>parent</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;cannot create context from nil parent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;nil key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>reflectlite</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>key</span><span class=p>).</span><span class=nf>Comparable</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;key is not comparable&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>valueCtx</span><span class=p>{</span><span class=nx>parent</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>val</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>关于键的使用建议</strong></p><p>提供的键必须是可比较的，并且不应是字符串或其他内置类型，以避免在使用Context的包之间发生冲突。<code>WithValue</code>的用户应该为键定义自己的类型。为了避免在赋值给接口时分配内存，Context的键通常具有具体类型<code>struct{}</code>。或者，导出的Context键变量的静态类型应该是指针或接口。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sirius1y.top/tags/go/>Go</a></li><li><a href=https://sirius1y.top/tags/context/>Context</a></li></ul><nav class=paginav><a class=prev href=https://sirius1y.top/posts/notes/basic/acap/><span class=title>« Prev</span><br><span>Wifi神秘消失排查经历</span>
</a><a class=next href=https://sirius1y.top/posts/notes/dev/dev-aorb-grpc/><span class=title>Next »</span><br><span>gRPC调用坎坷历程记录</span></a></nav></footer><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"yunyit/yunyit.github.io","data-repo-id":"R_kgDOKqkPYw","data-category":"Comments","data-category-id":"DIC_kwDOKqkPY84CceDi","data-mapping":"url","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"en",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>