<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Sirius' Blog</title>
<meta name=keywords content><meta name=description content="Posts - Sirius' Blog"><meta name=author content="sirius1y"><link rel=canonical href=https://sirius1y.top/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.3551607c8eb1ef998f0b6c81d22f9f03dd2c3b8ecaf983e42c023e8d41e39f66.css integrity="sha256-NVFgfI6x75mPC2yB0i+fA90sO47K+YPkLAI+jUHjn2Y=" rel="preload stylesheet" as=style><link rel=icon href=https://sirius1y.top/images/icon.png><link rel=icon type=image/png sizes=16x16 href=https://sirius1y.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sirius1y.top/favicon-32x32.png><link rel=apple-touch-icon href=https://sirius1y.top/apple-touch-icon.png><link rel=mask-icon href=https://sirius1y.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sirius1y.top/posts/index.xml><link rel=alternate hreflang=en href=https://sirius1y.top/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="Regret is the enemy."><meta property="og:type" content="website"><meta property="og:url" content="https://sirius1y.top/posts/"><meta property="og:image" content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Sirius' Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sirius1y.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Regret is the enemy."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sirius1y.top/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sirius1y.top/ accesskey=h title="Home (Alt + H)"><img src=https://sirius1y.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sirius1y.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sirius1y.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://sirius1y.top/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://sirius1y.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sirius1y.top/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Protobuf与gRPC初次使用</h2></header><div class=entry-content><p>在项目aorb中能够使用了微服务架构，然后引入了RPC，现在目前开发中，晚点再来完善这篇文章。现在先记录一些主要的概念。
IDL 接口定义语言 IDL（Interface Definition Language，接口定义语言）是一种用于定义软件组件之间接口的语言。IDL允许开发人员定义程序模块之间的接口，使得不同语言、平台和系统能够通过统一的接口进行通信。IDL的主要作用是定义数据类型和RPC（Remote Procedure Call，远程过程调用）的接口。
Proto接口定义的意义 Proto接口定义是指使用Protocol Buffers（protobuf）来定义数据结构和服务接口。protobuf是由Google开发的一种高效的二进制序列化格式，常用于配置文件、数据存储格式和通信协议。
跨语言支持：proto文件可以生成多种语言的代码，包括C++、Java、Python等，确保不同语言的系统可以互相通信。 高效传输：protobuf序列化后的数据体积小，解析速度快，适合网络传输。 版本兼容：proto文件可以通过增加新字段来实现向后兼容，不影响旧的客户端和服务器。 RPC（Remote Procedure Call，远程过程调用） RPC是一种通过网络从远程计算机程序上执行子程序的协议，仿佛是在本地执行一样。RPC隐藏了底层的网络通信细节，使得开发者可以像调用本地方法一样调用远程方法。
IDL和RPC的关系 IDL用于定义RPC接口，指定远程调用所需的参数和返回值类型。通过IDL定义的接口，可以自动生成客户端和服务器的桩代码（stub），这些代码负责处理序列化和反序列化、网络通信等底层细节，使得开发者可以专注于业务逻辑。
RESTful和gRPC的关系 RESTful和gRPC是两种不同的网络通信风格和框架，它们各自服务于不同的应用场景和需求。下面是它们之间的关系和区别：
RESTful (Representational State Transfer):
RESTful是一种基于HTTP协议的设计风格，它利用HTTP的方法（如GET、POST、PUT、DELETE等）来操作资源。 RESTful服务通常使用JSON或XML作为数据交换格式。 RESTful API设计简单，易于理解和使用，适合于跨平台和跨语言的场景。 由于基于HTTP，RESTful服务天然支持浏览器和各种HTTP客户端，易于缓存和负载均衡。 gRPC (Google Remote Procedure Call):
gRPC是由Google开发的高性能、开源的通用RPC框架。 gRPC使用Protocol Buffers（protobuf）作为接口定义语言（IDL）和数据序列化格式。 gRPC支持多种语言，并提供了跨语言的接口调用能力。 gRPC支持双向流式传输，适合于需要高性能和低延迟的场景，如微服务架构。 gRPC默认使用HTTP/2作为传输协议，支持多路复用和服务端推送等特性。 关系:
RESTful和gRPC都是用于构建分布式系统和微服务的通信协议，但它们的设计理念和使用场景有所不同。 RESTful更多地依赖于HTTP协议的特性，而gRPC则是一个独立的RPC框架，虽然它也使用了HTTP/2协议，但其核心在于protobuf的序列化和高效的RPC调用。 在实际应用中，选择RESTful还是gRPC取决于具体的需求，如性能要求、开发语言、团队熟悉度、生态系统支持等。 总结: RESTful和gRPC是两种互补的技术，它们各自在不同的领域和场景中发挥作用。开发者可以根据项目的具体需求和约束来选择最合适的通信方式。
.pb.go和_grpc.pb.go文件 在Go语言中使用Protocol Buffers (protobuf) 时，通常会生成两个主要的Go文件，分别是 auth_grpc.pb.go 和 auth.pb.go。这两个文件的作用如下：
auth.pb.go:
这个文件是由protobuf编译器根据.proto文件中的消息定义生成的。它包含了所有在.proto文件中定义的消息（messages）、枚举（enums）和任何其他非RPC相关的数据结构的Go语言实现。 auth.pb.go 文件主要负责序列化和反序列化数据，以及提供对消息结构的访问。例如，如果你在.proto文件中定义了一个名为 Token 的消息，auth.pb.go 将包含一个名为 Token 的Go结构体以及用于操作这个结构体的函数，如 Marshal、Unmarshal、New 等。 auth_grpc.pb.go:
这个文件是由protobuf编译器根据.proto文件中的服务定义（service definitions）生成的，特别是当.proto文件中包含了gRPC服务定义时。 auth_grpc....</p></div><footer class=entry-footer><span title='2024-06-18 00:00:00 +0000 UTC'>June 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;205 words&nbsp;·&nbsp;sirius1y</footer><a class=entry-link aria-label="post link to Protobuf与gRPC初次使用" href=https://sirius1y.top/posts/notes/dev/dev-aorb-protorpc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>golang八股文</h2></header><div class=entry-content><p>Golang goroutine内存泄漏 slice导致
获取长字符串中的一段，导致字符串未释放；
获取长slice中的一段导致长slice未释放；
在长切片中新建sllice导致泄漏
channel导致
发送不接受，接收不发送，nil channel
从 channel 里读，但是同时没有写入操作 向 无缓冲 channel 里写，但是同时没有读操作 向已满的 有缓冲 channel 里写，但是同时没有读操作 select操作在所有case上都阻塞() goroutine进入死循环，一直结束不了 向 nil channel 发送和接收数据都将会导致阻塞。这种情况可能在我们定义 channel 时忘记初始化的时候发生。 可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。
传统同步方式sync.mutex，sync.waitgroup导致
用了mutex加lock之后忘记unlock；
在一开始设置了具体数目的wg.wait(n)，但是有没有写够足够数量n的wg.Done()，导致wg.Wait()一直等待下去。（正确方式可以使用wg.Add(1)配合wg.Done使用）
Go调度器的GMP 在Go语言中，GPM通常指的是Goroutine、Processor和Machine，这是Go调度器（scheduler）的核心组成部分。下面是对每个部分的详细介绍：
Goroutine (G):
Goroutine是Go语言中的轻量级线程，由Go运行时管理。它们是并发的基本单位，可以被创建和销毁，而无需操作系统级别的线程开销。Goroutine的创建和销毁非常快速，因此可以轻松地创建成千上万个Goroutine。 Goroutine的调度是协作式的，这意味着一个Goroutine在执行时会自愿放弃CPU，让其他Goroutine有机会执行。这种协作式调度使得Go语言能够高效地利用多核处理器。 Processor (P):
Processor是Go调度器中的一个抽象概念，代表一个逻辑处理器。每个P都有一个本地运行队列，用于存储待执行的Goroutine。P的数量可以通过环境变量或运行时设置来调整，通常设置为CPU的核心数。 P的主要作用是管理Goroutine的执行。当一个Goroutine被调度到P上时，P会将其分配给一个可用的Machine（M）来执行。 Machine (M):
Machine代表一个操作系统线程。M与P关联，负责执行Goroutine。一个M可以与多个P关联，但在任何给定时间，一个M只能执行一个P的Goroutine。 M的主要作用是执行Goroutine的代码。当一个Goroutine被调度到M上时，M会执行该Goroutine的代码，直到该Goroutine自愿放弃CPU或被抢占。 Go调度器的工作原理是将Goroutine（G）分配到Processor（P）上，然后由Machine（M）执行。这种设计使得Go语言能够高效地利用多核处理器，并实现高并发。
在 Go 语言的运行时系统中，Goroutine（简称 G）有多种状态，用于描述它在不同时间点的执行情况。这些状态在 Go 的调度器（GMP 模型）中扮演重要角色。GMP 模型由 Goroutine（G）、工作线程（M）和处理器（P）三部分组成。以下是 G 的主要状态及其转变过程，以及它们与 GMP 模型的关系。
G 的状态 _Gidle：空闲状态。Goroutine 尚未被使用或已经完成执行，等待被分配新任务。 _Grunnable：可运行状态。Goroutine 已经准备好运行，等待被调度器选中运行。 _Grunning：运行状态。Goroutine 正在运行中。 _Gsyscall：系统调用状态。Goroutine 正在执行系统调用，处于阻塞状态，不会被调度器调度。 _Gwaiting：等待状态。Goroutine 在等待某个条件（例如通道操作、定时器、网络 I/O 等）完成。 _Gdead：死亡状态。Goroutine 已经完成执行，无法再被重新使用。 _Gcopystack：堆栈复制状态。Goroutine 的堆栈正在被复制，以调整其大小。 状态转变及其与 GMP 的关系 创建 Goroutine _Gidle -> _Grunnable 创建一个新的 Goroutine，并将其状态设置为 _Grunnable，表示该 Goroutine 准备好运行。 由 P 将新的 Goroutine 添加到其本地运行队列或全局运行队列中。 g := newGoroutine() g....</p></div><footer class=entry-footer><span title='2024-06-12 00:00:00 +0000 UTC'>June 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;498 words&nbsp;·&nbsp;sirius1y</footer><a class=entry-link aria-label="post link to golang八股文" href=https://sirius1y.top/posts/notes/jobhunter/go8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>system-design-prime</h2></header><div class=entry-content><p>system-design-prime 可用性模式 有两种支持高可用性的模式: 故障切换（fail-over）和复制（replication）。
故障切换 工作到备用切换（Active-passive） 关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。
宕机时间取决于备用服务器处于“热”待机状态还是需要从“冷”待机状态进行启动。只有工作服务器处理流量。
工作到备用的故障切换也被称为主从切换。
双工作切换（Active-active） 在双工作切换中，双方都在管控流量，在它们之间分散负载。
如果是外网服务器，DNS 将需要对两方都了解。如果是内网服务器，应用程序逻辑将需要对两方都了解。
双工作切换也可以称为主主切换。
缺陷：故障切换 故障切换需要添加额外硬件并增加复杂性。 如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据。 复制 主─从复制和主─主复制 这个主题进一步探讨了数据库部分:
主─从复制 主─主复制 CDN 内容分发网络 内容分发网络 CDN（英语：Content Delivery Network或Content Distribution Network）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。
CDN 的分类 Pull CDN 当用户第一次访问CDN的时候，CDN上是没有资源的，这时候CDN会去向服务器拉取资源。之后的访问就直接在CDN服务器中返回就可以。
push CDN 服务器可以在用户访问资源之前，把资源push给CDN服务器。
如何选择哪种CDN？ 关于使用哪种 CDN 类型的决定在很大程度上取决于流量和下载量。从长远来看，托管视频和播客（又名大量下载）的旅游博客会发现推送 CDN 更便宜、更高效，因为在您主动将其推送到 CDN 之前，CDN 不会重新下载内容。拉式 CDN 可以通过在 CDN 服务器上保留最受欢迎的内容来帮助高流量小下载的网站。内容的后续更新（或“拉取”）频率不足以使成本超过推送 CDN 的成本。
LoadBlancer 负载均衡器 负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:
防止请求进入不好的服务器 防止资源过载 帮助消除单一的故障点 通常会设置采用工作─备用 或 双工作 模式的多个负载均衡器，以免发生故障。...</p></div><footer class=entry-footer><span title='2024-06-12 00:00:00 +0000 UTC'>June 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;106 words&nbsp;·&nbsp;sirius1y</footer><a class=entry-link aria-label="post link to system-design-prime" href=https://sirius1y.top/posts/notes/jobhunter/system-design-prime/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MongoDB快速上手</h2></header><div class=entry-content><p>MongoDB安装 MongoDB官方的安装指南
Navicat客户端使用 可以在navicat上连上本地的mongodb使用，直观简单
Easy use (Terminal) 在终端中启动mongodb终端：
mongosh 以下是一些 MongoDB 的简单常用命令，可以帮助你快速上手并管理 MongoDB 数据库：
启动 MongoDB shell mongo 基本数据库操作 列出所有数据库 show dbs 切换到指定数据库（如果数据库不存在则创建新数据库） use mydatabase 显示当前数据库 db 删除当前数据库 db.dropDatabase() 集合操作 创建集合 db.createCollection('mycollection') 列出所有集合 show collections 删除集合 db.mycollection.drop() 文档操作 插入文档 db.mycollection.insertOne({name: "John", age: 30}) db.mycollection.insertMany([{name: "Alice", age: 25}, {name: "Bob", age: 27}]) 查找文档 db.mycollection.find() db.mycollection.find({name: "John"}) 查找并格式化输出 db.mycollection.find().pretty() 更新文档 db.mycollection.updateOne({name: "John"}, {$set: {age: 31}}) db.mycollection.updateMany({name: "Alice"}, {$set: {age: 26}}) 替换文档 db.mycollection.replaceOne({name: "John"}, {name: "John", age: 32, city: "New York"}) 删除文档 db....</p></div><footer class=entry-footer><span title='2024-06-06 00:00:00 +0000 UTC'>June 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;98 words&nbsp;·&nbsp;sirius1y</footer><a class=entry-link aria-label="post link to MongoDB快速上手" href=https://sirius1y.top/posts/notes/database/use-mongodb/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Flutter开发</h2></header><div class=entry-content><p>关键字 late late关键字允许变量将在稍后初始化，但必须在使用之前初始化。
这与 final 关键字不同，final 关键字用于声明必须在声明时或构造函数运行之前初始化的变量。
late 关键字的主要优点是可以提高性能，尤其是在构造函数中包含复杂初始化逻辑的类的情况下。通过使用 late 关键字，您可以推迟初始化，直到实际需要使用该变量时再进行初始化。这可以避免在构造函数中执行不必要的初始化工作，从而提高性能。
以下是一些有关如何使用 late 关键字的示例：
class MyWidget extends StatefulWidget { @override _MyWidgetState createState() => _MyWidgetState(); } class _MyWidgetState extends State&lt;MyWidget> { late String _data; @override void initState() { super.initState(); // 此处推迟了 _data 变量的初始化 _loadData(); } void _loadData() async { // 模拟异步数据加载 await Future.delayed(Duration(seconds: 2)); setState(() { _data = 'Data loaded'; }); } @override Widget build(BuildContext context) { if (_data == null) { return CircularProgressIndicator(); } return Text(_data); } } 在这个示例中，_data 变量使用 late 关键字声明。这意味着该变量不必在声明时或构造函数运行之前初始化。相反，它可以在稍后初始化，例如在 initState 方法中。这可以提高性能，因为只有在实际需要使用该变量时才会进行初始化。...</p></div><footer class=entry-footer><span title='2024-05-24 00:00:00 +0000 UTC'>May 24, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1578 words&nbsp;·&nbsp;sirius1y</footer><a class=entry-link aria-label="post link to Flutter开发" href=https://sirius1y.top/posts/notes/dev/dev-aorb-flutter/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://sirius1y.top/posts/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://sirius1y.top/posts/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span><a href=https://us.umami.is/websites/5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4 rel="noopener noreferrer" target=_blank>Analysis</a>
</span>|
<script defer src=https://cloud.umami.is/script.js data-website-id=5e6ac0c1-e2b2-4d0f-9542-b79ac2cf89c4></script><span><a href=https://beian.miit.gov.cn/ target=_blank>渝ICP备2024018631号</a>
</span>|
<span>&copy; 2025 <a href=https://sirius1y.top/>Sirius' Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>